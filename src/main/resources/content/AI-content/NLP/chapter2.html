<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>第2章：文本预处理 - 让机器读懂文字的第一步</title>
    <meta name="description" content="从一个搜索引擎的bug说起，深入理解分词、词性标注等文本预处理技术">

    <style>
        /* ===== CSS变量定义 ===== */
        :root {
            /* 渐变色 */
            --primary-gradient: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            --hero-gradient: linear-gradient(135deg, #f093fb 0%, #f5576c 100%);
            --card-gradient: linear-gradient(135deg, rgba(99, 102, 241, 0.1), rgba(139, 92, 246, 0.05));

            /* 主题色 */
            --primary: #6366f1;
            --primary-light: #818cf8;
            --primary-dark: #4f46e5;
            --secondary: #ec4899;
            --accent: #10b981;

            /* 功能色 */
            --success: #10b981;
            --warning: #f59e0b;
            --danger: #ef4444;
            --info: #3b82f6;

            /* 背景色 */
            --bg-dark: #0f172a;
            --bg-section: #1e293b;
            --bg-card: #334155;
            --bg-code: #0d1117;

            /* 文字色 */
            --text-primary: #f1f5f9;
            --text-secondary: #cbd5e1;
            --text-muted: #94a3b8;

            /* 其他 */
            --border-color: rgba(255, 255, 255, 0.1);
            --shadow: 0 20px 50px rgba(0, 0, 0, 0.5);
            --shadow-lg: 0 25px 50px -12px rgba(0, 0, 0, 0.5);
            --radius: 1rem;
            --transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
        }

        /* ===== 全局样式 ===== */
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        html {
            scroll-behavior: smooth;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
            background: var(--bg-dark);
            color: var(--text-primary);
            line-height: 1.7;
            font-size: 16px;
            overflow-x: hidden;
        }

        /* ===== 背景效果 ===== */
        .bg-pattern {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            opacity: 0.03;
            background-image:
                    repeating-linear-gradient(45deg, transparent, transparent 35px, rgba(255,255,255,.5) 35px, rgba(255,255,255,.5) 70px);
            pointer-events: none;
            z-index: 0;
        }

        .floating-shapes {
            position: fixed;
            width: 100%;
            height: 100%;
            overflow: hidden;
            z-index: 0;
        }

        .shape {
            position: absolute;
            opacity: 0.1;
            animation: float 20s infinite ease-in-out;
        }

        .shape:nth-child(1) {
            width: 80px;
            height: 80px;
            background: var(--primary);
            border-radius: 50%;
            left: 10%;
            top: 20%;
            animation-delay: 0s;
        }

        .shape:nth-child(2) {
            width: 120px;
            height: 120px;
            background: var(--secondary);
            border-radius: 38% 62% 63% 37% / 41% 44% 56% 59%;
            left: 70%;
            top: 60%;
            animation-delay: 2s;
        }

        .shape:nth-child(3) {
            width: 100px;
            height: 100px;
            background: var(--accent);
            border-radius: 63% 37% 54% 46% / 55% 48% 52% 45%;
            left: 40%;
            top: 80%;
            animation-delay: 4s;
        }

        @keyframes float {
            0%, 100% { transform: translateY(0) rotate(0deg); }
            33% { transform: translateY(-30px) rotate(120deg); }
            66% { transform: translateY(30px) rotate(240deg); }
        }

        /* ===== 布局 ===== */
        .container {
            max-width: 1200px;
            margin: 0 auto;
            padding: 0 1.5rem;
            position: relative;
            z-index: 1;
        }

        /* ===== 导航栏 ===== */
        .nav-header {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            background: rgba(15, 23, 42, 0.85);
            backdrop-filter: blur(20px);
            z-index: 1000;
            border-bottom: 1px solid var(--border-color);
            transition: var(--transition);
        }

        .nav-content {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 1rem 0;
        }

        .nav-title {
            display: flex;
            align-items: center;
            gap: 1rem;
        }

        .nav-title h1 {
            font-size: 1.25rem;
            font-weight: 600;
            background: var(--primary-gradient);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
        }

        .nav-menu {
            display: flex;
            gap: 1rem;
            align-items: center;
        }

        /* 进度条 */
        .progress-container {
            position: absolute;
            bottom: 0;
            left: 0;
            right: 0;
            height: 3px;
            background: rgba(255, 255, 255, 0.1);
        }

        .progress-bar {
            height: 100%;
            background: var(--primary-gradient);
            width: 0;
            transition: width 0.3s ease;
        }

        /* ===== 侧边栏 ===== */
        .sidebar {
            position: fixed;
            left: -300px;
            top: 60px;
            bottom: 0;
            width: 300px;
            background: var(--bg-section);
            border-right: 1px solid var(--border-color);
            padding: 2rem;
            overflow-y: auto;
            transition: transform 0.3s ease;
            z-index: 999;
            box-shadow: 5px 0 25px rgba(0, 0, 0, 0.5);
        }

        .sidebar.open {
            transform: translateX(300px);
        }

        .toc-title {
            color: var(--primary-light);
            margin-bottom: 1.5rem;
            font-size: 1.1rem;
            font-weight: 600;
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        .toc-section {
            margin-bottom: 1.5rem;
        }

        .toc-section-title {
            color: var(--text-muted);
            font-size: 0.75rem;
            text-transform: uppercase;
            letter-spacing: 0.05em;
            margin-bottom: 0.5rem;
            padding-left: 0.5rem;
        }

        .toc-item {
            display: block;
            padding: 0.75rem 1rem;
            color: var(--text-secondary);
            text-decoration: none;
            border-radius: 0.5rem;
            transition: all 0.3s ease;
            margin-bottom: 0.25rem;
            font-size: 0.95rem;
            position: relative;
            overflow: hidden;
        }

        .toc-item::before {
            content: '';
            position: absolute;
            left: 0;
            top: 0;
            bottom: 0;
            width: 3px;
            background: var(--primary);
            transform: translateX(-100%);
            transition: transform 0.3s ease;
        }

        .toc-item:hover {
            background: rgba(255, 255, 255, 0.05);
            color: var(--text-primary);
            padding-left: 1.5rem;
        }

        .toc-item.active {
            background: var(--card-gradient);
            color: var(--primary-light);
        }

        .toc-item.active::before {
            transform: translateX(0);
        }

        /* ===== 按钮样式 ===== */
        .btn {
            display: inline-flex;
            align-items: center;
            gap: 0.5rem;
            padding: 0.75rem 1.5rem;
            border-radius: 0.5rem;
            font-size: 0.95rem;
            font-weight: 500;
            text-decoration: none;
            transition: var(--transition);
            cursor: pointer;
            border: none;
            position: relative;
            overflow: hidden;
        }

        .btn::before {
            content: '';
            position: absolute;
            top: 50%;
            left: 50%;
            width: 0;
            height: 0;
            background: rgba(255, 255, 255, 0.2);
            border-radius: 50%;
            transform: translate(-50%, -50%);
            transition: width 0.5s, height 0.5s;
        }

        .btn:hover::before {
            width: 300px;
            height: 300px;
        }

        .btn-primary {
            background: var(--primary-gradient);
            color: white;
        }

        .btn-secondary {
            background: rgba(255, 255, 255, 0.1);
            color: var(--text-primary);
            border: 1px solid var(--border-color);
        }

        .btn-icon {
            background: transparent;
            padding: 0.5rem;
            color: var(--text-secondary);
        }

        /* ===== 主内容 ===== */
        main {
            margin-top: 80px;
            padding-bottom: 4rem;
            position: relative;
            z-index: 1;
        }

        /* ===== 章节头部 ===== */
        .chapter-hero {
            background: var(--hero-gradient);
            padding: 6rem 0;
            margin-bottom: 3rem;
            position: relative;
            overflow: hidden;
        }

        .chapter-hero::before {
            content: '';
            position: absolute;
            top: -50%;
            right: -50%;
            width: 200%;
            height: 200%;
            background: radial-gradient(circle, rgba(255,255,255,0.1) 0%, transparent 70%);
            animation: rotate 30s linear infinite;
        }

        @keyframes rotate {
            from { transform: rotate(0deg); }
            to { transform: rotate(360deg); }
        }

        .chapter-hero-content {
            text-align: center;
            color: white;
            position: relative;
            z-index: 1;
        }

        .chapter-hero h1 {
            font-size: 3.5rem;
            margin-bottom: 1rem;
            font-weight: 800;
            letter-spacing: -0.02em;
            animation: fadeInUp 0.8s ease;
        }

        .chapter-hero p {
            font-size: 1.5rem;
            opacity: 0.95;
            animation: fadeInUp 0.8s ease 0.2s both;
        }

        @keyframes fadeInUp {
            from {
                opacity: 0;
                transform: translateY(30px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        /* ===== 内容卡片 ===== */
        .section-card {
            background: var(--bg-section);
            border-radius: var(--radius);
            padding: 3rem;
            margin-bottom: 2rem;
            box-shadow: var(--shadow);
            position: relative;
            overflow: hidden;
        }

        .section-card::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            height: 3px;
            background: var(--primary-gradient);
            transform: scaleX(0);
            transform-origin: left;
            transition: transform 0.5s ease;
        }

        .section-card:hover::before {
            transform: scaleX(1);
        }

        .section-card h2 {
            color: var(--primary-light);
            margin-bottom: 2rem;
            font-size: 2.25rem;
            font-weight: 700;
        }

        .section-card h3 {
            color: var(--text-primary);
            margin: 2rem 0 1rem;
            font-size: 1.5rem;
            font-weight: 600;
        }

        /* ===== 故事卡片 ===== */
        .story-card {
            background: linear-gradient(135deg, rgba(236, 72, 153, 0.1), rgba(239, 68, 68, 0.1));
            border: 2px solid rgba(236, 72, 153, 0.3);
            border-radius: var(--radius);
            padding: 2.5rem;
            margin: 2rem 0;
            position: relative;
            overflow: hidden;
        }

        .story-card::after {
            content: '';
            position: absolute;
            top: -2px;
            left: -2px;
            right: -2px;
            bottom: -2px;
            background: var(--hero-gradient);
            z-index: -1;
            opacity: 0;
            transition: opacity 0.3s ease;
            border-radius: var(--radius);
        }

        .story-card:hover::after {
            opacity: 0.3;
        }

        .story-icon {
            font-size: 3rem;
            display: block;
            margin-bottom: 1rem;
            animation: pulse 2s ease-in-out infinite;
        }

        @keyframes pulse {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.1); }
        }

        /* ===== 代码块 ===== */
        .code-block {
            background: var(--bg-code);
            border: 1px solid #30363d;
            border-radius: 0.75rem;
            margin: 1.5rem 0;
            position: relative;
            overflow: hidden;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.5);
        }

        .code-header {
            background: #161b22;
            padding: 1rem 1.5rem;
            display: flex;
            justify-content: space-between;
            align-items: center;
            border-bottom: 1px solid #30363d;
        }

        .code-lang {
            color: var(--primary-light);
            font-size: 0.875rem;
            font-weight: 600;
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        .code-lang::before {
            content: '';
            width: 12px;
            height: 12px;
            background: var(--primary);
            border-radius: 50%;
            display: inline-block;
        }

        .code-actions {
            display: flex;
            gap: 0.5rem;
        }

        .code-btn {
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.2);
            color: var(--text-secondary);
            padding: 0.375rem 0.875rem;
            border-radius: 0.375rem;
            font-size: 0.75rem;
            cursor: pointer;
            transition: all 0.2s;
            font-weight: 500;
        }

        .code-btn:hover {
            background: var(--primary);
            color: white;
            border-color: var(--primary);
            transform: translateY(-1px);
        }

        .code-content {
            padding: 1.5rem;
            overflow-x: auto;
            font-family: 'SF Mono', 'Monaco', 'Inconsolata', 'Fira Code', monospace;
            font-size: 0.875rem;
            line-height: 1.7;
        }

        .code-content pre {
            margin: 0;
            color: #e6edf3;
        }

        .code-content.collapsed {
            max-height: 300px;
            overflow: hidden;
            position: relative;
        }

        .code-content.collapsed::after {
            content: '';
            position: absolute;
            bottom: 0;
            left: 0;
            right: 0;
            height: 100px;
            background: linear-gradient(transparent, var(--bg-code));
        }

        /* 代码高亮 */
        .keyword { color: #ff79c6; }
        .string { color: #f1fa8c; }
        .comment { color: #6272a4; }
        .function { color: #50fa7b; }
        .number { color: #bd93f9; }

        /* ===== 卡片网格 ===== */
        .card-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(320px, 1fr));
            gap: 2rem;
            margin: 2rem 0;
        }

        .info-card {
            background: var(--bg-card);
            border-radius: var(--radius);
            padding: 2rem;
            border: 1px solid var(--border-color);
            transition: all 0.3s ease;
            position: relative;
            overflow: hidden;
        }

        .info-card::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: var(--primary-gradient);
            opacity: 0;
            transition: opacity 0.3s ease;
        }

        .info-card:hover {
            transform: translateY(-5px);
            box-shadow: var(--shadow-lg);
            border-color: var(--primary);
        }

        .info-card:hover::before {
            opacity: 0.05;
        }

        .card-icon {
            font-size: 2.5rem;
            margin-bottom: 1rem;
            display: block;
        }

        .card-title {
            color: var(--primary-light);
            margin-bottom: 1rem;
            font-size: 1.25rem;
            font-weight: 600;
        }

        /* ===== 互动演示 ===== */
        .demo-container {
            background: linear-gradient(135deg, rgba(59, 130, 246, 0.1), rgba(139, 92, 246, 0.1));
            border: 2px solid rgba(59, 130, 246, 0.3);
            border-radius: var(--radius);
            padding: 2.5rem;
            margin: 2rem 0;
            position: relative;
            overflow: hidden;
        }

        .demo-container::before {
            content: '🧪';
            position: absolute;
            top: -20px;
            right: 20px;
            font-size: 4rem;
            opacity: 0.1;
        }

        .demo-input {
            width: 100%;
            padding: 1rem 1.5rem;
            background: var(--bg-dark);
            border: 2px solid var(--border-color);
            border-radius: 0.5rem;
            color: var(--text-primary);
            font-size: 1.1rem;
            margin-bottom: 1rem;
            transition: all 0.3s;
        }

        .demo-input:focus {
            outline: none;
            border-color: var(--primary);
            box-shadow: 0 0 0 3px rgba(99, 102, 241, 0.1);
        }

        .demo-button {
            background: var(--primary-gradient);
            color: white;
            border: none;
            padding: 1rem 2.5rem;
            border-radius: 0.5rem;
            font-size: 1rem;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s;
            position: relative;
            overflow: hidden;
        }

        .demo-button:hover {
            transform: translateY(-2px);
            box-shadow: 0 10px 20px rgba(99, 102, 241, 0.3);
        }

        .demo-result {
            margin-top: 2rem;
            padding: 1.5rem;
            background: var(--bg-dark);
            border-radius: 0.75rem;
            min-height: 120px;
            border: 1px solid var(--border-color);
        }

        /* ===== 分词展示 ===== */
        .token {
            display: inline-block;
            padding: 0.5rem 1.25rem;
            margin: 0.375rem;
            border-radius: 2rem;
            font-size: 1rem;
            font-weight: 500;
            transition: all 0.3s ease;
            cursor: pointer;
            position: relative;
            overflow: hidden;
        }

        .token::before {
            content: '';
            position: absolute;
            top: 50%;
            left: 50%;
            width: 0;
            height: 0;
            background: rgba(255, 255, 255, 0.2);
            border-radius: 50%;
            transform: translate(-50%, -50%);
            transition: width 0.5s, height 0.5s;
        }

        .token:hover::before {
            width: 100px;
            height: 100px;
        }

        .token:hover {
            transform: translateY(-3px) scale(1.05);
            box-shadow: 0 10px 20px rgba(0, 0, 0, 0.2);
        }

        .token-word {
            background: linear-gradient(135deg, rgba(59, 130, 246, 0.2), rgba(99, 102, 241, 0.2));
            border: 2px solid var(--info);
            color: var(--info);
        }

        .token-entity {
            background: linear-gradient(135deg, rgba(16, 185, 129, 0.2), rgba(34, 197, 94, 0.2));
            border: 2px solid var(--success);
            color: var(--success);
        }

        .token-pos {
            background: linear-gradient(135deg, rgba(236, 72, 153, 0.2), rgba(244, 114, 182, 0.2));
            border: 2px solid var(--secondary);
            color: var(--secondary);
            position: relative;
            padding-top: 2rem;
        }

        .pos-label {
            position: absolute;
            top: 0.25rem;
            left: 50%;
            transform: translateX(-50%);
            font-size: 0.65rem;
            background: var(--secondary);
            color: white;
            padding: 0.125rem 0.5rem;
            border-radius: 1rem;
        }

        /* ===== 流程图 ===== */
        .flow-diagram {
            background: var(--bg-card);
            border-radius: var(--radius);
            padding: 2.5rem;
            margin: 2rem 0;
            overflow-x: auto;
        }

        .flow-container {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 2rem;
            min-width: 800px;
            padding: 2rem 0;
        }

        .flow-step {
            background: var(--bg-section);
            border: 2px solid var(--border-color);
            border-radius: var(--radius);
            padding: 2rem;
            text-align: center;
            min-width: 150px;
            transition: all 0.3s ease;
            position: relative;
        }

        .flow-step:hover {
            transform: translateY(-5px);
            border-color: var(--primary);
            box-shadow: var(--shadow);
        }

        .flow-step-icon {
            font-size: 3rem;
            margin-bottom: 1rem;
            display: block;
        }

        .flow-step-title {
            font-weight: 600;
            color: var(--primary-light);
            margin-bottom: 0.5rem;
        }

        .flow-arrow {
            font-size: 2rem;
            color: var(--primary);
            animation: arrow-move 1.5s ease-in-out infinite;
        }

        @keyframes arrow-move {
            0%, 100% { transform: translateX(0); }
            50% { transform: translateX(10px); }
        }

        /* ===== 提示框 ===== */
        .tip {
            padding: 1.5rem 2rem;
            border-radius: var(--radius);
            margin: 2rem 0;
            border-left: 4px solid;
            position: relative;
            overflow: hidden;
        }

        .tip::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            opacity: 0.05;
            background: currentColor;
        }

        .tip-icon {
            font-size: 1.5rem;
            margin-right: 1rem;
            vertical-align: middle;
        }

        .tip.info {
            background: rgba(59, 130, 246, 0.1);
            border-color: var(--info);
            color: var(--text-primary);
        }

        .tip.warning {
            background: rgba(245, 158, 11, 0.1);
            border-color: var(--warning);
            color: var(--text-primary);
        }

        .tip.success {
            background: rgba(16, 185, 129, 0.1);
            border-color: var(--success);
            color: var(--text-primary);
        }

        .tip.danger {
            background: rgba(239, 68, 68, 0.1);
            border-color: var(--danger);
            color: var(--text-primary);
        }

        /* ===== 对比表格 ===== */
        .comparison-table {
            background: var(--bg-card);
            border-radius: var(--radius);
            overflow: hidden;
            margin: 2rem 0;
            box-shadow: var(--shadow);
        }

        .comparison-table table {
            width: 100%;
            border-collapse: collapse;
        }

        .comparison-table th {
            background: var(--primary-gradient);
            color: white;
            padding: 1.25rem;
            text-align: left;
            font-weight: 600;
            font-size: 0.95rem;
            text-transform: uppercase;
            letter-spacing: 0.05em;
        }

        .comparison-table td {
            padding: 1.25rem;
            border-bottom: 1px solid var(--border-color);
            transition: all 0.3s ease;
        }

        .comparison-table tr:hover td {
            background: rgba(99, 102, 241, 0.05);
        }

        .comparison-table tr:last-child td {
            border-bottom: none;
        }

        /* ===== 算法步骤 ===== */
        .algorithm-steps {
            background: linear-gradient(135deg, rgba(139, 92, 246, 0.1), rgba(167, 139, 250, 0.05));
            border: 2px solid rgba(139, 92, 246, 0.3);
            border-radius: var(--radius);
            padding: 2.5rem;
            margin: 2rem 0;
        }

        .step-item {
            display: flex;
            align-items: flex-start;
            margin-bottom: 2rem;
            position: relative;
        }

        .step-item:not(:last-child)::after {
            content: '';
            position: absolute;
            left: 24px;
            top: 50px;
            bottom: -30px;
            width: 2px;
            background: linear-gradient(to bottom, var(--primary), transparent);
        }

        .step-number {
            width: 48px;
            height: 48px;
            background: var(--primary-gradient);
            color: white;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: bold;
            font-size: 1.25rem;
            margin-right: 1.5rem;
            flex-shrink: 0;
            position: relative;
            z-index: 1;
        }

        .step-content h5 {
            color: var(--primary-light);
            margin-bottom: 0.5rem;
            font-size: 1.25rem;
        }

        /* ===== 数学公式 ===== */
        .math-display {
            background: linear-gradient(135deg, rgba(139, 92, 246, 0.05), rgba(99, 102, 241, 0.05));
            border: 2px solid rgba(139, 92, 246, 0.2);
            border-radius: var(--radius);
            padding: 2rem;
            margin: 2rem 0;
            text-align: center;
            font-size: 1.2rem;
            overflow-x: auto;
        }

        .math-formula {
            font-family: 'KaTeX_Math', 'Times New Roman', serif;
            font-style: italic;
            color: var(--primary-light);
            font-size: 1.3rem;
            margin: 1rem 0;
        }

        /* ===== 可视化组件 ===== */
        .visualization {
            background: var(--bg-card);
            border-radius: var(--radius);
            padding: 2rem;
            margin: 2rem 0;
            text-align: center;
        }

        .matrix-grid {
            display: inline-grid;
            gap: 0.5rem;
            padding: 1rem;
            background: rgba(0, 0, 0, 0.2);
            border-radius: 0.5rem;
            margin: 1rem auto;
        }

        .matrix-cell {
            width: 60px;
            height: 40px;
            display: flex;
            align-items: center;
            justify-content: center;
            background: rgba(99, 102, 241, 0.1);
            border: 1px solid var(--primary);
            border-radius: 0.375rem;
            font-size: 0.875rem;
            transition: all 0.3s ease;
            cursor: pointer;
        }

        .matrix-cell:hover {
            background: rgba(99, 102, 241, 0.3);
            transform: scale(1.1);
            box-shadow: 0 5px 15px rgba(99, 102, 241, 0.4);
        }

        /* ===== 快速导航 ===== */
        .quick-nav {
            position: fixed;
            right: 2rem;
            top: 50%;
            transform: translateY(-50%);
            z-index: 100;
            display: flex;
            flex-direction: column;
            gap: 1rem;
        }

        .quick-nav-item {
            width: 12px;
            height: 12px;
            background: var(--text-muted);
            border-radius: 50%;
            transition: all 0.3s;
            position: relative;
            cursor: pointer;
        }

        .quick-nav-item:hover,
        .quick-nav-item.active {
            background: var(--primary);
            transform: scale(1.5);
        }

        .quick-nav-tooltip {
            position: absolute;
            right: 20px;
            top: 50%;
            transform: translateY(-50%);
            background: var(--bg-dark);
            padding: 0.5rem 1rem;
            border-radius: 0.5rem;
            white-space: nowrap;
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.3s;
            border: 1px solid var(--border-color);
            font-size: 0.875rem;
        }

        .quick-nav-item:hover .quick-nav-tooltip {
            opacity: 1;
        }

        /* ===== 交互效果 ===== */
        .interactive-box {
            background: var(--bg-card);
            border: 2px dashed var(--primary);
            border-radius: var(--radius);
            padding: 2rem;
            margin: 2rem 0;
            text-align: center;
            cursor: pointer;
            transition: all 0.3s;
        }

        .interactive-box:hover {
            border-style: solid;
            background: rgba(99, 102, 241, 0.05);
        }

        /* ===== 响应式设计 ===== */
        @media (max-width: 768px) {
            .chapter-hero h1 {
                font-size: 2.5rem;
            }

            .section-card {
                padding: 2rem;
            }

            .quick-nav {
                display: none;
            }

            .card-grid {
                grid-template-columns: 1fr;
            }

            .flow-container {
                flex-direction: column;
                min-width: auto;
            }

            .flow-arrow {
                transform: rotate(90deg);
            }
        }

        /* ===== 加载动画 ===== */
        .loading-spinner {
            display: inline-block;
            width: 20px;
            height: 20px;
            border: 2px solid rgba(255, 255, 255, 0.3);
            border-radius: 50%;
            border-top-color: white;
            animation: spin 1s ease-in-out infinite;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        /* ===== 工具类 ===== */
        .text-center { text-align: center; }
        .text-muted { color: var(--text-muted); }
        .mt-1 { margin-top: 0.5rem; }
        .mt-2 { margin-top: 1rem; }
        .mt-3 { margin-top: 1.5rem; }
        .mt-4 { margin-top: 2rem; }
        .mb-1 { margin-bottom: 0.5rem; }
        .mb-2 { margin-bottom: 1rem; }
        .mb-3 { margin-bottom: 1.5rem; }
        .mb-4 { margin-bottom: 2rem; }
        .flex { display: flex; }
        .items-center { align-items: center; }
        .justify-between { justify-content: space-between; }
        .gap-1 { gap: 0.5rem; }
        .gap-2 { gap: 1rem; }
    </style>
</head>
<body>

<!-- 背景效果 -->
<div class="bg-pattern"></div>
<div class="floating-shapes">
    <div class="shape"></div>
    <div class="shape"></div>
    <div class="shape"></div>
</div>

<!-- 导航栏 -->
<nav class="nav-header">
    <div class="container">
        <div class="nav-content">
            <div class="nav-title">
                <button id="toggle-sidebar" class="btn btn-icon">
                    <svg width="20" height="20" fill="currentColor">
                        <path d="M3 5h14M3 10h14M3 15h14" stroke="currentColor" stroke-width="2" stroke-linecap="round"/>
                    </svg>
                </button>
                <h1>第2章：文本预处理</h1>
            </div>
            <div class="nav-menu">
                <button class="btn btn-icon" id="theme-toggle">🌙</button>
                <a href="#summary" class="btn btn-secondary">章节总结</a>
            </div>
        </div>
        <div class="progress-container">
            <div class="progress-bar" id="progress-bar"></div>
        </div>
    </div>
</nav>

<!-- 侧边栏 -->
<aside class="sidebar" id="sidebar">
    <h3 class="toc-title">
        <span>📚</span>
        <span>本章导航</span>
    </h3>

    <div class="toc-section">
        <div class="toc-section-title">开篇</div>
        <a href="#intro" class="toc-item active">序言：一个搜索引擎的Bug</a>
        <a href="#why-preprocess" class="toc-item">为什么需要预处理</a>
    </div>

    <div class="toc-section">
        <div class="toc-section-title">核心技术</div>
        <a href="#tokenization" class="toc-item">分词：切分的艺术</a>
        <a href="#tokenization-math" class="toc-item">分词的数学本质</a>
        <a href="#chinese-challenges" class="toc-item">中文分词挑战</a>
        <a href="#pos-tagging" class="toc-item">词性标注</a>
        <a href="#ner" class="toc-item">命名实体识别</a>
    </div>

    <div class="toc-section">
        <div class="toc-section-title">实践应用</div>
        <a href="#text-cleaning" class="toc-item">文本清洗</a>
        <a href="#tools-comparison" class="toc-item">工具对比</a>
        <a href="#practice" class="toc-item">构建预处理管道</a>
        <a href="#optimization" class="toc-item">性能优化</a>
    </div>

    <div class="toc-section">
        <div class="toc-section-title">总结展望</div>
        <a href="#summary" class="toc-item">本章总结</a>
        <a href="#exercises" class="toc-item">练习题</a>
    </div>
</aside>

<!-- 快速导航 -->
<div class="quick-nav" id="quick-nav">
    <div class="quick-nav-item active" data-section="intro">
        <span class="quick-nav-tooltip">开篇故事</span>
    </div>
    <div class="quick-nav-item" data-section="tokenization">
        <span class="quick-nav-tooltip">分词技术</span>
    </div>
    <div class="quick-nav-item" data-section="pos-tagging">
        <span class="quick-nav-tooltip">词性标注</span>
    </div>
    <div class="quick-nav-item" data-section="ner">
        <span class="quick-nav-tooltip">实体识别</span>
    </div>
    <div class="quick-nav-item" data-section="practice">
        <span class="quick-nav-tooltip">实战应用</span>
    </div>
</div>

<!-- 主内容 -->
<main>
    <!-- 章节标题 -->
    <section class="chapter-hero">
        <div class="container">
            <div class="chapter-hero-content">
                <h1>文本预处理</h1>
                <p>让机器读懂文字的第一步</p>
            </div>
        </div>
    </section>

    <div class="container">
        <!-- 序言 -->
        <section id="intro" class="section-card">
            <h2>📖 序言：一个价值千万的空格</h2>

            <div class="story-card">
                <span class="story-icon">🌙</span>
                <p><strong>2019年，北京，某互联网公司总部。</strong></p>
                <p class="mt-2">
                    凌晨3点，搜索团队的值班工程师小李被一阵急促的电话铃声惊醒。
                </p>
                <p class="mt-2">
                    "搜索崩了！iPhone11的所有商品都搜不出来了！"运营总监在电话那头几乎是在咆哮，"现在是iPhone11首发预售，每分钟损失几十万！"
                </p>
                <p class="mt-2">
                    小李睡意全无，立刻登录系统。奇怪的是，搜索"iPhone 11"（有空格）能找到成千上万的商品，但搜索"iPhone11"（无空格）却一片空白。
                </p>
                <p class="mt-2">
                    经过两个小时的奋战，真相终于浮出水面：系统把"iPhone11"当作一个完整的词，而商家上传时99%都写的是"iPhone 11"。<strong>一个小小的空格，让价值数千万的商品在用户面前"隐身"了。</strong>
                </p>
                <p class="mt-3 text-center" style="font-size: 1.25rem; color: var(--warning);">
                    💡 这个Bug揭示了一个深刻的问题：<br>
                    人类觉得"显而易见"的事，对机器来说却是巨大的鸿沟。
                </p>
            </div>

            <div class="demo-container">
                <h3 class="text-center mb-3" style="color: var(--primary-light);">🔍 一个空格的蝴蝶效应</h3>

                <div class="card-grid">
                    <div class="info-card">
                        <span class="card-icon">❌</span>
                        <h4 class="card-title">Bug发生时</h4>
                        <p>用户搜索："iPhone11"</p>
                        <p class="text-muted">数据库中："iPhone 11"</p>
                        <p class="mt-2 text-center" style="color: var(--danger);">
                            匹配失败！0个结果
                        </p>
                        <p class="mt-3 text-center" style="font-size: 2rem;">💸</p>
                        <p class="text-center" style="color: var(--danger);">损失：3000万/天</p>
                    </div>

                    <div class="info-card">
                        <span class="card-icon">✅</span>
                        <h4 class="card-title">修复后</h4>
                        <p>智能分词："iPhone11" → "iPhone" + "11"</p>
                        <p class="text-muted">数据库："iPhone 11" → "iPhone" + "11"</p>
                        <p class="mt-2 text-center" style="color: var(--success);">
                            匹配成功！50000+结果
                        </p>
                        <p class="mt-3 text-center" style="font-size: 2rem;">🎉</p>
                        <p class="text-center" style="color: var(--success);">效果：销量提升300%</p>
                    </div>
                </div>
            </div>

            <div class="tip info mt-4">
                <span class="tip-icon">🤔</span>
                <strong>深层思考：理解的鸿沟</strong>
                <p class="mt-2">这个Bug背后反映了人机理解的本质差异：</p>
                <ul class="mt-2">
                    <li><strong>人类理解：</strong>基于语义和经验。看到"iPhone11"，大脑会自动理解为"iPhone的第11代"</li>
                    <li><strong>机器理解：</strong>基于字符匹配。"iPhone11"就是13个字符组成的字符串，与"iPhone 11"完全不同</li>
                    <li><strong>解决之道：</strong>通过预处理，让机器学会"像人一样理解"文本</li>
                </ul>
            </div>
        </section>

        <!-- 为什么需要预处理 -->
        <section id="why-preprocess" class="section-card">
            <h2>🎯 为什么需要预处理？</h2>

            <div class="story-card">
                <span class="story-icon">🌍</span>
                <p><strong>想象一个场景：</strong>你是一个刚到地球的外星人，第一次看到人类的文字。</p>
                <p class="mt-2">你看到这样一段话：</p>
                <div class="code-block mt-2">
                    <div class="code-header">
                        <span class="code-lang">混乱的原始文本</span>
                    </div>
                    <div class="code-content">
                        <pre>"NLP很有趣！！！我爱N.L.P.~~~Machine Learning也不错😊😊😊"</pre>
                    </div>
                </div>
                <p class="mt-2">作为外星人的你会困惑：</p>
                <ul>
                    <li>NLP和N.L.P.是同一个东西吗？</li>
                    <li>那些感叹号和波浪线是什么意思？</li>
                    <li>😊这个黄色圆脸是文字的一部分吗？</li>
                    <li>Machine Learning是一个词还是两个词？</li>
                </ul>
                <p class="mt-3 text-center" style="color: var(--primary-light); font-size: 1.1rem;">
                    机器就像这个外星人，需要我们教它如何理解这些"混乱"的人类文本。
                </p>
            </div>

            <h3>文本预处理面临的三大挑战</h3>

            <div class="card-grid">
                <div class="info-card">
                    <span class="card-icon">🌐</span>
                    <h3 class="card-title">形式多样性挑战</h3>
                    <p>同样的意思，千变万化的写法</p>
                    <div class="demo-container mt-3" style="padding: 1.5rem;">
                        <p style="font-size: 0.9rem;">一个概念，多种表达：</p>
                        <ul style="font-size: 0.875rem;">
                            <li>人工智能 = AI = A.I. = Artificial Intelligence</li>
                            <li>二〇二三年 = 2023年 = 2023-年 = 贰零贰叁年</li>
                            <li>iPhone 12 = iPhone12 = iphone12 = IPHONE12</li>
                        </ul>
                    </div>
                </div>

                <div class="info-card">
                    <span class="card-icon">🧹</span>
                    <h3 class="card-title">噪声污染挑战</h3>
                    <p>真实文本像没打扫的房间</p>
                    <div class="demo-container mt-3" style="padding: 1.5rem;">
                        <p style="font-size: 0.9rem;">常见噪声：</p>
                        <code style="font-size: 0.75rem; display: block; white-space: pre-wrap;">
                            &lt;p&gt;这是&lt;b&gt;重要&lt;/b&gt;的内容！！！！&lt;/p&gt;
                            大家好👋👋👋今天天气真好☀️☀️
                            买买买买买买！！！便宜！！！</code>
                    </div>
                </div>

                <div class="info-card">
                    <span class="card-icon">📏</span>
                    <h3 class="card-title">粒度困境挑战</h3>
                    <p>什么是一个"词"？</p>
                    <div class="demo-container mt-3" style="padding: 1.5rem;">
                        <p style="font-size: 0.9rem;">分词歧义：</p>
                        <ul style="font-size: 0.875rem;">
                            <li>"研究生命起源" → 研究/生命/起源 or 研究生/命/起源？</li>
                            <li>"basketball" → basket/ball or basketball？</li>
                            <li>"机器学习算法" → 几个词？</li>
                        </ul>
                    </div>
                </div>
            </div>

            <div class="flow-diagram">
                <h4 class="text-center mb-4" style="color: var(--primary-light);">🎨 文本预处理：从混沌到秩序</h4>
                <div class="flow-container">
                    <div class="flow-step">
                        <span class="flow-step-icon">🌪️</span>
                        <div class="flow-step-title">原始文本</div>
                        <div class="text-muted" style="font-size: 0.875rem;">
                            混乱、噪声、不规范<br>
                            "NLP很牛👍👍iphone12"
                        </div>
                    </div>
                    <div class="flow-arrow">→</div>
                    <div class="flow-step">
                        <span class="flow-step-icon">🧹</span>
                        <div class="flow-step-title">清洗</div>
                        <div class="text-muted" style="font-size: 0.875rem;">
                            去噪、规范化<br>
                            "nlp很牛iphone12"
                        </div>
                    </div>
                    <div class="flow-arrow">→</div>
                    <div class="flow-step">
                        <span class="flow-step-icon">✂️</span>
                        <div class="flow-step-title">分词</div>
                        <div class="text-muted" style="font-size: 0.875rem;">
                            切分基本单元<br>
                            ["nlp","很","牛","iphone","12"]
                        </div>
                    </div>
                    <div class="flow-arrow">→</div>
                    <div class="flow-step">
                        <span class="flow-step-icon">🏷️</span>
                        <div class="flow-step-title">标注</div>
                        <div class="text-muted" style="font-size: 0.875rem;">
                            词性、实体识别<br>
                            [名词,副词,形容词,名词,数词]
                        </div>
                    </div>
                    <div class="flow-arrow">→</div>
                    <div class="flow-step">
                        <span class="flow-step-icon">📊</span>
                        <div class="flow-step-title">结构化数据</div>
                        <div class="text-muted" style="font-size: 0.875rem;">
                            机器可理解<br>
                            向量、特征、标签
                        </div>
                    </div>
                </div>
            </div>
        </section>

        <!-- 分词：切分的艺术 -->
        <section id="tokenization" class="section-card">
            <h2>✂️ 分词：切分的艺术</h2>

            <div class="story-card">
                <span class="story-icon">👽</span>
                <p><strong>外星人学中文的第一天</strong></p>
                <p class="mt-2">
                    想象你是一个外星语言学家，第一次接触地球文字。你的助手给你看了两段文本：
                </p>
                <div class="card-grid mt-3">
                    <div class="demo-container">
                        <p style="font-weight: bold;">英文：</p>
                        <p style="font-size: 1.2rem;">I love natural language processing</p>
                        <p class="text-muted mt-2">空格天然分隔，5个词一目了然</p>
                    </div>
                    <div class="demo-container">
                        <p style="font-weight: bold;">中文：</p>
                        <p style="font-size: 1.2rem;">我爱自然语言处理</p>
                        <p class="text-muted mt-2">没有分隔符，这是1个词还是7个词？</p>
                    </div>
                </div>
                <p class="mt-3 text-center" style="color: var(--primary-light); font-size: 1.1rem;">
                    欢迎来到分词的世界——一个看似简单实则深奥的领域！
                </p>
            </div>

            <h3>英文分词：规则明确的游戏</h3>

            <div class="demo-container">
                <div class="mb-3">
                    <p class="mb-2"><strong>原文：</strong></p>
                    <div class="code-block">
                        <div class="code-header">
                            <span class="code-lang">英文文本</span>
                        </div>
                        <div class="code-content">
                            <pre>"Natural Language Processing is amazing! Let's learn NLP together."</pre>
                        </div>
                    </div>
                </div>

                <div>
                    <p class="mb-2"><strong>分词结果：</strong></p>
                    <div>
                        <span class="token token-word">Natural</span>
                        <span class="token token-word">Language</span>
                        <span class="token token-word">Processing</span>
                        <span class="token token-word">is</span>
                        <span class="token token-word">amazing</span>
                        <span class="token" style="background: rgba(245, 158, 11, 0.2); border-color: var(--warning); color: var(--warning);">!</span>
                        <span class="token token-word">Let's</span>
                        <span class="token token-word">learn</span>
                        <span class="token token-word">NLP</span>
                        <span class="token token-word">together</span>
                        <span class="token" style="background: rgba(245, 158, 11, 0.2); border-color: var(--warning); color: var(--warning);">.</span>
                    </div>
                </div>

                <div class="tip info mt-3">
                    <span class="tip-icon">💡</span>
                    <strong>英文分词规则：</strong>
                    <ul class="mt-2">
                        <li>空格是天然的分隔符</li>
                        <li>标点符号需要单独处理</li>
                        <li>缩写（如Let's）需要特殊规则</li>
                        <li>大小写可能影响语义（Apple vs apple）</li>
                    </ul>
                </div>
            </div>

            <h3 class="mt-4">中文分词：没有空格的噩梦</h3>

            <div class="demo-container">
                <p class="mb-3"><strong>一个经典的例子：</strong></p>
                <p style="font-size: 1.5rem; text-align: center; padding: 1.5rem; background: var(--bg-dark); border-radius: 0.5rem;">
                    "南京市长江大桥"
                </p>

                <div class="mt-4">
                    <p class="mb-3"><strong>可能的分词结果：</strong></p>

                    <div class="mb-4">
                        <p style="color: var(--success); font-weight: 600;">✓ 场景1：介绍景点</p>
                        <div class="mb-2">
                            <span class="token token-word">南京市</span>
                            <span class="token token-word">长江大桥</span>
                        </div>
                        <p class="text-muted">→ 南京市的长江大桥（一座著名的桥）</p>
                    </div>

                    <div class="mb-4">
                        <p style="color: var(--danger); font-weight: 600;">✗ 场景2：新闻标题？</p>
                        <div class="mb-2">
                            <span class="token token-word">南京</span>
                            <span class="token token-word">市长</span>
                            <span class="token token-word">江大桥</span>
                        </div>
                        <p class="text-muted">→ 南京的市长叫江大桥？（这会是个大新闻！）</p>
                    </div>

                    <div>
                        <p style="color: var(--warning); font-weight: 600;">? 场景3：另一种可能</p>
                        <div class="mb-2">
                            <span class="token token-word">南京市长</span>
                            <span class="token token-word">江</span>
                            <span class="token token-word">大桥</span>
                        </div>
                        <p class="text-muted">→ 南京市长（叫）江（的那座）大桥？</p>
                    </div>
                </div>
            </div>

            <div class="tip warning mt-4">
                <span class="tip-icon">🤯</span>
                <strong>更多令人头疼的例子</strong>
                <div class="card-grid mt-3">
                    <div class="demo-container" style="padding: 1.5rem;">
                        <p style="font-weight: bold; color: var(--primary-light);">"结婚的和尚未结婚的"</p>
                        <p style="font-size: 0.9rem;" class="mt-2">
                            A: 结婚的 / 和 / 尚未 / 结婚的<br>
                            B: 结婚的 / 和尚 / 未 / 结婚的
                        </p>
                    </div>
                    <div class="demo-container" style="padding: 1.5rem;">
                        <p style="font-weight: bold; color: var(--primary-light);">"乒乓球拍卖完了"</p>
                        <p style="font-size: 0.9rem;" class="mt-2">
                            A: 乒乓球拍 / 卖 / 完了<br>
                            B: 乒乓 / 球拍卖 / 完了
                        </p>
                    </div>
                </div>
                <p class="mt-3 text-center" style="color: var(--warning); font-size: 1.1rem;">
                    💡 分词的核心挑战：如何让机器选择"最合理"的分词方案？
                </p>
            </div>

            <h3 class="mt-4">分词互动演示</h3>

            <div class="demo-container">
                <p class="mb-3"><strong>🧪 输入文本，实时查看分词效果：</strong></p>

                <textarea id="demo-input" class="demo-input" rows="3" placeholder="输入文本，例如：我爱自然语言处理">我爱自然语言处理技术</textarea>

                <div class="flex gap-2">
                    <button class="demo-button" onclick="tokenizeDemo()">
                        开始分词
                    </button>
                    <button class="btn btn-secondary" onclick="clearDemo()">
                        清空
                    </button>
                </div>

                <div id="demo-result" class="demo-result">
                    <p class="text-muted">分词结果将显示在这里...</p>
                </div>
            </div>
        </section>

        <!-- 分词的数学本质 -->
        <section id="tokenization-math" class="section-card">
            <h2>🔢 分词的数学本质：从直觉到概率</h2>

            <div class="story-card">
                <span class="story-icon">🎲</span>
                <p><strong>赌场里的语言学家</strong></p>
                <p class="mt-2">
                    想象你在一个特殊的赌场，这里的游戏是"猜分词"。庄家给你一个句子，你要猜测正确的分词方式。
                </p>
                <p class="mt-2">
                    句子："独立自主和平等互利的原则"
                </p>
                <p class="mt-2">你面前有多个筹码，每个代表一种分词方案：</p>
                <ul class="mt-2">
                    <li>方案A：独立自主 / 和 / 平等互利 / 的 / 原则（赔率1:2）</li>
                    <li>方案B：独立 / 自主 / 和平 / 等 / 互利 / 的 / 原则（赔率1:1000）</li>
                </ul>
                <p class="mt-3">
                    赔率反映了概率——<strong>最可能的分词方案有最低的赔率</strong>。这就是分词算法的核心思想！
                </p>
            </div>

            <div class="tip info">
                <span class="tip-icon">🎯</span>
                <strong>核心洞察：分词是一个概率优化问题</strong>
                <p class="mt-2">给定句子S，找到概率最大的分词序列W：</p>
                <p class="text-center" style="font-size: 1.3rem; margin: 1.5rem 0;">
                    最优分词 = 概率最大的分词方案
                </p>
            </div>

            <div class="math-display">
                <h4 class="mb-3" style="color: var(--primary-light);">📊 概率模型的数学表达</h4>

                <div style="background: rgba(0, 0, 0, 0.2); padding: 2rem; border-radius: 0.5rem;">
                    <p class="mb-3"><strong>目标：</strong>给定句子S = "南京市长江大桥"，找到最优分词W*</p>

                    <div class="math-formula">
                        W* = argmax<sub>W</sub> P(W|S)
                    </div>
                    <p class="text-muted text-center">（在所有可能的分词W中，找到给定S时概率最大的）</p>

                    <div class="mt-4">
                        <p class="mb-2"><strong>贝叶斯变换：</strong></p>
                        <div class="math-formula">
                            P(W|S) = P(S|W) × P(W) / P(S)
                        </div>
                    </div>

                    <div class="tip success mt-4">
                        <span class="tip-icon">✨</span>
                        <strong>关键简化：</strong>
                        <ul class="mt-2">
                            <li>P(S|W) = 1（给定分词后，句子是确定的）</li>
                            <li>P(S)是常数（对所有分词方案都一样）</li>
                            <li>因此：<strong>W* = argmax<sub>W</sub> P(W)</strong></li>
                        </ul>
                    </div>
                </div>
            </div>

            <div class="algorithm-steps">
                <h4 class="mb-4" style="color: var(--primary-light);">🎲 用概率选择最佳分词</h4>

                <div class="step-item">
                    <div class="step-number">1</div>
                    <div class="step-content">
                        <h5>统计词频，计算概率</h5>
                        <p>从海量文本中学习每个词出现的概率</p>
                        <div class="code-block mt-3">
                            <div class="code-header">
                                <span class="code-lang">词频统计示例</span>
                            </div>
                            <div class="code-content">
                                <pre>语料库统计（1亿词）：
"南京市"出现12000次 → P("南京市") = 0.00012
"长江大桥"出现2000次 → P("长江大桥") = 0.00002
"市长"出现10000次 → P("市长") = 0.0001
"江大桥"出现1次 → P("江大桥") = 0.00000001</pre>
                            </div>
                        </div>
                    </div>
                </div>

                <div class="step-item">
                    <div class="step-number">2</div>
                    <div class="step-content">
                        <h5>列举所有可能的分词</h5>
                        <p>像枚举密码组合一样，列出所有可能</p>
                        <div class="card-grid mt-3">
                            <div class="demo-container" style="padding: 1rem;">
                                <p style="font-size: 0.9rem;">方案1：南京市/长江大桥</p>
                                <p style="font-size: 0.9rem;">方案2：南京/市长/江大桥</p>
                                <p style="font-size: 0.9rem;">方案3：南京市/长江/大桥</p>
                            </div>
                            <div class="demo-container" style="padding: 1rem;">
                                <p style="font-size: 0.9rem;">方案4：南/京市/长江大桥</p>
                                <p style="font-size: 0.9rem;">方案5：南京市长/江/大桥</p>
                                <p style="font-size: 0.9rem;">...</p>
                            </div>
                        </div>
                    </div>
                </div>

                <div class="step-item">
                    <div class="step-number">3</div>
                    <div class="step-content">
                        <h5>计算每种分词的联合概率</h5>
                        <p>假设词之间独立，概率相乘</p>
                        <div class="code-block mt-3">
                            <div class="code-header">
                                <span class="code-lang">概率计算</span>
                            </div>
                            <div class="code-content">
                                <pre>P(方案1) = P(南京市) × P(长江大桥)
         = 0.00012 × 0.00002 = 2.4×10⁻⁹ <span class="comment">✅ 最大！</span>

P(方案2) = P(南京) × P(市长) × P(江大桥)
         = 0.0001 × 0.0001 × 0.00000001 = 1×10⁻¹³</pre>
                            </div>
                        </div>
                    </div>
                </div>

                <div class="step-item">
                    <div class="step-number">4</div>
                    <div class="step-content">
                        <h5>选择概率最大的方案</h5>
                        <p style="color: var(--success); font-size: 1.1rem;">✓ 获胜者："南京市 / 长江大桥"</p>
                        <p class="mt-2 text-muted">
                            这符合我们的直觉——常见的词组合比罕见的组合更可能是正确答案！
                        </p>
                    </div>
                </div>
            </div>

            <div class="tip danger mt-4">
                <span class="tip-icon">💡</span>
                <strong>效率问题：指数爆炸的噩梦</strong>
                <p class="mt-2">等等！如果句子有n个字符，理论上有2<sup>n-1</sup>种分词方式！</p>

                <div class="visualization mt-3">
                    <div class="matrix-grid" style="grid-template-columns: repeat(3, 1fr);">
                        <div class="matrix-cell">10个字</div>
                        <div class="matrix-cell">→</div>
                        <div class="matrix-cell">512种分词</div>
                        <div class="matrix-cell">20个字</div>
                        <div class="matrix-cell">→</div>
                        <div class="matrix-cell">524,288种分词</div>
                        <div class="matrix-cell">30个字</div>
                        <div class="matrix-cell">→</div>
                        <div class="matrix-cell" style="color: var(--danger);">536,870,912种分词 😱</div>
                    </div>
                </div>

                <div class="mt-4">
                    <h4 style="color: var(--primary-light);">🚀 解决方案：动态规划（Viterbi算法）</h4>
                    <p class="mt-2">核心思想：最优路径的子路径也是最优的</p>

                    <div class="code-block mt-3">
                        <div class="code-header">
                            <span class="code-lang">动态规划公式</span>
                        </div>
                        <div class="code-content">
                            <pre>dp[i] = max{ dp[j] × P(word[j:i]) } for all valid j < i</pre>
                        </div>
                    </div>
                    <p class="mt-2 text-center">
                        时间复杂度：从O(2<sup>n</sup>) 降到 O(n²×m)，其中m是词典大小
                    </p>
                </div>
            </div>

            <div class="visualization mt-4">
                <h4 class="text-center mb-3" style="color: var(--primary-light);">🎯 动态规划可视化</h4>

                <p class="text-center mb-3">句子："我爱北京天安门"</p>

                <div class="text-center">
                    <svg width="600" height="300" viewBox="0 0 600 300" style="max-width: 100%;">
                        <!-- 节点 -->
                        <circle cx="50" cy="150" r="20" fill="#3b82f6" />
                        <text x="50" y="155" text-anchor="middle" fill="white" font-size="12">始</text>

                        <circle cx="150" cy="80" r="20" fill="#8b5cf6" />
                        <text x="150" y="85" text-anchor="middle" fill="white" font-size="12">我</text>

                        <circle cx="250" cy="80" r="20" fill="#8b5cf6" />
                        <text x="250" y="85" text-anchor="middle" fill="white" font-size="12">爱</text>

                        <circle cx="350" cy="80" r="20" fill="#8b5cf6" />
                        <text x="350" y="85" text-anchor="middle" fill="white" font-size="12">北京</text>

                        <circle cx="450" cy="80" r="20" fill="#8b5cf6" />
                        <text x="450" y="85" text-anchor="middle" fill="white" font-size="12">天安门</text>

                        <circle cx="550" cy="150" r="20" fill="#22c55e" />
                        <text x="550" y="155" text-anchor="middle" fill="white" font-size="12">终</text>

                        <!-- 其他可能的节点 -->
                        <circle cx="250" cy="220" r="20" fill="#ef4444" opacity="0.5" />
                        <text x="250" y="225" text-anchor="middle" fill="white" font-size="12">爱北</text>

                        <circle cx="350" cy="220" r="20" fill="#ef4444" opacity="0.5" />
                        <text x="350" y="225" text-anchor="middle" fill="white" font-size="12">京天</text>

                        <!-- 最优路径（实线） -->
                        <path d="M 70 150 L 130 80" stroke="#22c55e" stroke-width="3" fill="none" />
                        <path d="M 170 80 L 230 80" stroke="#22c55e" stroke-width="3" fill="none" />
                        <path d="M 270 80 L 330 80" stroke="#22c55e" stroke-width="3" fill="none" />
                        <path d="M 370 80 L 430 80" stroke="#22c55e" stroke-width="3" fill="none" />
                        <path d="M 470 80 L 530 150" stroke="#22c55e" stroke-width="3" fill="none" />

                        <!-- 其他路径（虚线） -->
                        <path d="M 170 80 L 230 220" stroke="#ef4444" stroke-width="1" fill="none" stroke-dasharray="5,5" opacity="0.5" />
                        <path d="M 270 220 L 330 220" stroke="#ef4444" stroke-width="1" fill="none" stroke-dasharray="5,5" opacity="0.5" />

                        <!-- 概率标注 -->
                        <text x="100" y="110" font-size="10" fill="#cbd5e1">0.8</text>
                        <text x="200" y="70" font-size="10" fill="#cbd5e1">0.9</text>
                        <text x="300" y="70" font-size="10" fill="#cbd5e1">0.95</text>
                        <text x="400" y="70" font-size="10" fill="#cbd5e1">0.98</text>
                        <text x="500" y="110" font-size="10" fill="#cbd5e1">1.0</text>
                    </svg>
                </div>

                <p class="mt-3 text-center text-muted">
                    绿色路径：最优分词路径（概率最大）<br>
                    红色路径：其他可能但概率较低的路径
                </p>
            </div>
        </section>

        <!-- 中文分词挑战 -->
        <section id="chinese-challenges" class="section-card">
            <h2>🀄 中文分词：理想与现实的差距</h2>

            <div class="story-card">
                <span class="story-icon">🏥</span>
                <p><strong>一个医疗AI的困境</strong></p>
                <p class="mt-2">
                    2020年，某医院部署了一个医疗问答AI。上线第一天就闹了笑话：
                </p>
                <div class="code-block mt-3">
                    <div class="code-header">
                        <span class="code-lang">对话记录</span>
                    </div>
                    <div class="code-content">
                        <pre>患者："我最近总是失眠多梦怎么办？"
AI分词：失眠 / 多 / 梦 / 怎么办
AI回复："您好，关于多个梦的问题..."</pre>
                    </div>
                </div>
                <p class="mt-3">
                    问题出在哪？AI不认识"多梦"这个医学术语，把它拆成了"多"和"梦"。
                </p>
                <p class="mt-2 text-center" style="color: var(--warning); font-size: 1.1rem;">
                    这揭示了中文分词的核心挑战：<strong>领域新词层出不穷！</strong>
                </p>
            </div>

            <div class="comparison-table">
                <table>
                    <thead>
                    <tr>
                        <th>挑战类型</th>
                        <th>实际例子</th>
                        <th>为什么困难</th>
                        <th>解决思路</th>
                    </tr>
                    </thead>
                    <tbody>
                    <tr>
                        <td><strong>歧义切分</strong></td>
                        <td>
                            "研究生命起源"<br>
                            → 研究/生命/起源 ✓<br>
                            → 研究生/命/起源 ✗
                        </td>
                        <td>同样的字符串有多种合理切分</td>
                        <td>结合上下文，使用N-gram模型</td>
                    </tr>
                    <tr>
                        <td><strong>未登录词</strong></td>
                        <td>
                            新词：元宇宙、内卷、躺平<br>
                            人名：易烊千玺、欧阳娜娜<br>
                            品牌：蔚来、理想、小鹏
                        </td>
                        <td>词典永远跟不上语言发展</td>
                        <td>新词发现算法、在线学习</td>
                    </tr>
                    <tr>
                        <td><strong>语言混杂</strong></td>
                        <td>
                            "用Python写NLP很cool"<br>
                            "买了3个N95口罩"<br>
                            "B站UP主"
                        </td>
                        <td>中英文、数字混合，边界模糊</td>
                        <td>多语言统一建模</td>
                    </tr>
                    <tr>
                        <td><strong>领域特殊性</strong></td>
                        <td>
                            医学：甲状腺功能亢进症<br>
                            金融：股权激励计划<br>
                            法律：不当得利返还请求权
                        </td>
                        <td>专业术语长、结构复杂</td>
                        <td>领域词典、迁移学习</td>
                    </tr>
                    </tbody>
                </table>
            </div>

            <h3 class="mt-4">主流分词工具实战对比</h3>

            <div class="code-block">
                <div class="code-header">
                    <span class="code-lang">Python - 分词工具对比</span>
                    <div class="code-actions">
                        <button class="code-btn" onclick="toggleCode(this)">展开</button>
                        <button class="code-btn" onclick="copyCode(this)">复制</button>
                    </div>
                </div>
                <div class="code-content collapsed">
                    <pre><span class="comment"># 测试不同分词工具的效果</span>
<span class="keyword">import</span> jieba
<span class="keyword">import</span> pkuseg
<span class="keyword">import</span> thulac

<span class="comment"># 测试文本：包含歧义、新词、专业术语</span>
test_cases = [
    <span class="string">"南京市长江大桥"</span>,
    <span class="string">"我们在B站学习自然语言处理"</span>,
    <span class="string">"小明硕士毕业于南京大学"</span>,
    <span class="string">"蔚来ES8是一款新能源SUV"</span>,
    <span class="string">"确诊甲状腺功能亢进症"</span>
]

<span class="comment"># jieba分词（基于前缀词典+HMM）</span>
print(<span class="string">"=== jieba分词 ==="</span>)
<span class="keyword">for</span> text <span class="keyword">in</span> test_cases:
    result = jieba.lcut(text)
    print(<span class="string">f"{text} → {'/'.join(result)}"</span>)

<span class="comment"># 添加自定义词典</span>
jieba.add_word(<span class="string">'蔚来ES8'</span>, freq=<span class="number">10000</span>)
jieba.add_word(<span class="string">'甲状腺功能亢进症'</span>, freq=<span class="number">10000</span>)

print(<span class="string">"\n=== jieba分词（添加词典后）==="</span>)
<span class="keyword">for</span> text <span class="keyword">in</span> test_cases:
    result = jieba.lcut(text)
    print(<span class="string">f"{text} → {'/'.join(result)}"</span>)

<span class="comment"># pkuseg（北大，基于CRF）</span>
print(<span class="string">"\n=== pkuseg分词 ==="</span>)
seg = pkuseg.pkuseg()
<span class="keyword">for</span> text <span class="keyword">in</span> test_cases:
    result = seg.cut(text)
    print(<span class="string">f"{text} → {'/'.join(result)}"</span>)

<span class="comment"># 使用领域模型</span>
print(<span class="string">"\n=== pkuseg医学领域分词 ==="</span>)
seg_med = pkuseg.pkuseg(model_name=<span class="string">'medicine'</span>)
result = seg_med.cut(<span class="string">"确诊甲状腺功能亢进症"</span>)
print(<span class="string">f"确诊甲状腺功能亢进症 → {'/'.join(result)}"</span>)

<span class="comment">"""
输出对比：
=== jieba分词 ===
南京市长江大桥 → 南京市/长江大桥
我们在B站学习自然语言处理 → 我们/在/B/站/学习/自然语言/处理
小明硕士毕业于南京大学 → 小明/硕士/毕业/于/南京大学
蔚来ES8是一款新能源SUV → 蔚/来/ES8/是/一款/新能源/SUV
确诊甲状腺功能亢进症 → 确诊/甲状腺/功能/亢进/症

=== jieba分词（添加词典后）===
蔚来ES8是一款新能源SUV → 蔚来ES8/是/一款/新能源/SUV
确诊甲状腺功能亢进症 → 确诊/甲状腺功能亢进症
"""</span></pre>
                </div>
            </div>

            <div class="tip info mt-4">
                <span class="tip-icon">🚀</span>
                <strong>分词技术的演进</strong>
                <div class="flow-container mt-3" style="justify-content: space-between;">
                    <div class="flow-step" style="flex: 1;">
                        <span class="flow-step-icon">📏</span>
                        <h5 style="color: var(--info);">第一代：规则匹配</h5>
                        <ul style="font-size: 0.875rem; text-align: left;">
                            <li>最大匹配法</li>
                            <li>词典+规则</li>
                            <li>速度快但准确率低</li>
                        </ul>
                    </div>
                    <div class="flow-arrow">→</div>
                    <div class="flow-step" style="flex: 1;">
                        <span class="flow-step-icon">📊</span>
                        <h5 style="color: var(--primary);">第二代：统计模型</h5>
                        <ul style="font-size: 0.875rem; text-align: left;">
                            <li>HMM、CRF</li>
                            <li>概率建模</li>
                            <li>准确率提升明显</li>
                        </ul>
                    </div>
                    <div class="flow-arrow">→</div>
                    <div class="flow-step" style="flex: 1;">
                        <span class="flow-step-icon">🧠</span>
                        <h5 style="color: var(--success);">第三代：深度学习</h5>
                        <ul style="font-size: 0.875rem; text-align: left;">
                            <li>BERT、RoBERTa</li>
                            <li>端到端学习</li>
                            <li>接近人类水平</li>
                        </ul>
                    </div>
                </div>
            </div>
        </section>

        <!-- 词性标注 -->
        <section id="pos-tagging" class="section-card">
            <h2>🏷️ 词性标注：理解词的角色</h2>

            <div class="story-card">
                <span class="story-icon">🎭</span>
                <p><strong>莎士比亚的困惑</strong></p>
                <p class="mt-2">
                    如果莎士比亚活在今天，他可能会对中文感到困惑：
                </p>
                <div class="card-grid mt-3">
                    <div class="demo-container">
                        <p style="font-weight: bold;">句子1：</p>
                        <p style="font-size: 1.1rem;">"研究表明这个方法有效"</p>
                        <p style="color: var(--warning); margin-top: 0.5rem;">研究 = 名词（主语）</p>
                    </div>
                    <div class="demo-container">
                        <p style="font-weight: bold;">句子2：</p>
                        <p style="font-size: 1.1rem;">"我们研究这个问题"</p>
                        <p style="color: var(--success); margin-top: 0.5rem;">研究 = 动词（谓语）</p>
                    </div>
                </div>
                <p class="mt-3 text-center">
                    同一个词，不同的角色——这就是词性标注要解决的问题！
                </p>
            </div>

            <div class="demo-container">
                <h3 class="text-center mb-3" style="color: var(--primary-light);">词性标注示例</h3>

                <div class="text-center" style="font-size: 1.3rem; line-height: 3;">
                    <span class="token token-pos">
                        <span class="pos-label" style="background: var(--info);">代词</span>
                        我们
                    </span>
                    <span class="token token-pos">
                        <span class="pos-label" style="background: var(--danger);">动词</span>
                        使用
                    </span>
                    <span class="token token-pos">
                        <span class="pos-label" style="background: var(--warning);">名词</span>
                        深度学习
                    </span>
                    <span class="token token-pos">
                        <span class="pos-label" style="background: var(--danger);">动词</span>
                        解决
                    </span>
                    <span class="token token-pos">
                        <span class="pos-label" style="background: var(--success);">形容词</span>
                        复杂的
                    </span>
                    <span class="token token-pos">
                        <span class="pos-label" style="background: var(--warning);">名词</span>
                        问题
                    </span>
                </div>

                <p class="mt-4 text-center" style="color: var(--primary-light);">
                    词性标注让机器理解句子的语法结构，这是深层理解的基础！
                </p>
            </div>

            <div class="math-display">
                <h3 class="mb-3" style="color: var(--primary-light);">🧮 词性标注的数学模型：隐马尔可夫模型（HMM）</h3>

                <p>词性标注可以看作一个序列标注问题：</p>

                <div class="mt-3 mb-3">
                    <p class="math-formula">给定词序列 W = w₁, w₂, ..., wₙ</p>
                    <p class="math-formula">找到词性序列 T = t₁, t₂, ..., tₙ</p>
                    <p class="math-formula" style="font-size: 1.5rem; color: var(--warning);">
                        T* = argmax<sub>T</sub> P(T|W)
                    </p>
                </div>

                <div class="card-grid mt-4">
                    <div class="info-card">
                        <span class="card-icon">🔄</span>
                        <h4 style="color: var(--success);">转移概率</h4>
                        <p class="math-formula">P(t<sub>i</sub>|t<sub>i-1</sub>)</p>
                        <p class="mt-2">某个词性后面跟另一个词性的概率</p>
                        <div class="demo-container mt-3" style="padding: 1rem;">
                            <p style="font-size: 0.875rem;">
                                P(动词|名词) = 0.4<br>
                                P(名词|形容词) = 0.7<br>
                                P(动词|动词) = 0.1
                            </p>
                        </div>
                    </div>

                    <div class="info-card">
                        <span class="card-icon">📡</span>
                        <h4 style="color: var(--secondary);">发射概率</h4>
                        <p class="math-formula">P(w<sub>i</sub>|t<sub>i</sub>)</p>
                        <p class="mt-2">某个词性产生某个词的概率</p>
                        <div class="demo-container mt-3" style="padding: 1rem;">
                            <p style="font-size: 0.875rem;">
                                P("研究"|动词) = 0.01<br>
                                P("研究"|名词) = 0.005<br>
                                P("的"|助词) = 0.9
                            </p>
                        </div>
                    </div>
                </div>
            </div>

            <div class="code-block mt-4">
                <div class="code-header">
                    <span class="code-lang">Python - 词性标注实战</span>
                    <div class="code-actions">
                        <button class="code-btn" onclick="toggleCode(this)">展开</button>
                        <button class="code-btn" onclick="copyCode(this)">复制</button>
                    </div>
                </div>
                <div class="code-content collapsed">
                    <pre><span class="comment"># 词性标注实战</span>
<span class="keyword">import</span> jieba.posseg <span class="keyword">as</span> pseg

<span class="comment"># 测试句子</span>
sentences = [
    <span class="string">"研究表明这个方法有效"</span>,
    <span class="string">"我们研究这个问题"</span>,
    <span class="string">"这是一个有趣的研究"</span>,
    <span class="string">"苹果公司发布了新产品"</span>,
    <span class="string">"我喜欢吃苹果"</span>
]

print(<span class="string">"=== 词性标注结果 ==="</span>)
<span class="keyword">for</span> sent <span class="keyword">in</span> sentences:
    words_pos = pseg.cut(sent)
    result = []
    <span class="keyword">for</span> word, pos <span class="keyword">in</span> words_pos:
        result.append(<span class="string">f"{word}/{pos}"</span>)
        <span class="comment"># 特别标注同形异义词</span>
        <span class="keyword">if</span> word == <span class="string">"研究"</span>:
            print(<span class="string">f"  '{word}' → {pos} ({'名词' if pos.startswith('n') else '动词'})"</span>)
        <span class="keyword">elif</span> word == <span class="string">"苹果"</span>:
            print(<span class="string">f"  '{word}' → {pos} ({'公司' if '公司' in sent else '水果'})"</span>)
    print(<span class="string">f"{sent}"</span>)
    print(<span class="string">f"→ {' '.join(result)}"</span>)
    print()

<span class="comment"># 词性标注在下游任务中的应用</span>
<span class="keyword">def</span> <span class="function">extract_verb_noun_pairs</span>(sentence):
    <span class="string">"""提取动宾结构"""</span>
    words_pos = list(pseg.cut(sentence))
    pairs = []

    <span class="keyword">for</span> i <span class="keyword">in</span> range(len(words_pos) - <span class="number">1</span>):
        word1, pos1 = words_pos[i]
        word2, pos2 = words_pos[i + <span class="number">1</span>]

        <span class="comment"># 动词 + 名词 = 动宾结构</span>
        <span class="keyword">if</span> pos1.startswith(<span class="string">'v'</span>) <span class="keyword">and</span> pos2.startswith(<span class="string">'n'</span>):
            pairs.append((word1, word2))

    <span class="keyword">return</span> pairs

<span class="comment"># 测试动宾提取</span>
test_sents = [
    <span class="string">"我们分析数据发现问题"</span>,
    <span class="string">"研究人员开发算法解决难题"</span>,
    <span class="string">"用户使用软件处理文档"</span>
]

print(<span class="string">"\n=== 动宾结构提取 ==="</span>)
<span class="keyword">for</span> sent <span class="keyword">in</span> test_sents:
    pairs = extract_verb_noun_pairs(sent)
    print(<span class="string">f"{sent}"</span>)
    print(<span class="string">f"动宾结构：{pairs}"</span>)
    print()</pre>
                </div>
            </div>
        </section>

        <!-- 命名实体识别 -->
        <section id="ner" class="section-card">
            <h2>🎯 命名实体识别（NER）：找到文本中的主角</h2>

            <div class="story-card">
                <span class="story-icon">🕵️</span>
                <p><strong>情报分析员的日常</strong></p>
                <p class="mt-2">
                    想象你是一名情报分析员，每天要处理成千上万份报告。你的任务是快速找出：
                </p>
                <ul class="mt-2">
                    <li>🧑 谁（人物）参与了事件？</li>
                    <li>🏢 哪些组织（机构）相关？</li>
                    <li>📍 事件发生在哪里（地点）？</li>
                    <li>📅 什么时间（时间）发生？</li>
                </ul>
                <p class="mt-3">
                    这正是NER要做的事——从海量文本中自动提取关键实体信息！
                </p>
            </div>

            <div class="demo-container">
                <h3 class="mb-3" style="color: var(--primary-light);">🔍 NER实战演示</h3>

                <p class="mb-3"><strong>新闻原文：</strong></p>
                <p style="font-size: 1.2rem; line-height: 2.5;">
                    2024年1月，<span class="token token-entity" style="background: linear-gradient(135deg, rgba(236, 72, 153, 0.2), rgba(244, 114, 182, 0.2)); border-color: var(--secondary); color: var(--secondary);">马斯克</span>在
                    <span class="token token-entity">上海</span>宣布
                    <span class="token token-entity" style="background: linear-gradient(135deg, rgba(59, 130, 246, 0.2), rgba(99, 102, 241, 0.2)); border-color: var(--info); color: var(--info);">特斯拉</span>将在
                    <span class="token token-entity">中国</span>建设第二座超级工厂。
                    <span class="token token-entity" style="background: linear-gradient(135deg, rgba(236, 72, 153, 0.2), rgba(244, 114, 182, 0.2)); border-color: var(--secondary); color: var(--secondary);">李斌</span>表示
                    <span class="token token-entity" style="background: linear-gradient(135deg, rgba(59, 130, 246, 0.2), rgba(99, 102, 241, 0.2)); border-color: var(--info); color: var(--info);">蔚来汽车</span>将加快在
                    <span class="token token-entity">欧洲</span>的扩张步伐。
                </p>

                <div class="card-grid mt-4">
                    <div class="text-center">
                        <div style="font-size: 3rem;">👤</div>
                        <h4 style="color: var(--secondary);">人名（PER）</h4>
                        <p>马斯克、李斌</p>
                    </div>
                    <div class="text-center">
                        <div style="font-size: 3rem;">📍</div>
                        <h4 style="color: var(--success);">地名（LOC）</h4>
                        <p>上海、中国、欧洲</p>
                    </div>
                    <div class="text-center">
                        <div style="font-size: 3rem;">🏢</div>
                        <h4 style="color: var(--info);">机构（ORG）</h4>
                        <p>特斯拉、蔚来汽车</p>
                    </div>
                </div>
            </div>

            <div class="tip warning mt-4">
                <span class="tip-icon">🤔</span>
                <strong>NER的核心挑战</strong>
                <div class="card-grid mt-3">
                    <div class="demo-container" style="padding: 1.5rem;">
                        <h5 style="color: var(--info);">边界识别</h5>
                        <p style="font-size: 0.9rem;">
                            "南京市长" vs "南京市/长"<br>
                            "中国银行" vs "中国/银行"<br>
                            实体的边界在哪里？
                        </p>
                    </div>

                    <div class="demo-container" style="padding: 1.5rem;">
                        <h5 style="color: var(--primary);">类型歧义</h5>
                        <p style="font-size: 0.9rem;">
                            "苹果"→ 公司还是水果？<br>
                            "长江"→ 地名还是其他？<br>
                            需要结合上下文判断
                        </p>
                    </div>

                    <div class="demo-container" style="padding: 1.5rem;">
                        <h5 style="color: var(--secondary);">嵌套实体</h5>
                        <p style="font-size: 0.9rem;">
                            "北京大学"：<br>
                            - 地名：北京<br>
                            - 机构：北京大学
                        </p>
                    </div>

                    <div class="demo-container" style="padding: 1.5rem;">
                        <h5 style="color: var(--warning);">新实体涌现</h5>
                        <p style="font-size: 0.9rem;">
                            新公司：字节跳动、拼多多<br>
                            新人名：网红、明星<br>
                            如何识别词典中没有的实体？
                        </p>
                    </div>
                </div>
            </div>

            <div class="algorithm-steps">
                <h4 class="mb-4" style="color: var(--primary-light);">🏗️ 基于条件随机场(CRF)的NER</h4>

                <div class="step-item">
                    <div class="step-number">1</div>
                    <div class="step-content">
                        <h5>BIO标注体系</h5>
                        <p>将NER转化为序列标注问题</p>
                        <div class="code-block mt-3">
                            <div class="code-header">
                                <span class="code-lang">BIO标注示例</span>
                            </div>
                            <div class="code-content">
                                <pre>马   斯   克   在   上   海   工   作
B-PER I-PER I-PER O  B-LOC I-LOC O   O

• B-PER：人名开始
• I-PER：人名内部
• B-LOC：地名开始
• O：非实体</pre>
                            </div>
                        </div>
                    </div>
                </div>

                <div class="step-item">
                    <div class="step-number">2</div>
                    <div class="step-content">
                        <h5>特征工程</h5>
                        <p>提取有助于识别实体的特征</p>
                        <div class="card-grid mt-3">
                            <div class="demo-container" style="padding: 1rem;">
                                <strong>词汇特征</strong>
                                <ul style="font-size: 0.875rem;">
                                    <li>当前词</li>
                                    <li>前后词</li>
                                    <li>词性标注</li>
                                </ul>
                            </div>
                            <div class="demo-container" style="padding: 1rem;">
                                <strong>字符特征</strong>
                                <ul style="font-size: 0.875rem;">
                                    <li>是否大写</li>
                                    <li>是否包含数字</li>
                                    <li>词缀（公司、集团）</li>
                                </ul>
                            </div>
                        </div>
                    </div>
                </div>

                <div class="step-item">
                    <div class="step-number">3</div>
                    <div class="step-content">
                        <h5>CRF建模</h5>
                        <p>学习标签之间的转移规律</p>
                        <div class="demo-container mt-3">
                            <p><strong>合理的标签序列：</strong></p>
                            <p style="color: var(--success);">✓ B-PER → I-PER → O</p>
                            <p><strong>不合理的标签序列：</strong></p>
                            <p style="color: var(--danger);">✗ I-PER → B-PER（实体内部不能接开始）</p>
                            <p style="color: var(--danger);">✗ B-PER → I-LOC（人名不能接地名内部）</p>
                        </div>
                    </div>
                </div>
            </div>

            <div class="code-block mt-4">
                <div class="code-header">
                    <span class="code-lang">Python - NER实战代码</span>
                    <div class="code-actions">
                        <button class="code-btn" onclick="toggleCode(this)">展开</button>
                        <button class="code-btn" onclick="copyCode(this)">复制</button>
                    </div>
                </div>
                <div class="code-content collapsed">
                    <pre><span class="comment"># NER实战代码</span>
<span class="keyword">import</span> re
<span class="keyword">from</span> collections <span class="keyword">import</span> defaultdict

<span class="keyword">class</span> <span class="function">SimpleNER</span>:
    <span class="string">"""简单的规则+词典NER系统"""</span>

    <span class="keyword">def</span> <span class="function">__init__</span>(self):
        <span class="comment"># 实体词典</span>
        self.person_dict = {<span class="string">'马云'</span>, <span class="string">'马化腾'</span>, <span class="string">'李彦宏'</span>, <span class="string">'雷军'</span>, <span class="string">'马斯克'</span>, <span class="string">'李斌'</span>}
        self.org_dict = {<span class="string">'阿里巴巴'</span>, <span class="string">'腾讯'</span>, <span class="string">'百度'</span>, <span class="string">'小米'</span>, <span class="string">'特斯拉'</span>, <span class="string">'蔚来'</span>,
                         <span class="string">'字节跳动'</span>, <span class="string">'美团'</span>, <span class="string">'京东'</span>, <span class="string">'拼多多'</span>}
        self.loc_dict = {<span class="string">'北京'</span>, <span class="string">'上海'</span>, <span class="string">'深圳'</span>, <span class="string">'杭州'</span>, <span class="string">'广州'</span>, <span class="string">'中国'</span>,
                         <span class="string">'美国'</span>, <span class="string">'欧洲'</span>, <span class="string">'亚洲'</span>}

        <span class="comment"># 实体后缀模式</span>
        self.org_suffix = [<span class="string">'公司'</span>, <span class="string">'集团'</span>, <span class="string">'银行'</span>, <span class="string">'大学'</span>, <span class="string">'学院'</span>, <span class="string">'医院'</span>,
                           <span class="string">'研究院'</span>, <span class="string">'实验室'</span>, <span class="string">'工作室'</span>]
        self.person_prefix = [<span class="string">'董事长'</span>, <span class="string">'总经理'</span>, <span class="string">'CEO'</span>, <span class="string">'创始人'</span>, <span class="string">'教授'</span>,
                             <span class="string">'博士'</span>, <span class="string">'院士'</span>]

    <span class="keyword">def</span> <span class="function">recognize</span>(self, text):
        <span class="string">"""识别文本中的命名实体"""</span>
        entities = {
            <span class="string">'PER'</span>: [],  <span class="comment"># 人名</span>
            <span class="string">'ORG'</span>: [],  <span class="comment"># 机构</span>
            <span class="string">'LOC'</span>: []   <span class="comment"># 地名</span>
        }

        <span class="comment"># 1. 基于词典的精确匹配</span>
        <span class="keyword">for</span> person <span class="keyword">in</span> self.person_dict:
            <span class="keyword">if</span> person <span class="keyword">in</span> text:
                entities[<span class="string">'PER'</span>].append(person)

        <span class="keyword">for</span> org <span class="keyword">in</span> self.org_dict:
            <span class="keyword">if</span> org <span class="keyword">in</span> text:
                entities[<span class="string">'ORG'</span>].append(org)

        <span class="keyword">for</span> loc <span class="keyword">in</span> self.loc_dict:
            <span class="keyword">if</span> loc <span class="keyword">in</span> text:
                entities[<span class="string">'LOC'</span>].append(loc)

        <span class="comment"># 2. 基于模式的识别</span>
        <span class="comment"># 识别"XX公司"格式的机构名</span>
        <span class="keyword">for</span> suffix <span class="keyword">in</span> self.org_suffix:
            pattern = <span class="string">f'[\u4e00-\u9fa5]+{suffix}'</span>
            matches = re.findall(pattern, text)
            entities[<span class="string">'ORG'</span>].extend(matches)

        <span class="comment"># 识别"董事长XX"格式的人名</span>
        <span class="keyword">for</span> prefix <span class="keyword">in</span> self.person_prefix:
            pattern = <span class="string">f'{prefix}[\u4e00-\u9fa5]{{2,4}}'</span>
            matches = re.findall(pattern, text)
            <span class="comment"># 提取人名部分</span>
            <span class="keyword">for</span> match <span class="keyword">in</span> matches:
                name = match.replace(prefix, <span class="string">''</span>)
                <span class="keyword">if</span> len(name) >= <span class="number">2</span>:
                    entities[<span class="string">'PER'</span>].append(name)

        <span class="comment"># 3. 去重</span>
        <span class="keyword">for</span> key <span class="keyword">in</span> entities:
            entities[key] = list(set(entities[key]))

        <span class="keyword">return</span> entities

    <span class="keyword">def</span> <span class="function">visualize</span>(self, text, entities):
        <span class="string">"""可视化NER结果"""</span>
        <span class="comment"># 为不同类型的实体添加标记</span>
        result = text

        <span class="comment"># 按长度排序，先替换长的，避免重叠</span>
        all_entities = []
        <span class="keyword">for</span> ent_type, ent_list <span class="keyword">in</span> entities.items():
            <span class="keyword">for</span> ent <span class="keyword">in</span> ent_list:
                all_entities.append((ent, ent_type))

        all_entities.sort(key=<span class="keyword">lambda</span> x: len(x[<span class="number">0</span>]), reverse=<span class="keyword">True</span>)

        <span class="comment"># 替换实体</span>
        <span class="keyword">for</span> ent, ent_type <span class="keyword">in</span> all_entities:
            <span class="keyword">if</span> ent_type == <span class="string">'PER'</span>:
                result = result.replace(ent, <span class="string">f'[人名：{ent}]'</span>)
            <span class="keyword">elif</span> ent_type == <span class="string">'ORG'</span>:
                result = result.replace(ent, <span class="string">f'[机构：{ent}]'</span>)
            <span class="keyword">elif</span> ent_type == <span class="string">'LOC'</span>:
                result = result.replace(ent, <span class="string">f'[地点：{ent}]'</span>)

        <span class="keyword">return</span> result

<span class="comment"># 测试NER系统</span>
ner = SimpleNER()

test_texts = [
    <span class="string">"马云创办的阿里巴巴总部位于杭州，马化腾的腾讯总部在深圳。"</span>,
    <span class="string">"特斯拉CEO马斯克宣布将在上海建设新工厂。"</span>,
    <span class="string">"北京大学教授李明在自然语言处理实验室工作。"</span>,
    <span class="string">"字节跳动创始人张一鸣毕业于南开大学软件学院。"</span>
]

print(<span class="string">"=== NER识别结果 ===\n"</span>)
<span class="keyword">for</span> text <span class="keyword">in</span> test_texts:
    print(<span class="string">f"原文：{text}"</span>)
    entities = ner.recognize(text)
    print(<span class="string">f"识别的实体：{entities}"</span>)
    result = ner.visualize(text, entities)
    print(<span class="string">f"标注结果：{result}"</span>)
    print(<span class="string">"-"</span> * <span class="number">50</span>)</pre>
                </div>
            </div>
        </section>

        <!-- 文本清洗 -->
        <section id="text-cleaning" class="section-card">
            <h2>🧹 文本清洗：垃圾进，垃圾出</h2>

            <div class="story-card">
                <span class="story-icon">🗑️</span>
                <p><strong>数据科学家的噩梦</strong></p>
                <p class="mt-2">
                    小王接手了一个情感分析项目，信心满满地开始训练模型。一周后，模型准确率只有60%。
                </p>
                <p class="mt-2">他检查了预测错误的样本，发现了问题：</p>
                <div class="code-block mt-3">
                    <div class="code-header">
                        <span class="code-lang">脏数据示例</span>
                    </div>
                    <div class="code-content">
                        <pre>原始评论：&lt;p&gt;这个产品真的很好好好好好！！！！！&lt;/p&gt;😍😍😍
模型看到的：整个HTML和一堆符号
模型预测：负面（因为训练数据中HTML标签常出现在垃圾评论中）</pre></div>
                </div>
                <p class="mt-3 text-center" style="color: var(--danger); font-size: 1.1rem;">
                    💡 垃圾进，垃圾出（Garbage In, Garbage Out）——数据质量决定模型上限！
                </p>
            </div>

            <div class="tip danger">
                <span class="tip-icon">🚨</span>
                <strong>真实世界的文本有多脏？</strong>
                <div class="card-grid mt-3">
                    <div class="demo-container" style="padding: 1rem;">
                        <h5 style="color: var(--danger);">社交媒体</h5>
                        <code style="font-size: 0.8rem;">
                            转发这条锦鲤🐟🐟🐟<br>
                            ！！！暴富！！！<br>
                            @小明 @小红 @小李<br>
                            #转发抽奖# #锦鲤#
                        </code>
                    </div>
                    <div class="demo-container" style="padding: 1rem;">
                        <h5 style="color: var(--warning);">电商评论</h5>
                        <code style="font-size: 0.8rem;">
                            宝贝很好好好好好！！！<br>
                            卖家人nice~~~么么哒😘<br>
                            物流快快快快快！5星⭐⭐⭐⭐⭐
                        </code>
                    </div>
                    <div class="demo-container" style="padding: 1rem;">
                        <h5 style="color: var(--info);">网页爬取</h5>
                        <code style="font-size: 0.8rem;">
                            &lt;div&gt;价格：&lt;span&gt;￥99&lt;/span&gt;&lt;/div&gt;<br>
                            &amp;nbsp;&amp;nbsp;立即购买<br>
                            Copyright©2024
                        </code>
                    </div>
                </div>
            </div>

            <h3 class="mt-4">文本清洗的层次</h3>

            <div class="algorithm-steps">
                <div class="step-item">
                    <div class="step-number">1</div>
                    <div class="step-content">
                        <h5>基础清洗：去除明显噪声</h5>
                        <p>处理最基本的格式问题</p>
                        <div class="code-block mt-3">
                            <div class="code-header">
                                <span class="code-lang">Python - 基础清洗</span>
                            </div>
                            <div class="code-content">
                                <pre><span class="keyword">import</span> re
<span class="keyword">import</span> html

<span class="keyword">def</span> <span class="function">basic_clean</span>(text):
    <span class="comment"># 1. 去除HTML标签</span>
    text = re.sub(<span class="string">r'<[^>]+>'</span>, <span class="string">''</span>, text)

    <span class="comment"># 2. 处理HTML实体</span>
    text = html.unescape(text)  <span class="comment"># &amp;nbsp; → 空格</span>

    <span class="comment"># 3. 统一空白字符</span>
    text = re.sub(<span class="string">r'\s+'</span>, <span class="string">' '</span>, text)

    <span class="comment"># 4. 去除首尾空白</span>
    text = text.strip()

    <span class="keyword">return</span> text

<span class="comment"># 示例</span>
dirty = <span class="string">"&lt;p&gt;这是一段&amp;nbsp;&amp;nbsp;&amp;nbsp;文本&lt;/p&gt;"</span>
clean = basic_clean(dirty)
print(clean)  <span class="comment"># "这是一段 文本"</span></pre>
                            </div>
                        </div>
                    </div>
                </div>

                <div class="step-item">
                    <div class="step-number">2</div>
                    <div class="step-content">
                        <h5>规范化：统一表达形式</h5>
                        <p>让相同含义的文本有相同的形式</p>
                        <div class="code-block mt-3">
                            <div class="code-header">
                                <span class="code-lang">Python - 文本规范化</span>
                            </div>
                            <div class="code-content">
                                <pre><span class="keyword">def</span> <span class="function">normalize_text</span>(text):
    <span class="comment"># 1. 繁简转换</span>
    <span class="keyword">from</span> opencc <span class="keyword">import</span> OpenCC
    cc = OpenCC(<span class="string">'t2s'</span>)  <span class="comment"># 繁体转简体</span>
    text = cc.convert(text)

    <span class="comment"># 2. 全角转半角</span>
    <span class="keyword">def</span> <span class="function">full2half</span>(s):
        n = []
        <span class="keyword">for</span> char <span class="keyword">in</span> s:
            num = ord(char)
            <span class="keyword">if</span> num == <span class="number">0x3000</span>:  <span class="comment"># 全角空格</span>
                n.append(<span class="string">' '</span>)
            <span class="keyword">elif</span> <span class="number">0xFF01</span> <= num <= <span class="number">0xFF5E</span>:
                n.append(chr(num - <span class="number">0xFEE0</span>))
            <span class="keyword">else</span>:
                n.append(char)
        <span class="keyword">return</span> <span class="string">''</span>.join(n)

    text = full2half(text)

    <span class="comment"># 3. 大小写统一（英文）</span>
    text = text.lower()

    <span class="comment"># 4. 数字规范化</span>
    text = re.sub(<span class="string">r'[０-９]'</span>, <span class="keyword">lambda</span> x: str(ord(x.group()) - ord(<span class="string">'０'</span>)), text)

    <span class="keyword">return</span> text

<span class="comment"># 示例</span>
print(normalize_text(<span class="string">"這是繁體字，ＡＢＣ１２３"</span>))
<span class="comment"># 输出：这是繁体字，abc123</span></pre>
                            </div>
                        </div>
                    </div>
                </div>

                <div class="step-item">
                    <div class="step-number">3</div>
                    <div class="step-content">
                        <h5>噪声过滤：去除无意义内容</h5>
                        <p>识别并去除对任务无用的内容</p>
                        <div class="card-grid mt-3">
                            <div class="demo-container" style="padding: 1.5rem;">
                                <h6 style="color: var(--primary-light);">重复字符</h6>
                                <p style="font-size: 0.9rem;">
                                    "好好好好好" → "好"<br>
                                    "哈哈哈哈哈" → "哈哈"<br>
                                    "！！！！！" → "！"
                                </p>
                            </div>
                            <div class="demo-container" style="padding: 1.5rem;">
                                <h6 style="color: var(--secondary);">表情符号</h6>
                                <p style="font-size: 0.9rem;">
                                    根据任务决定：<br>
                                    • 情感分析：保留😊<br>
                                    • 主题分类：去除👍
                                </p>
                            </div>
                            <div class="demo-container" style="padding: 1.5rem;">
                                <h6 style="color: var(--warning);">特殊符号</h6>
                                <p style="font-size: 0.9rem;">
                                    @用户名、#话题#<br>
                                    URL链接<br>
                                    特殊标记
                                </p>
                            </div>
                        </div>
                    </div>
                </div>

                <div class="step-item">
                    <div class="step-number">4</div>
                    <div class="step-content">
                        <h5>智能清洗：基于任务的优化</h5>
                        <p>根据具体任务定制清洗策略</p>
                        <div class="demo-container">
                            <p><strong>示例：不同任务的清洗策略</strong></p>
                            <div class="comparison-table mt-3">
                                <table>
                                    <thead>
                                    <tr>
                                        <th>任务类型</th>
                                        <th>保留内容</th>
                                        <th>去除内容</th>
                                        <th>特殊处理</th>
                                    </tr>
                                    </thead>
                                    <tbody>
                                    <tr>
                                        <td>情感分析</td>
                                        <td>表情、感叹号、程度副词</td>
                                        <td>URL、@提及</td>
                                        <td>重复字符限制为2个</td>
                                    </tr>
                                    <tr>
                                        <td>主题分类</td>
                                        <td>名词、实体词</td>
                                        <td>表情、标点、语气词</td>
                                        <td>停用词过滤</td>
                                    </tr>
                                    <tr>
                                        <td>机器翻译</td>
                                        <td>所有标点、大小写</td>
                                        <td>仅去除控制字符</td>
                                        <td>保持原始格式</td>
                                    </tr>
                                    <tr>
                                        <td>问答系统</td>
                                        <td>问号、实体、数字</td>
                                        <td>表情、装饰符号</td>
                                        <td>问句规范化</td>
                                    </tr>
                                    </tbody>
                                </table>
                            </div>
                        </div>
                    </div>
                </div>
            </div>

            <div class="code-block mt-4">
                <div class="code-header">
                    <span class="code-lang">Python - 完整的文本清洗管道</span>
                    <div class="code-actions">
                        <button class="code-btn" onclick="toggleCode(this)">展开</button>
                        <button class="code-btn" onclick="copyCode(this)">复制</button>
                    </div>
                </div>
                <div class="code-content collapsed">
                    <pre><span class="keyword">import</span> re
<span class="keyword">import</span> string
<span class="keyword">import</span> emoji
<span class="keyword">from</span> typing <span class="keyword">import</span> List, Set

<span class="keyword">class</span> <span class="function">TextCleaner</span>:
    <span class="string">"""可配置的文本清洗器"""</span>

    <span class="keyword">def</span> <span class="function">__init__</span>(self, config=None):
        self.config = config <span class="keyword">or</span> {}

        <span class="comment"># 默认停用词</span>
        self.stopwords = {
            <span class="string">'的'</span>, <span class="string">'了'</span>, <span class="string">'和'</span>, <span class="string">'是'</span>, <span class="string">'在'</span>, <span class="string">'我'</span>, <span class="string">'有'</span>,
            <span class="string">'就'</span>, <span class="string">'不'</span>, <span class="string">'也'</span>, <span class="string">'这'</span>, <span class="string">'那'</span>, <span class="string">'但'</span>, <span class="string">'你'</span>
        }

    <span class="keyword">def</span> <span class="function">remove_html</span>(self, text: str) -> str:
        <span class="string">"""去除HTML标签和实体"""</span>
        <span class="comment"># 去除script和style内容</span>
        text = re.sub(<span class="string">r'<script.*?</script>'</span>, <span class="string">''</span>, text, flags=re.DOTALL)
        text = re.sub(<span class="string">r'<style.*?</style>'</span>, <span class="string">''</span>, text, flags=re.DOTALL)
        <span class="comment"># 去除标签</span>
        text = re.sub(<span class="string">r'<[^>]+>'</span>, <span class="string">''</span>, text)
        <span class="comment"># 处理HTML实体</span>
        text = re.sub(<span class="string">r'&[a-zA-Z]+;'</span>, <span class="string">' '</span>, text)
        <span class="keyword">return</span> text

    <span class="keyword">def</span> <span class="function">remove_urls</span>(self, text: str) -> str:
        <span class="string">"""去除URL链接"""</span>
        <span class="comment"># HTTP(S)链接</span>
        text = re.sub(<span class="string">r'https?://[^\s]+'</span>, <span class="string">''</span>, text)
        <span class="comment"># www链接</span>
        text = re.sub(<span class="string">r'www\.[^\s]+'</span>, <span class="string">''</span>, text)
        <span class="keyword">return</span> text

    <span class="keyword">def</span> <span class="function">remove_emails</span>(self, text: str) -> str:
        <span class="string">"""去除邮箱地址"""</span>
        text = re.sub(<span class="string">r'[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}'</span>, <span class="string">''</span>, text)
        <span class="keyword">return</span> text

    <span class="keyword">def</span> <span class="function">handle_emojis</span>(self, text: str, mode=<span class="string">'remove'</span>) -> str:
        <span class="string">"""处理表情符号"""</span>
        <span class="keyword">if</span> mode == <span class="string">'remove'</span>:
            <span class="keyword">return</span> emoji.replace_emoji(text, <span class="string">''</span>)
        <span class="keyword">elif</span> mode == <span class="string">'replace'</span>:
            <span class="keyword">return</span> emoji.demojize(text)  <span class="comment"># 😊 → :smiling_face:</span>
        <span class="keyword">else</span>:
            <span class="keyword">return</span> text

    <span class="keyword">def</span> <span class="function">reduce_repetitions</span>(self, text: str, max_repeat=<span class="number">2</span>) -> str:
        <span class="string">"""减少重复字符"""</span>
        <span class="comment"># 处理中文重复</span>
        pattern = <span class="string">r'([\u4e00-\u9fa5])\1{' + str(max_repeat) + <span class="string">',}'</span>
        text = re.sub(pattern, <span class="string">r'\1' * max_repeat, text)

        <span class="comment"># 处理标点重复</span>
        text = re.sub(<span class="string">r'([!?。！？])\1+'</span>, <span class="string">r'\1'</span>, text)

        <span class="comment"># 处理英文重复</span>
        text = re.sub(<span class="string">r'([a-zA-Z])\1{2,}'</span>, <span class="string">r'\1\1'</span>, text)

        <span class="keyword">return</span> text

    <span class="keyword">def</span> <span class="function">normalize_whitespace</span>(self, text: str) -> str:
        <span class="string">"""规范化空白字符"""</span>
        <span class="comment"># 替换各种空白为标准空格</span>
        text = re.sub(<span class="string">r'[\xa0\u3000\t\r\n]+'</span>, <span class="string">' '</span>, text)
        <span class="comment"># 多个空格合并为一个</span>
        text = re.sub(<span class="string">r' +'</span>, <span class="string">' '</span>, text)
        <span class="keyword">return</span> text.strip()

    <span class="keyword">def</span> <span class="function">remove_special_chars</span>(self, text: str, keep_chars=<span class="string">''</span>) -> str:
        <span class="string">"""去除特殊字符"""</span>
        <span class="comment"># 保留中文、英文、数字和指定字符</span>
        pattern = <span class="string">f'[^\\u4e00-\\u9fa5a-zA-Z0-9{re.escape(keep_chars)}]+'</span>
        text = re.sub(pattern, <span class="string">' '</span>, text)
        <span class="keyword">return</span> text

    <span class="keyword">def</span> <span class="function">remove_stopwords</span>(self, text: str, custom_stopwords: Set[str] = None) -> str:
        <span class="string">"""去除停用词"""</span>
        stopwords = self.stopwords
        <span class="keyword">if</span> custom_stopwords:
            stopwords = stopwords.union(custom_stopwords)

        words = text.split()
        words = [w <span class="keyword">for</span> w <span class="keyword">in</span> words <span class="keyword">if</span> w <span class="keyword">not in</span> stopwords]
        <span class="keyword">return</span> <span class="string">' '</span>.join(words)

    <span class="keyword">def</span> <span class="function">clean</span>(self, text: str, pipeline: List[str] = None) -> str:
        <span class="string">"""执行清洗管道"""</span>
        <span class="keyword">if</span> pipeline <span class="keyword">is</span> None:
            pipeline = [
                <span class="string">'html'</span>, <span class="string">'urls'</span>, <span class="string">'emails'</span>, <span class="string">'whitespace'</span>,
                <span class="string">'repetitions'</span>, <span class="string">'emojis'</span>
            ]

        <span class="keyword">for</span> step <span class="keyword">in</span> pipeline:
            <span class="keyword">if</span> step == <span class="string">'html'</span>:
                text = self.remove_html(text)
            <span class="keyword">elif</span> step == <span class="string">'urls'</span>:
                text = self.remove_urls(text)
            <span class="keyword">elif</span> step == <span class="string">'emails'</span>:
                text = self.remove_emails(text)
            <span class="keyword">elif</span> step == <span class="string">'whitespace'</span>:
                text = self.normalize_whitespace(text)
            <span class="keyword">elif</span> step == <span class="string">'repetitions'</span>:
                text = self.reduce_repetitions(text)
            <span class="keyword">elif</span> step == <span class="string">'emojis'</span>:
                text = self.handle_emojis(text, mode=<span class="string">'remove'</span>)
            <span class="keyword">elif</span> step == <span class="string">'special'</span>:
                text = self.remove_special_chars(text)
            <span class="keyword">elif</span> step == <span class="string">'stopwords'</span>:
                text = self.remove_stopwords(text)

        <span class="keyword">return</span> text

<span class="comment"># 使用示例</span>
cleaner = TextCleaner()

<span class="comment"># 针对不同任务的清洗配置</span>
<span class="comment"># 1. 情感分析</span>
sentiment_pipeline = [<span class="string">'html'</span>, <span class="string">'urls'</span>, <span class="string">'whitespace'</span>, <span class="string">'repetitions'</span>]
text = <span class="string">"这个产品真的很好好好好！！！😍😍 http://example.com"</span>
cleaned = cleaner.clean(text, sentiment_pipeline)
print(<span class="string">f"情感分析清洗：{cleaned}"</span>)  <span class="comment"># 保留了表情</span>

<span class="comment"># 2. 主题分类</span>
topic_pipeline = [<span class="string">'html'</span>, <span class="string">'urls'</span>, <span class="string">'emails'</span>, <span class="string">'emojis'</span>, <span class="string">'special'</span>, <span class="string">'stopwords'</span>]
text = <span class="string">"分享一个机器学习的教程 https://ml-tutorial.com 👍👍"</span>
cleaned = cleaner.clean(text, topic_pipeline)
print(<span class="string">f"主题分类清洗：{cleaned}"</span>)  <span class="comment"># 去除了URL和表情</span>

<span class="comment"># 3. 批量处理</span>
texts = [
    <span class="string">"&lt;p&gt;产品很棒！！！&lt;/p&gt;"</span>,
    <span class="string">"客服态度好好好好 😊😊😊"</span>,
    <span class="string">"物流速度快快快快快！"</span>
]

cleaned_texts = [cleaner.clean(t) <span class="keyword">for</span> t <span class="keyword">in</span> texts]
<span class="keyword">for</span> original, cleaned <span class="keyword">in</span> zip(texts, cleaned_texts):
    print(<span class="string">f"{original} → {cleaned}"</span>)</pre>
                </div>
            </div>

            <div class="tip success mt-4">
                <span class="tip-icon">✨</span>
                <strong>清洗的黄金法则</strong>
                <ul class="mt-2">
                    <li><strong>保守原则：</strong>宁可少清洗，不可过度清洗。丢失的信息无法恢复！</li>
                    <li><strong>任务导向：</strong>不同任务需要不同的清洗策略，没有一刀切的方案</li>
                    <li><strong>保留备份：</strong>永远保存原始数据，清洗后的数据另存</li>
                    <li><strong>迭代优化：</strong>先简单清洗，根据效果逐步调整策略</li>
                </ul>
            </div>
        </section>

        <!-- 工具对比 -->
        <section id="tools-comparison" class="section-card">
            <h2>🛠️ 工具对比：选择合适的武器</h2>

            <div class="story-card">
                <span class="story-icon">⚔️</span>
                <p><strong>工具选择困难症</strong></p>
                <p class="mt-2">
                    新手小张要做一个中文NLP项目，打开搜索引擎，发现有几十种分词工具：jieba、THULAC、pkuseg、HanLP、LAC...
                </p>
                <p class="mt-2">
                    "选哪个？"小张陷入了深深的纠结。
                </p>
                <p class="mt-3 text-center" style="color: var(--primary-light); font-size: 1.1rem;">
                    没有最好的工具，只有最合适的工具！
                </p>
            </div>

            <div class="comparison-table">
                <table>
                    <thead>
                    <tr>
                        <th>工具名称</th>
                        <th>核心算法</th>
                        <th>速度</th>
                        <th>准确率</th>
                        <th>特色功能</th>
                        <th>适用场景</th>
                    </tr>
                    </thead>
                    <tbody>
                    <tr>
                        <td><strong>jieba</strong></td>
                        <td>前缀词典+HMM</td>
                        <td>⚡⚡⚡⚡⚡<br><small>50MB/s</small></td>
                        <td>⭐⭐⭐⭐<br><small>~95%</small></td>
                        <td>• 支持自定义词典<br>• 三种分词模式<br>• 关键词提取</td>
                        <td>通用场景、快速原型</td>
                    </tr>
                    <tr>
                        <td><strong>THULAC</strong></td>
                        <td>结构化感知机</td>
                        <td>⚡⚡⚡<br><small>10MB/s</small></td>
                        <td>⭐⭐⭐⭐⭐<br><small>~97%</small></td>
                        <td>• 词性标注一体化<br>• 模型精度高<br>• 支持自定义</td>
                        <td>学术研究、高精度需求</td>
                    </tr>
                    <tr>
                        <td><strong>pkuseg</strong></td>
                        <td>CRF</td>
                        <td>⚡⚡<br><small>5MB/s</small></td>
                        <td>⭐⭐⭐⭐⭐<br><small>~96%</small></td>
                        <td>• 领域模型<br>• 细粒度分词<br>• 多线程</td>
                        <td>特定领域、精细分词</td>
                    </tr>
                    <tr>
                        <td><strong>HanLP</strong></td>
                        <td>深度学习</td>
                        <td>⚡⚡⚡⚡<br><small>20MB/s</small></td>
                        <td>⭐⭐⭐⭐⭐<br><small>~98%</small></td>
                        <td>• 全功能NLP<br>• 多语言<br>• 预训练模型</td>
                        <td>企业级应用、全栈NLP</td>
                    </tr>
                    <tr>
                        <td><strong>LAC</strong></td>
                        <td>Bi-LSTM+CRF</td>
                        <td>⚡⚡⚡<br><small>15MB/s</small></td>
                        <td>⭐⭐⭐⭐⭐<br><small>~97%</small></td>
                        <td>• 词性+NER一体<br>• 百度出品<br>• 工业级</td>
                        <td>工业应用、一体化处理</td>
                    </tr>
                    </tbody>
                </table>
            </div>

            <div class="flow-diagram mt-4">
                <h4 class="text-center mb-4" style="color: var(--primary-light);">🎯 工具选择决策树</h4>

                <div class="algorithm-steps">
                    <div class="step-item">
                        <div class="step-number">?</div>
                        <div class="step-content">
                            <h5>速度是首要考虑吗？</h5>
                            <div class="card-grid mt-3">
                                <div class="demo-container" style="padding: 1rem;">
                                    <p style="color: var(--success); font-weight: bold;">✓ 是</p>
                                    <p>→ 选择 <strong>jieba</strong></p>
                                    <p style="font-size: 0.875rem;">最快、易用、社区活跃</p>
                                </div>
                                <div class="demo-container" style="padding: 1rem;">
                                    <p style="color: var(--danger); font-weight: bold;">✗ 否</p>
                                    <p>→ 继续下一个问题</p>
                                </div>
                            </div>
                        </div>
                    </div>

                    <div class="step-item">
                        <div class="step-number">?</div>
                        <div class="step-content">
                            <h5>需要特定领域优化吗？</h5>
                            <div class="card-grid mt-3">
                                <div class="demo-container" style="padding: 1rem;">
                                    <p style="color: var(--success); font-weight: bold;">✓ 是</p>
                                    <p>→ 选择 <strong>pkuseg</strong></p>
                                    <p style="font-size: 0.875rem;">医疗、新闻等领域模型</p>
                                </div>
                                <div class="demo-container" style="padding: 1rem;">
                                    <p style="color: var(--danger); font-weight: bold;">✗ 否</p>
                                    <p>→ 继续下一个问题</p>
                                </div>
                            </div>
                        </div>
                    </div>

                    <div class="step-item">
                        <div class="step-number">?</div>
                        <div class="step-content">
                            <h5>需要完整的NLP功能吗？</h5>
                            <div class="card-grid mt-3">
                                <div class="demo-container" style="padding: 1rem;">
                                    <p style="color: var(--success); font-weight: bold;">✓ 是</p>
                                    <p>→ 选择 <strong>HanLP</strong></p>
                                    <p style="font-size: 0.875rem;">一站式解决方案</p>
                                </div>
                                <div class="demo-container" style="padding: 1rem;">
                                    <p style="color: var(--primary); font-weight: bold;">~ 只需要分词+词性+NER</p>
                                    <p>→ 选择 <strong>LAC</strong></p>
                                    <p style="font-size: 0.875rem;">一体化处理，性能均衡</p>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
            </div>

            <div class="code-block mt-4">
                <div class="code-header">
                    <span class="code-lang">Python - 多工具效果对比</span>
                    <div class="code-actions">
                        <button class="code-btn" onclick="toggleCode(this)">展开</button>
                        <button class="code-btn" onclick="copyCode(this)">复制</button>
                    </div>
                </div>
                <div class="code-content collapsed">
                    <pre><span class="comment"># 多工具效果对比实验</span>
<span class="keyword">import</span> time
<span class="keyword">import</span> jieba
<span class="keyword">import</span> pkuseg
<span class="keyword">import</span> thulac
<span class="keyword">from</span> LAC <span class="keyword">import</span> LAC

<span class="comment"># 测试文本</span>
test_texts = [
    <span class="string">"南京市长江大桥"</span>,  <span class="comment"># 歧义</span>
    <span class="string">"他研究生物化学"</span>,  <span class="comment"># 歧义</span>
    <span class="string">"马云和马化腾是中国互联网的代表人物"</span>,  <span class="comment"># 人名识别</span>
    <span class="string">"我用Python写自然语言处理程序"</span>,  <span class="comment"># 混合语言</span>
    <span class="string">"新冠疫苗接种率达到85%以上"</span>,  <span class="comment"># 新词</span>
]

<span class="keyword">def</span> <span class="function">benchmark_tools</span>(texts):
    <span class="string">"""对比不同工具的效果和性能"""</span>
    results = {}

    <span class="comment"># 1. jieba</span>
    print(<span class="string">"=== jieba ==="</span>)
    start = time.time()
    jieba_results = []
    <span class="keyword">for</span> text <span class="keyword">in</span> texts:
        result = list(jieba.cut(text))
        jieba_results.append(result)
        print(<span class="string">f"{text} → {'/'.join(result)}"</span>)
    jieba_time = time.time() - start
    results[<span class="string">'jieba'</span>] = {<span class="string">'time'</span>: jieba_time, <span class="string">'results'</span>: jieba_results}

    <span class="comment"># 2. pkuseg</span>
    print(<span class="string">"\n=== pkuseg ==="</span>)
    seg = pkuseg.pkuseg()
    start = time.time()
    pkuseg_results = []
    <span class="keyword">for</span> text <span class="keyword">in</span> texts:
        result = seg.cut(text)
        pkuseg_results.append(result)
        print(<span class="string">f"{text} → {'/'.join(result)}"</span>)
    pkuseg_time = time.time() - start
    results[<span class="string">'pkuseg'</span>] = {<span class="string">'time'</span>: pkuseg_time, <span class="string">'results'</span>: pkuseg_results}

    <span class="comment"># 3. THULAC</span>
    print(<span class="string">"\n=== THULAC ==="</span>)
    thu = thulac.thulac(seg_only=<span class="keyword">True</span>)
    start = time.time()
    thulac_results = []
    <span class="keyword">for</span> text <span class="keyword">in</span> texts:
        result = thu.cut(text, text=<span class="keyword">True</span>).split()
        thulac_results.append(result)
        print(<span class="string">f"{text} → {'/'.join(result)}"</span>)
    thulac_time = time.time() - start
    results[<span class="string">'thulac'</span>] = {<span class="string">'time'</span>: thulac_time, <span class="string">'results'</span>: thulac_results}

    <span class="comment"># 4. LAC（词法分析）</span>
    print(<span class="string">"\n=== LAC (百度) ==="</span>)
    lac = LAC(mode=<span class="string">'seg'</span>)
    start = time.time()
    lac_results = []
    <span class="keyword">for</span> text <span class="keyword">in</span> texts:
        result = lac.run(text)[<span class="number">0</span>]
        lac_results.append(result)
        print(<span class="string">f"{text} → {'/'.join(result)}"</span>)
    lac_time = time.time() - start
    results[<span class="string">'lac'</span>] = {<span class="string">'time'</span>: lac_time, <span class="string">'results'</span>: lac_results}

    <span class="comment"># 性能对比</span>
    print(<span class="string">"\n=== 性能对比 ==="</span>)
    <span class="keyword">for</span> tool, data <span class="keyword">in</span> results.items():
        print(<span class="string">f"{tool}: {data['time']:.3f}秒"</span>)

    <span class="comment"># 差异分析</span>
    print(<span class="string">"\n=== 分词差异分析 ==="</span>)
    <span class="keyword">for</span> i, text <span class="keyword">in</span> enumerate(texts):
        diffs = []
        tools = list(results.keys())
        <span class="keyword">for</span> j <span class="keyword">in</span> range(len(tools)):
            <span class="keyword">for</span> k <span class="keyword">in</span> range(j+<span class="number">1</span>, len(tools)):
                result1 = results[tools[j]][<span class="string">'results'</span>][i]
                result2 = results[tools[k]][<span class="string">'results'</span>][i]
                <span class="keyword">if</span> result1 != result2:
                    diffs.append(<span class="string">f"{tools[j]} vs {tools[k]}"</span>)

        <span class="keyword">if</span> diffs:
            print(<span class="string">f"\n文本：{text}"</span>)
            print(<span class="string">f"存在分歧：{', '.join(diffs)}"</span>)
            <span class="keyword">for</span> tool <span class="keyword">in</span> tools:
                print(<span class="string">f"  {tool}: {'/'.join(results[tool]['results'][i])}"</span>)

<span class="comment"># 运行对比</span>
benchmark_tools(test_texts)

<span class="comment"># 领域适应性测试</span>
print(<span class="string">"\n=== 领域适应性测试 ==="</span>)
domain_texts = {
    <span class="string">'医疗'</span>: <span class="string">"患者确诊为甲状腺功能亢进症"</span>,
    <span class="string">'金融'</span>: <span class="string">"央行降准释放流动性"</span>,
    <span class="string">'科技'</span>: <span class="string">"深度学习框架TensorFlow发布新版本"</span>,
    <span class="string">'法律'</span>: <span class="string">"被告人犯故意伤害罪"</span>
}

<span class="comment"># 使用pkuseg的领域模型</span>
<span class="keyword">for</span> domain, text <span class="keyword">in</span> domain_texts.items():
    print(<span class="string">f"\n{domain}领域：{text}"</span>)

    <span class="comment"># 通用模型</span>
    seg_general = pkuseg.pkuseg()
    result_general = seg_general.cut(text)
    print(<span class="string">f"通用模型：{'/'.join(result_general)}"</span>)

    <span class="comment"># 领域模型（如果有）</span>
    <span class="keyword">try</span>:
        <span class="keyword">if</span> domain == <span class="string">'医疗'</span>:
            seg_domain = pkuseg.pkuseg(model_name=<span class="string">'medicine'</span>)
        <span class="keyword">elif</span> domain == <span class="string">'新闻'</span>:
            seg_domain = pkuseg.pkuseg(model_name=<span class="string">'news'</span>)
        <span class="keyword">else</span>:
            <span class="keyword">continue</span>

        result_domain = seg_domain.cut(text)
        print(<span class="string">f"领域模型：{'/'.join(result_domain)}"</span>)
    <span class="keyword">except</span>:
        <span class="keyword">pass</span></pre>
                </div>
            </div>
        </section>

        <!-- 构建预处理管道 -->
        <section id="practice" class="section-card">
            <h2>🔧 实战：构建工业级预处理管道</h2>

            <div class="story-card">
                <span class="story-icon">🏭</span>
                <p><strong>从实验室到生产环境</strong></p>
                <p class="mt-2">
                    "在Jupyter里跑得好好的代码，为什么到生产环境就崩了？"
                </p>
                <p class="mt-2">
                    这是每个NLP工程师都会遇到的问题。实验室环境和生产环境的差异：
                </p>
                <ul class="mt-2">
                    <li>数据量：100条 vs 1亿条</li>
                    <li>实时性：离线处理 vs 毫秒级响应</li>
                    <li>容错性：崩溃重跑 vs 7×24稳定运行</li>
                </ul>
            </div>

            <div class="algorithm-steps">
                <h4 class="mb-4" style="color: var(--primary-light);">🏗️ 工业级预处理管道架构</h4>

                <div class="step-item">
                    <div class="step-number">1</div>
                    <div class="step-content">
                        <h5>模块化设计</h5>
                        <p>每个处理步骤独立封装，便于维护和扩展</p>
                        <div class="code-block mt-3">
                            <div class="code-header">
                                <span class="code-lang">Python - 模块化预处理管道</span>
                            </div>
                            <div class="code-content">
                                <pre><span class="keyword">from</span> abc <span class="keyword">import</span> ABC, abstractmethod
<span class="keyword">from</span> typing <span class="keyword">import</span> List, Dict, Any
<span class="keyword">import</span> logging

<span class="keyword">class</span> <span class="function">PreprocessStep</span>(ABC):
    <span class="string">"""预处理步骤基类"""</span>

    <span class="keyword">def</span> <span class="function">__init__</span>(self, name: str):
        self.name = name
        self.logger = logging.getLogger(name)

    @abstractmethod
    <span class="keyword">def</span> <span class="function">process</span>(self, text: str) -> str:
        <span class="string">"""处理文本"""</span>
        <span class="keyword">pass</span>

    <span class="keyword">def</span> <span class="function">__call__</span>(self, text: str) -> str:
        <span class="keyword">try</span>:
            result = self.process(text)
            self.logger.debug(<span class="string">f"处理成功: {self.name}"</span>)
            <span class="keyword">return</span> result
        <span class="keyword">except</span> Exception <span class="keyword">as</span> e:
            self.logger.error(<span class="string">f"处理失败: {self.name}, 错误: {e}"</span>)
            <span class="comment"># 失败时返回原文本，保证管道继续运行</span>
            <span class="keyword">return</span> text

<span class="keyword">class</span> <span class="function">Pipeline</span>:
    <span class="string">"""预处理管道"""</span>

    <span class="keyword">def</span> <span class="function">__init__</span>(self, steps: List[PreprocessStep] = None):
        self.steps = steps <span class="keyword">or</span> []
        self.logger = logging.getLogger(<span class="string">'Pipeline'</span>)

    <span class="keyword">def</span> <span class="function">add_step</span>(self, step: PreprocessStep):
        <span class="string">"""添加处理步骤"""</span>
        self.steps.append(step)
        <span class="keyword">return</span> self  <span class="comment"># 支持链式调用</span>

    <span class="keyword">def</span> <span class="function">process</span>(self, text: str) -> Dict[str, Any]:
        <span class="string">"""执行管道处理"""</span>
        result = {<span class="string">'original'</span>: text}
        current_text = text

        <span class="keyword">for</span> step <span class="keyword">in</span> self.steps:
            current_text = step(current_text)
            result[step.name] = current_text

        result[<span class="string">'final'</span>] = current_text
        <span class="keyword">return</span> result

    <span class="keyword">def</span> <span class="function">batch_process</span>(self, texts: List[str],
                        n_jobs: int = <span class="number">1</span>) -> List[Dict[str, Any]]:
        <span class="string">"""批量处理"""</span>
        <span class="keyword">if</span> n_jobs == <span class="number">1</span>:
            <span class="keyword">return</span> [self.process(text) <span class="keyword">for</span> text <span class="keyword">in</span> texts]
        <span class="keyword">else</span>:
            <span class="keyword">from</span> multiprocessing <span class="keyword">import</span> Pool
            <span class="keyword">with</span> Pool(n_jobs) <span class="keyword">as</span> pool:
                <span class="keyword">return</span> pool.map(self.process, texts)</pre>
                            </div>
                        </div>
                    </div>
                </div>

                <div class="step-item">
                    <div class="step-number">2</div>
                    <div class="step-content">
                        <h5>实现具体的处理步骤</h5>
                        <p>根据业务需求实现各种预处理模块</p>
                        <div class="code-block mt-3">
                            <div class="code-header">
                                <span class="code-lang">Python - 具体处理步骤实现</span>
                            </div>
                            <div class="code-content collapsed">
                                <pre><span class="keyword">import</span> re
<span class="keyword">import</span> jieba
<span class="keyword">from</span> typing <span class="keyword">import</span> Set

<span class="keyword">class</span> <span class="function">TextCleaner</span>(PreprocessStep):
    <span class="string">"""文本清洗步骤"""</span>

    <span class="keyword">def</span> <span class="function">__init__</span>(self):
        <span class="keyword">super</span>().__init__(<span class="string">'text_cleaner'</span>)

    <span class="keyword">def</span> <span class="function">process</span>(self, text: str) -> str:
        <span class="comment"># 去除HTML</span>
        text = re.sub(<span class="string">r'<[^>]+>'</span>, <span class="string">''</span>, text)
        <span class="comment"># 去除URL</span>
        text = re.sub(<span class="string">r'https?://[^\s]+'</span>, <span class="string">''</span>, text)
        <span class="comment"># 统一空白</span>
        text = re.sub(<span class="string">r'\s+'</span>, <span class="string">' '</span>, text)
        <span class="keyword">return</span> text.strip()

<span class="keyword">class</span> <span class="function">TextNormalizer</span>(PreprocessStep):
    <span class="string">"""文本规范化步骤"""</span>

    <span class="keyword">def</span> <span class="function">__init__</span>(self):
        <span class="keyword">super</span>().__init__(<span class="string">'normalizer'</span>)
        <span class="comment"># 构建映射表</span>
        self.char_mapping = self._build_mapping()

    <span class="keyword">def</span> <span class="function">_build_mapping</span>(self):
        <span class="string">"""构建字符映射表"""</span>
        mapping = {}
        <span class="comment"># 全角转半角</span>
        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0xFF01</span>, <span class="number">0xFF5F</span>):
            mapping[chr(i)] = chr(i - <span class="number">0xFEE0</span>)
        <span class="comment"># 常见变体</span>
        mapping.update({
            <span class="string">'【'</span>: <span class="string">'['</span>, <span class="string">'】'</span>: <span class="string">']'</span>,
            <span class="string">'（'</span>: <span class="string">'('</span>, <span class="string">'）'</span>: <span class="string">')'</span>,
            <span class="string">'～'</span>: <span class="string">'~'</span>, <span class="string">'！'</span>: <span class="string">'!'</span>
        })
        <span class="keyword">return</span> mapping

    <span class="keyword">def</span> <span class="function">process</span>(self, text: str) -> str:
        <span class="comment"># 字符替换</span>
        chars = []
        <span class="keyword">for</span> char <span class="keyword">in</span> text:
            chars.append(self.char_mapping.get(char, char))
        <span class="keyword">return</span> <span class="string">''</span>.join(chars).lower()

<span class="keyword">class</span> <span class="function">Tokenizer</span>(PreprocessStep):
    <span class="string">"""分词步骤"""</span>

    <span class="keyword">def</span> <span class="function">__init__</span>(self, custom_dict: str = None):
        <span class="keyword">super</span>().__init__(<span class="string">'tokenizer'</span>)
        <span class="keyword">if</span> custom_dict:
            jieba.load_userdict(custom_dict)

    <span class="keyword">def</span> <span class="function">process</span>(self, text: str) -> str:
        tokens = jieba.cut(text)
        <span class="keyword">return</span> <span class="string">' '</span>.join(tokens)

<span class="keyword">class</span> <span class="function">StopwordRemover</span>(PreprocessStep):
    <span class="string">"""停用词过滤步骤"""</span>

    <span class="keyword">def</span> <span class="function">__init__</span>(self, stopwords_file: str = None):
        <span class="keyword">super</span>().__init__(<span class="string">'stopword_remover'</span>)
        self.stopwords = self._load_stopwords(stopwords_file)

    <span class="keyword">def</span> <span class="function">_load_stopwords</span>(self, file_path: str) -> Set[str]:
        <span class="keyword">if</span> <span class="keyword">not</span> file_path:
            <span class="keyword">return</span> {<span class="string">'的'</span>, <span class="string">'了'</span>, <span class="string">'和'</span>, <span class="string">'是'</span>, <span class="string">'在'</span>}

        <span class="keyword">with</span> open(file_path, <span class="string">'r'</span>, encoding=<span class="string">'utf-8'</span>) <span class="keyword">as</span> f:
            <span class="keyword">return</span> set(line.strip() <span class="keyword">for</span> line <span class="keyword">in</span> f)

    <span class="keyword">def</span> <span class="function">process</span>(self, text: str) -> str:
        tokens = text.split()
        filtered = [t <span class="keyword">for</span> t <span class="keyword">in</span> tokens <span class="keyword">if</span> t <span class="keyword">not in</span> self.stopwords]
        <span class="keyword">return</span> <span class="string">' '</span>.join(filtered)

<span class="keyword">class</span> <span class="function">LengthFilter</span>(PreprocessStep):
    <span class="string">"""长度过滤步骤"""</span>

    <span class="keyword">def</span> <span class="function">__init__</span>(self, min_len: int = <span class="number">2</span>, max_len: int = <span class="number">1000</span>):
        <span class="keyword">super</span>().__init__(<span class="string">'length_filter'</span>)
        self.min_len = min_len
        self.max_len = max_len

    <span class="keyword">def</span> <span class="function">process</span>(self, text: str) -> str:
        <span class="keyword">if</span> len(text) < self.min_len:
            <span class="keyword">return</span> <span class="string">''</span>
        <span class="keyword">if</span> len(text) > self.max_len:
            <span class="keyword">return</span> text[:self.max_len]
        <span class="keyword">return</span> text</pre>
                            </div>
                        </div>
                    </div>
                </div>

                <div class="step-item">
                    <div class="step-number">3</div>
                    <div class="step-content">
                        <h5>配置化管理</h5>
                        <p>通过配置文件灵活控制管道行为</p>
                        <div class="code-block mt-3">
                            <div class="code-header">
                                <span class="code-lang">YAML - 管道配置文件</span>
                            </div>
                            <div class="code-content">
                                <pre><span class="comment"># preprocess_config.yaml</span>
pipeline:
  name: <span class="string">"production_pipeline"</span>
  version: <span class="string">"1.0.0"</span>

steps:
  - name: <span class="string">"cleaner"</span>
    class: <span class="string">"TextCleaner"</span>
    enabled: <span class="keyword">true</span>

  - name: <span class="string">"normalizer"</span>
    class: <span class="string">"TextNormalizer"</span>
    enabled: <span class="keyword">true</span>

  - name: <span class="string">"tokenizer"</span>
    class: <span class="string">"Tokenizer"</span>
    enabled: <span class="keyword">true</span>
    params:
      custom_dict: <span class="string">"./data/custom_dict.txt"</span>

  - name: <span class="string">"stopword_remover"</span>
    class: <span class="string">"StopwordRemover"</span>
    enabled: <span class="keyword">true</span>
    params:
      stopwords_file: <span class="string">"./data/stopwords.txt"</span>

  - name: <span class="string">"length_filter"</span>
    class: <span class="string">"LengthFilter"</span>
    enabled: <span class="keyword">true</span>
    params:
      min_len: <span class="number">5</span>
      max_len: <span class="number">500</span>

logging:
  level: <span class="string">"INFO"</span>
  format: <span class="string">"%(asctime)s - %(name)s - %(levelname)s - %(message)s"</span>

performance:
  batch_size: <span class="number">1000</span>
  n_jobs: <span class="number">4</span>
  timeout: <span class="number">30</span></pre>
                            </div>
                        </div>
                    </div>
                </div>

                <div class="step-item">
                    <div class="step-number">4</div>
                    <div class="step-content">
                        <h5>生产环境部署</h5>
                        <p>构建高性能、高可用的服务</p>
                        <div class="code-block mt-3">
                            <div class="code-header">
                                <span class="code-lang">Python - 生产级预处理服务</span>
                            </div>
                            <div class="code-content collapsed">
                                <pre><span class="keyword">import</span> yaml
<span class="keyword">import</span> asyncio
<span class="keyword">import</span> aioredis
<span class="keyword">from</span> fastapi <span class="keyword">import</span> FastAPI, HTTPException
<span class="keyword">from</span> pydantic <span class="keyword">import</span> BaseModel
<span class="keyword">from</span> typing <span class="keyword">import</span> List, Optional
<span class="keyword">import</span> hashlib
<span class="keyword">import</span> json

<span class="keyword">class</span> <span class="function">PreprocessRequest</span>(BaseModel):
    texts: List[str]
    pipeline: Optional[str] = <span class="string">"default"</span>
    use_cache: Optional[bool] = <span class="keyword">True</span>

<span class="keyword">class</span> <span class="function">PreprocessResponse</span>(BaseModel):
    results: List[Dict[str, Any]]
    pipeline_used: str
    processing_time: float

<span class="keyword">class</span> <span class="function">PreprocessService</span>:
    <span class="string">"""预处理服务"""</span>

    <span class="keyword">def</span> <span class="function">__init__</span>(self, config_file: str):
        self.config = self._load_config(config_file)
        self.pipelines = {}
        self.redis = None
        self._init_pipelines()

    <span class="keyword">def</span> <span class="function">_load_config</span>(self, config_file: str):
        <span class="keyword">with</span> open(config_file, <span class="string">'r'</span>) <span class="keyword">as</span> f:
            <span class="keyword">return</span> yaml.safe_load(f)

    <span class="keyword">def</span> <span class="function">_init_pipelines</span>(self):
        <span class="string">"""初始化管道"""</span>
        <span class="comment"># 根据配置构建管道</span>
        pipeline = Pipeline()

        <span class="keyword">for</span> step_config <span class="keyword">in</span> self.config[<span class="string">'steps'</span>]:
            <span class="keyword">if</span> <span class="keyword">not</span> step_config.get(<span class="string">'enabled'</span>, <span class="keyword">True</span>):
                <span class="keyword">continue</span>

            <span class="comment"># 动态加载类</span>
            class_name = step_config[<span class="string">'class'</span>]
            params = step_config.get(<span class="string">'params'</span>, {})

            <span class="keyword">if</span> class_name == <span class="string">'TextCleaner'</span>:
                step = TextCleaner()
            <span class="keyword">elif</span> class_name == <span class="string">'TextNormalizer'</span>:
                step = TextNormalizer()
            <span class="keyword">elif</span> class_name == <span class="string">'Tokenizer'</span>:
                step = Tokenizer(**params)
            <span class="keyword">elif</span> class_name == <span class="string">'StopwordRemover'</span>:
                step = StopwordRemover(**params)
            <span class="keyword">elif</span> class_name == <span class="string">'LengthFilter'</span>:
                step = LengthFilter(**params)

            pipeline.add_step(step)

        self.pipelines[<span class="string">'default'</span>] = pipeline

    <span class="keyword">async</span> <span class="keyword">def</span> <span class="function">init_cache</span>(self):
        <span class="string">"""初始化缓存"""</span>
        self.redis = <span class="keyword">await</span> aioredis.create_redis_pool(
            <span class="string">'redis://localhost'</span>,
            encoding=<span class="string">'utf-8'</span>
        )

    <span class="keyword">def</span> <span class="function">_get_cache_key</span>(self, text: str, pipeline: str) -> str:
        <span class="string">"""生成缓存键"""</span>
        content = <span class="string">f"{pipeline}:{text}"</span>
        <span class="keyword">return</span> hashlib.md5(content.encode()).hexdigest()

    <span class="keyword">async</span> <span class="keyword">def</span> <span class="function">process_with_cache</span>(self, text: str,
                                   pipeline_name: str) -> Dict[str, Any]:
        <span class="string">"""带缓存的处理"""</span>
        cache_key = self._get_cache_key(text, pipeline_name)

        <span class="comment"># 尝试从缓存获取</span>
        <span class="keyword">if</span> self.redis:
            cached = <span class="keyword">await</span> self.redis.get(cache_key)
            <span class="keyword">if</span> cached:
                <span class="keyword">return</span> json.loads(cached)

        <span class="comment"># 处理文本</span>
        pipeline = self.pipelines[pipeline_name]
        result = pipeline.process(text)

        <span class="comment"># 写入缓存</span>
        <span class="keyword">if</span> self.redis:
            <span class="keyword">await</span> self.redis.setex(
                cache_key,
                <span class="number">3600</span>,  <span class="comment"># 1小时过期</span>
                json.dumps(result)
            )

        <span class="keyword">return</span> result

    <span class="keyword">async</span> <span class="keyword">def</span> <span class="function">batch_process</span>(self, texts: List[str],
                            pipeline_name: str,
                            use_cache: bool) -> List[Dict[str, Any]]:
        <span class="string">"""批量处理"""</span>
        <span class="keyword">if</span> use_cache <span class="keyword">and</span> self.redis:
            <span class="comment"># 并发处理</span>
            tasks = [
                self.process_with_cache(text, pipeline_name)
                <span class="keyword">for</span> text <span class="keyword">in</span> texts
            ]
            <span class="keyword">return</span> <span class="keyword">await</span> asyncio.gather(*tasks)
        <span class="keyword">else</span>:
            <span class="comment"># 不使用缓存</span>
            pipeline = self.pipelines[pipeline_name]
            <span class="keyword">return</span> [pipeline.process(text) <span class="keyword">for</span> text <span class="keyword">in</span> texts]

<span class="comment"># FastAPI应用</span>
app = FastAPI(title=<span class="string">"文本预处理服务"</span>)
service = PreprocessService(<span class="string">"preprocess_config.yaml"</span>)

@app.on_event(<span class="string">"startup"</span>)
<span class="keyword">async</span> <span class="keyword">def</span> <span class="function">startup_event</span>():
    <span class="keyword">await</span> service.init_cache()

@app.post(<span class="string">"/preprocess"</span>, response_model=PreprocessResponse)
<span class="keyword">async</span> <span class="keyword">def</span> <span class="function">preprocess</span>(request: PreprocessRequest):
    <span class="string">"""预处理接口"""</span>
    <span class="keyword">import</span> time

    start_time = time.time()

    <span class="keyword">try</span>:
        results = <span class="keyword">await</span> service.batch_process(
            request.texts,
            request.pipeline,
            request.use_cache
        )

        processing_time = time.time() - start_time

        <span class="keyword">return</span> PreprocessResponse(
            results=results,
            pipeline_used=request.pipeline,
            processing_time=processing_time
        )

    <span class="keyword">except</span> Exception <span class="keyword">as</span> e:
        <span class="keyword">raise</span> HTTPException(status_code=<span class="number">500</span>, detail=str(e))

@app.get(<span class="string">"/health"</span>)
<span class="keyword">async</span> <span class="keyword">def</span> <span class="function">health_check</span>():
    <span class="string">"""健康检查"""</span>
    <span class="keyword">return</span> {<span class="string">"status"</span>: <span class="string">"healthy"</span>}

<span class="comment"># 运行服务</span>
<span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:
    <span class="keyword">import</span> uvicorn
    uvicorn.run(app, host=<span class="string">"0.0.0.0"</span>, port=<span class="number">8000</span>)</pre>
                            </div>
                        </div>
                    </div>
                </div>
            </div>

            <div class="tip info mt-4">
                <span class="tip-icon">🚀</span>
                <strong>生产环境最佳实践</strong>
                <ul class="mt-2">
                    <li><strong>监控告警：</strong>记录处理时间、错误率、资源使用</li>
                    <li><strong>优雅降级：</strong>某个步骤失败不影响整体</li>
                    <li><strong>版本管理：</strong>支持多版本管道共存</li>
                    <li><strong>A/B测试：</strong>灰度发布新的预处理策略</li>
                    <li><strong>性能优化：</strong>缓存、批处理、异步处理</li>
                </ul>
            </div>
        </section>

        <!-- 性能优化 -->
        <section id="optimization" class="section-card">
            <h2>⚡ 性能优化：让预处理飞起来</h2>

            <div class="story-card">
                <span class="story-icon">🐌</span>
                <p><strong>从蜗牛到火箭</strong></p>
                <p class="mt-2">
                    "处理100万条文本要跑3个小时？"老板看着进度条，眉头紧锁。
                </p>
                <p class="mt-2">
                    "这样下去，我们的实时推荐系统永远上不了线。"
                </p>
                <p class="mt-3">
                    三天后，同样的100万条文本，5分钟处理完毕。发生了什么？
                </p>
            </div>

            <div class="visualization">
                <h4 class="mb-3" style="color: var(--primary-light);">📊 优化前后对比</h4>

                <div class="card-grid">
                    <div class="info-card">
                        <h5 style="color: var(--danger);">优化前</h5>
                        <ul style="font-size: 0.9rem; text-align: left;">
                            <li>处理速度：100条/秒</li>
                            <li>内存占用：8GB</li>
                            <li>CPU利用率：25%（单核）</li>
                            <li>总耗时：3小时</li>
                        </ul>
                    </div>
                    <div class="info-card">
                        <h5 style="color: var(--success);">优化后</h5>
                        <ul style="font-size: 0.9rem; text-align: left;">
                            <li>处理速度：3333条/秒</li>
                            <li>内存占用：2GB</li>
                            <li>CPU利用率：95%（8核）</li>
                            <li>总耗时：5分钟</li>
                        </ul>
                    </div>
                </div>
            </div>

            <div class="algorithm-steps mt-4">
                <h4 class="mb-4" style="color: var(--primary-light);">🚀 性能优化秘籍</h4>

                <div class="step-item">
                    <div class="step-number">1</div>
                    <div class="step-content">
                        <h5>批处理：化零为整</h5>
                        <p>不要一条一条处理，要批量处理</p>
                        <div class="code-block mt-3">
                            <div class="code-header">
                                <span class="code-lang">Python - 批处理优化</span>
                            </div>
                            <div class="code-content">
                                <pre><span class="comment"># ❌ 低效：逐条处理</span>
results = []
<span class="keyword">for</span> text <span class="keyword">in</span> texts:
    result = jieba.cut(text)
    results.append(list(result))

<span class="comment"># ✅ 高效：批处理</span>
<span class="keyword">def</span> <span class="function">batch_tokenize</span>(texts, batch_size=<span class="number">1000</span>):
    results = []
    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>, len(texts), batch_size):
        batch = texts[i:i+batch_size]
        <span class="comment"># 批量处理，减少函数调用开销</span>
        batch_results = [list(jieba.cut(t)) <span class="keyword">for</span> t <span class="keyword">in</span> batch]
        results.extend(batch_results)
    <span class="keyword">return</span> results</pre>
                            </div>
                        </div>
                    </div>
                </div>

                <div class="step-item">
                    <div class="step-number">2</div>
                    <div class="step-content">
                        <h5>多进程并行：榨干CPU</h5>
                        <p>利用多核CPU并行处理</p>
                        <div class="code-block mt-3">
                            <div class="code-header">
                                <span class="code-lang">Python - 多进程优化</span>
                            </div>
                            <div class="code-content collapsed">
                                <pre><span class="keyword">from</span> multiprocessing <span class="keyword">import</span> Pool, cpu_count
<span class="keyword">import</span> numpy <span class="keyword">as</span> np

<span class="keyword">def</span> <span class="function">parallel_process</span>(texts, process_func, n_jobs=None):
    <span class="string">"""并行处理文本"""</span>
    <span class="keyword">if</span> n_jobs <span class="keyword">is</span> None:
        n_jobs = cpu_count()

    <span class="comment"># 将数据分成n_jobs份</span>
    text_chunks = np.array_split(texts, n_jobs)

    <span class="comment"># 创建进程池</span>
    <span class="keyword">with</span> Pool(n_jobs) <span class="keyword">as</span> pool:
        <span class="comment"># 并行处理</span>
        results = pool.map(process_func, text_chunks)

    <span class="comment"># 合并结果</span>
    <span class="keyword">return</span> [item <span class="keyword">for</span> sublist <span class="keyword">in</span> results <span class="keyword">for</span> item <span class="keyword">in</span> sublist]

<span class="comment"># 处理函数需要能处理文本列表</span>
<span class="keyword">def</span> <span class="function">process_chunk</span>(texts):
    <span class="keyword">return</span> [<span class="string">' '</span>.join(jieba.cut(text)) <span class="keyword">for</span> text <span class="keyword">in</span> texts]

<span class="comment"># 使用示例</span>
texts = [<span class="string">"文本1"</span>, <span class="string">"文本2"</span>, ...] * <span class="number">100000</span>
results = parallel_process(texts, process_chunk, n_jobs=<span class="number">8</span>)</pre>
                            </div>
                        </div>
                    </div>
                </div>

                <div class="step-item">
                    <div class="step-number">3</div>
                    <div class="step-content">
                        <h5>缓存优化：避免重复计算</h5>
                        <p>对频繁出现的文本进行缓存</p>
                        <div class="code-block mt-3">
                            <div class="code-header">
                                <span class="code-lang">Python - 缓存优化</span>
                            </div>
                            <div class="code-content">
                                <pre><span class="keyword">from</span> functools <span class="keyword">import</span> lru_cache
<span class="keyword">import</span> hashlib

<span class="keyword">class</span> <span class="function">CachedTokenizer</span>:
    <span class="keyword">def</span> <span class="function">__init__</span>(self, cache_size=<span class="number">10000</span>):
        self.cache = {}
        self.cache_size = cache_size
        self.hit_count = <span class="number">0</span>
        self.miss_count = <span class="number">0</span>

    <span class="keyword">def</span> <span class="function">_get_key</span>(self, text):
        <span class="comment"># 使用MD5作为缓存键</span>
        <span class="keyword">return</span> hashlib.md5(text.encode()).hexdigest()

    <span class="keyword">def</span> <span class="function">tokenize</span>(self, text):
        key = self._get_key(text)

        <span class="keyword">if</span> key <span class="keyword">in</span> self.cache:
            self.hit_count += <span class="number">1</span>
            <span class="keyword">return</span> self.cache[key]

        self.miss_count += <span class="number">1</span>
        result = list(jieba.cut(text))

        <span class="comment"># LRU策略</span>
        <span class="keyword">if</span> len(self.cache) >= self.cache_size:
            <span class="comment"># 删除最早的缓存项</span>
            oldest = <span class="keyword">next</span>(iter(self.cache))
            <span class="keyword">del</span> self.cache[oldest]

        self.cache[key] = result
        <span class="keyword">return</span> result

    <span class="keyword">def</span> <span class="function">stats</span>(self):
        total = self.hit_count + self.miss_count
        hit_rate = self.hit_count / total <span class="keyword">if</span> total > <span class="number">0</span> <span class="keyword">else</span> <span class="number">0</span>
        <span class="keyword">return</span> {
            <span class="string">'hit_rate'</span>: hit_rate,
            <span class="string">'cache_size'</span>: len(self.cache)
        }</pre>
                            </div>
                        </div>
                    </div>
                </div>

                <div class="step-item">
                    <div class="step-number">4</div>
                    <div class="step-content">
                        <h5>内存优化：减少内存占用</h5>
                        <p>使用生成器和流式处理</p>
                        <div class="code-block mt-3">
                            <div class="code-header">
                                <span class="code-lang">Python - 内存优化</span>
                            </div>
                            <div class="code-content collapsed">
                                <pre><span class="comment"># ❌ 内存密集：一次性加载所有数据</span>
<span class="keyword">def</span> <span class="function">process_file_bad</span>(filename):
    <span class="keyword">with</span> open(filename, <span class="string">'r'</span>) <span class="keyword">as</span> f:
        texts = f.readlines()  <span class="comment"># 全部加载到内存</span>

    results = []
    <span class="keyword">for</span> text <span class="keyword">in</span> texts:
        results.append(process_text(text))
    <span class="keyword">return</span> results

<span class="comment"># ✅ 内存友好：流式处理</span>
<span class="keyword">def</span> <span class="function">process_file_stream</span>(filename):
    <span class="string">"""生成器方式处理大文件"""</span>
    <span class="keyword">with</span> open(filename, <span class="string">'r'</span>) <span class="keyword">as</span> f:
        <span class="keyword">for</span> line <span class="keyword">in</span> f:
            <span class="keyword">yield</span> process_text(line.strip())

<span class="comment"># 使用生成器处理</span>
<span class="keyword">for</span> result <span class="keyword">in</span> process_file_stream(<span class="string">'huge_file.txt'</span>):
    <span class="comment"># 逐条处理，内存占用稳定</span>
    save_to_db(result)

<span class="comment"># 内存映射文件（适合随机访问）</span>
<span class="keyword">import</span> mmap

<span class="keyword">def</span> <span class="function">process_with_mmap</span>(filename):
    <span class="keyword">with</span> open(filename, <span class="string">'r+b'</span>) <span class="keyword">as</span> f:
        <span class="keyword">with</span> mmap.mmap(f.fileno(), <span class="number">0</span>) <span class="keyword">as</span> mmapped_file:
            <span class="comment"># 像访问内存一样访问文件</span>
            <span class="keyword">for</span> line <span class="keyword">in</span> iter(mmapped_file.readline, <span class="string">b""</span>):
                text = line.decode(<span class="string">'utf-8'</span>).strip()
                <span class="keyword">yield</span> process_text(text)</pre>
                            </div>
                        </div>
                    </div>
                </div>

                <div class="step-item">
                    <div class="step-number">5</div>
                    <div class="step-content">
                        <h5>算法优化：选择更快的算法</h5>
                        <p>不同场景选择不同的算法实现</p>
                        <div class="comparison-table">
                            <table>
                                <thead>
                                <tr>
                                    <th>任务</th>
                                    <th>慢速方案</th>
                                    <th>快速方案</th>
                                    <th>加速比</th>
                                </tr>
                                </thead>
                                <tbody>
                                <tr>
                                    <td>分词</td>
                                    <td>深度学习模型</td>
                                    <td>词典+规则</td>
                                    <td>100x</td>
                                </tr>
                                <tr>
                                    <td>去重</td>
                                    <td>嵌套循环 O(n²)</td>
                                    <td>哈希表 O(n)</td>
                                    <td>1000x</td>
                                </tr>
                                <tr>
                                    <td>正则匹配</td>
                                    <td>复杂正则</td>
                                    <td>简单字符串操作</td>
                                    <td>10x</td>
                                </tr>
                                <tr>
                                    <td>相似度计算</td>
                                    <td>编辑距离</td>
                                    <td>SimHash</td>
                                    <td>50x</td>
                                </tr>
                                </tbody>
                            </table>
                        </div>
                    </div>
                </div>
            </div>

            <div class="code-block mt-4">
                <div class="code-header">
                    <span class="code-lang">Python - 完整的优化示例</span>
                    <div class="code-actions">
                        <button class="code-btn" onclick="toggleCode(this)">展开</button>
                        <button class="code-btn" onclick="copyCode(this)">复制</button>
                    </div>
                </div>
                <div class="code-content collapsed">
                    <pre><span class="keyword">import</span> time
<span class="keyword">import</span> psutil
<span class="keyword">import</span> os
<span class="keyword">from</span> multiprocessing <span class="keyword">import</span> Pool, Manager
<span class="keyword">from</span> threading <span class="keyword">import</span> Thread
<span class="keyword">from</span> queue <span class="keyword">import</span> Queue
<span class="keyword">import</span> numpy <span class="keyword">as</span> np

<span class="keyword">class</span> <span class="function">OptimizedPreprocessor</span>:
    <span class="string">"""优化的预处理器"""</span>

    <span class="keyword">def</span> <span class="function">__init__</span>(self, n_workers=None, cache_size=<span class="number">10000</span>):
        self.n_workers = n_workers <span class="keyword">or</span> os.cpu_count()
        self.cache_size = cache_size
        self.stats = {
            <span class="string">'processed'</span>: <span class="number">0</span>,
            <span class="string">'cache_hits'</span>: <span class="number">0</span>,
            <span class="string">'processing_time'</span>: <span class="number">0</span>
        }

    <span class="keyword">def</span> <span class="function">preprocess_batch_optimized</span>(self, texts, batch_size=<span class="number">1000</span>):
        <span class="string">"""优化的批处理"""</span>
        start_time = time.time()

        <span class="comment"># 1. 去重优化：相同文本只处理一次</span>
        unique_texts = list(set(texts))
        text_to_index = {text: [] <span class="keyword">for</span> text <span class="keyword">in</span> unique_texts}
        <span class="keyword">for</span> i, text <span class="keyword">in</span> enumerate(texts):
            text_to_index[text].append(i)

        print(<span class="string">f"去重效果：{len(texts)} → {len(unique_texts)}"</span>)

        <span class="comment"># 2. 分批处理</span>
        batches = [unique_texts[i:i+batch_size]
                   <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>, len(unique_texts), batch_size)]

        <span class="comment"># 3. 多进程并行</span>
        <span class="keyword">with</span> Pool(self.n_workers) <span class="keyword">as</span> pool:
            batch_results = pool.map(self._process_batch, batches)

        <span class="comment"># 4. 结果重组</span>
        processed_texts = {}
        <span class="keyword">for</span> batch, results <span class="keyword">in</span> zip(batches, batch_results):
            <span class="keyword">for</span> text, result <span class="keyword">in</span> zip(batch, results):
                processed_texts[text] = result

        <span class="comment"># 5. 恢复原始顺序</span>
        final_results = [<span class="keyword">None</span>] * len(texts)
        <span class="keyword">for</span> text, indices <span class="keyword">in</span> text_to_index.items():
            result = processed_texts[text]
            <span class="keyword">for</span> idx <span class="keyword">in</span> indices:
                final_results[idx] = result

        self.stats[<span class="string">'processed'</span>] += len(texts)
        self.stats[<span class="string">'processing_time'</span>] += time.time() - start_time

        <span class="keyword">return</span> final_results

    <span class="keyword">def</span> <span class="function">_process_batch</span>(self, texts):
        <span class="string">"""处理一个批次"""</span>
        <span class="comment"># 导入放在函数内，避免多进程问题</span>
        <span class="keyword">import</span> jieba
        results = []

        <span class="keyword">for</span> text <span class="keyword">in</span> texts:
            <span class="comment"># 清洗</span>
            text = text.strip().lower()
            <span class="comment"># 分词</span>
            tokens = list(jieba.cut(text))
            <span class="comment"># 过滤</span>
            tokens = [t <span class="keyword">for</span> t <span class="keyword">in</span> tokens <span class="keyword">if</span> len(t) > <span class="number">1</span>]
            results.append(<span class="string">' '</span>.join(tokens))

        <span class="keyword">return</span> results

    <span class="keyword">def</span> <span class="function">benchmark</span>(self, texts):
        <span class="string">"""性能测试"""</span>
        print(<span class="string">"=== 性能测试 ==="</span>)
        print(<span class="string">f"文本数量：{len(texts)}"</span>)
        print(<span class="string">f"CPU核心数：{self.n_workers}"</span>)

        <span class="comment"># 内存使用（开始）</span>
        process = psutil.Process(os.getpid())
        mem_before = process.memory_info().rss / <span class="number">1024</span> / <span class="number">1024</span>  <span class="comment"># MB</span>

        <span class="comment"># 处理</span>
        start = time.time()
        results = self.preprocess_batch_optimized(texts)
        end = time.time()

        <span class="comment"># 内存使用（结束）</span>
        mem_after = process.memory_info().rss / <span class="number">1024</span> / <span class="number">1024</span>  <span class="comment"># MB</span>

        <span class="comment"># 统计</span>
        duration = end - start
        speed = len(texts) / duration

        print(<span class="string">f"\n处理时间：{duration:.2f} 秒"</span>)
        print(<span class="string">f"处理速度：{speed:.0f} 条/秒"</span>)
        print(<span class="string">f"内存使用：{mem_before:.1f}MB → {mem_after:.1f}MB"</span>)
        print(<span class="string">f"内存增长：{mem_after - mem_before:.1f}MB"</span>)

        <span class="keyword">return</span> results

<span class="comment"># 生产者-消费者模式（适合实时处理）</span>
<span class="keyword">class</span> <span class="function">StreamProcessor</span>:
    <span class="string">"""流式处理器"""</span>

    <span class="keyword">def</span> <span class="function">__init__</span>(self, n_consumers=<span class="number">4</span>):
        self.queue = Queue(maxsize=<span class="number">1000</span>)
        self.n_consumers = n_consumers
        self.results = {}
        self.running = <span class="keyword">False</span>

    <span class="keyword">def</span> <span class="function">start</span>(self):
        <span class="string">"""启动消费者线程"""</span>
        self.running = <span class="keyword">True</span>
        self.consumers = []

        <span class="keyword">for</span> i <span class="keyword">in</span> range(self.n_consumers):
            t = Thread(target=self._consumer, args=(i,))
            t.start()
            self.consumers.append(t)

    <span class="keyword">def</span> <span class="function">stop</span>(self):
        <span class="string">"""停止处理"""</span>
        self.running = <span class="keyword">False</span>
        <span class="keyword">for</span> _ <span class="keyword">in</span> range(self.n_consumers):
            self.queue.put(<span class="keyword">None</span>)
        <span class="keyword">for</span> t <span class="keyword">in</span> self.consumers:
            t.join()

    <span class="keyword">def</span> <span class="function">process</span>(self, text_id, text):
        <span class="string">"""添加文本到处理队列"""</span>
        self.queue.put((text_id, text))

    <span class="keyword">def</span> <span class="function">_consumer</span>(self, consumer_id):
        <span class="string">"""消费者线程"""</span>
        <span class="keyword">import</span> jieba

        <span class="keyword">while</span> self.running:
            item = self.queue.get()
            <span class="keyword">if</span> item <span class="keyword">is</span> <span class="keyword">None</span>:
                <span class="keyword">break</span>

            text_id, text = item
            <span class="comment"># 处理文本</span>
            tokens = list(jieba.cut(text))
            result = <span class="string">' '</span>.join(tokens)

            <span class="comment"># 保存结果</span>
            self.results[text_id] = result

            <span class="keyword">if</span> text_id % <span class="number">1000</span> == <span class="number">0</span>:
                print(<span class="string">f"Consumer {consumer_id}: 已处理 {text_id} 条"</span>)

<span class="comment"># 使用示例</span>
<span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:
    <span class="comment"># 生成测试数据</span>
    test_texts = [
        <span class="string">"这是一段测试文本，用于性能测试。"</span> * <span class="number">10</span>,
        <span class="string">"自然语言处理是人工智能的重要分支。"</span> * <span class="number">5</span>,
        <span class="string">"优化算法可以显著提升处理速度。"</span> * <span class="number">8</span>
    ] * <span class="number">10000</span>

    <span class="comment"># 批处理优化测试</span>
    processor = OptimizedPreprocessor(n_workers=<span class="number">8</span>)
    results = processor.benchmark(test_texts)

    <span class="comment"># 流式处理示例</span>
    print(<span class="string">"\n=== 流式处理示例 ==="</span>)
    stream_processor = StreamProcessor(n_consumers=<span class="number">4</span>)
    stream_processor.start()

    <span class="comment"># 模拟实时数据流</span>
    <span class="keyword">for</span> i, text <span class="keyword">in</span> enumerate(test_texts[:<span class="number">1000</span>]):
        stream_processor.process(i, text)
        <span class="keyword">if</span> i % <span class="number">100</span> == <span class="number">0</span>:
            time.sleep(<span class="number">0.01</span>)  <span class="comment"># 模拟数据到达间隔</span>

    stream_processor.stop()
    print(<span class="string">f"流式处理完成，共处理 {len(stream_processor.results)} 条"</span>)</pre>
                </div>
            </div>

            <div class="tip warning mt-4">
                <span class="tip-icon">⚠️</span>
                <strong>性能优化的陷阱</strong>
                <ul class="mt-2">
                    <li><strong>过早优化：</strong>先让代码正确运行，再考虑优化</li>
                    <li><strong>过度优化：</strong>不要为了10%的提升牺牲代码可读性</li>
                    <li><strong>忽视瓶颈：</strong>用profiler找到真正的性能瓶颈</li>
                    <li><strong>内存泄漏：</strong>注意大对象的生命周期管理</li>
                </ul>
            </div>
        </section>

        <!-- 本章总结 -->
        <section id="summary" class="section-card">
            <h2>📚 本章总结</h2>

            <div class="story-card">
                <span class="story-icon">🎓</span>
                <p><strong>从bug到顿悟</strong></p>
                <p class="mt-2">
                    还记得开篇那个"iPhone11"的bug吗？一个小小的空格，引发了我们对文本预处理的深入探索。
                </p>
                <p class="mt-2">
                    现在回头看，文本预处理就像给机器戴上了一副"眼镜"，让它能看清人类语言的真实面貌。
                </p>
            </div>

            <div class="flow-diagram">
                <h4 class="text-center mb-4" style="color: var(--primary-light);">🗺️ 知识地图</h4>

                <div class="visualization">
                    <svg width="800" height="500" viewBox="0 0 800 500" style="max-width: 100%;">
                        <!-- 中心节点 -->
                        <circle cx="400" cy="250" r="60" fill="#6366f1" />
                        <text x="400" y="255" text-anchor="middle" fill="white" font-size="14" font-weight="bold">文本预处理</text>

                        <!-- 分支节点 -->
                        <!-- 文本清洗 -->
                        <circle cx="200" cy="100" r="40" fill="#ec4899" />
                        <text x="200" y="105" text-anchor="middle" fill="white" font-size="12">文本清洗</text>
                        <line x1="360" y1="220" x2="240" y2="130" stroke="#64748b" stroke-width="2" />

                        <!-- 分词 -->
                        <circle cx="600" cy="100" r="40" fill="#10b981" />
                        <text x="600" y="105" text-anchor="middle" fill="white" font-size="12">分词</text>
                        <line x1="440" y1="220" x2="560" y2="130" stroke="#64748b" stroke-width="2" />

                        <!-- 词性标注 -->
                        <circle cx="200" cy="400" r="40" fill="#f59e0b" />
                        <text x="200" y="405" text-anchor="middle" fill="white" font-size="12">词性标注</text>
                        <line x1="360" y1="280" x2="240" y2="370" stroke="#64748b" stroke-width="2" />

                        <!-- NER -->
                        <circle cx="600" cy="400" r="40" fill="#3b82f6" />
                        <text x="600" y="405" text-anchor="middle" fill="white" font-size="12">实体识别</text>
                        <line x1="440" y1="280" x2="560" y2="370" stroke="#64748b" stroke-width="2" />

                        <!-- 子节点 -->
                        <g font-size="10" fill="#94a3b8">
                            <!-- 文本清洗子节点 -->
                            <circle cx="100" cy="50" r="20" fill="#334155" />
                            <text x="100" y="53" text-anchor="middle">去噪</text>
                            <line x1="180" y1="85" x2="120" y2="65" stroke="#475569" stroke-width="1" />

                            <circle cx="100" cy="150" r="20" fill="#334155" />
                            <text x="100" y="153" text-anchor="middle">规范化</text>
                            <line x1="180" y1="115" x2="120" y2="135" stroke="#475569" stroke-width="1" />

                            <!-- 分词子节点 -->
                            <circle cx="700" cy="50" r="20" fill="#334155" />
                            <text x="700" y="53" text-anchor="middle">算法</text>
                            <line x1="620" y1="85" x2="680" y2="65" stroke="#475569" stroke-width="1" />

                            <circle cx="700" cy="150" r="20" fill="#334155" />
                            <text x="700" y="153" text-anchor="middle">工具</text>
                            <line x1="620" y1="115" x2="680" y2="135" stroke="#475569" stroke-width="1" />
                        </g>
                    </svg>
                </div>
            </div>

            <div class="card-grid mt-4">
                <div class="info-card">
                    <span class="card-icon">🎯</span>
                    <h3 class="card-title">核心要点</h3>
                    <ul>
                        <li>文本预处理是NLP的基础，质量决定上限</li>
                        <li>分词是中文NLP的特殊挑战</li>
                        <li>不同任务需要不同的预处理策略</li>
                        <li>工程实践和算法同样重要</li>
                    </ul>
                </div>

                <div class="info-card">
                    <span class="card-icon">💡</span>
                    <h3 class="card-title">实践建议</h3>
                    <ul>
                        <li>先用jieba快速原型，再考虑其他工具</li>
                        <li>建立领域词典，持续迭代优化</li>
                        <li>保留原始数据，预处理要可追溯</li>
                        <li>性能优化要基于实际瓶颈</li>
                    </ul>
                </div>

                <div class="info-card">
                    <span class="card-icon">🚀</span>
                    <h3 class="card-title">进阶方向</h3>
                    <ul>
                        <li>深度学习分词模型（BERT-based）</li>
                        <li>多语言统一处理框架</li>
                        <li>实时流式处理优化</li>
                        <li>自适应预处理策略</li>
                    </ul>
                </div>
            </div>

            <div class="tip success mt-4">
                <span class="tip-icon">🌟</span>
                <strong>记住：预处理不是目的，而是手段</strong>
                <p class="mt-2">
                    好的预处理应该是透明的——它默默工作，让后续的NLP任务能够专注于真正的语言理解，而不是纠结于文本的表面形式。
                </p>
                <p class="mt-2">
                    就像那个iPhone11的bug，解决之后，用户甚至不会意识到曾经有过这个问题。这就是优秀工程的魅力——<strong>把复杂留给自己，把简单留给用户。</strong>
                </p>
            </div>
        </section>

        <!-- 练习题 -->
        <section id="exercises" class="section-card">
            <h2>🏋️ 动手练习</h2>

            <div class="algorithm-steps">
                <div class="step-item">
                    <div class="step-number">1</div>
                    <div class="step-content">
                        <h5>基础练习：实现一个简单的分词器</h5>
                        <p>不使用任何外部库，实现最大匹配分词算法</p>
                        <div class="code-block mt-3">
                            <div class="code-header">
                                <span class="code-lang">Python - 练习模板</span>
                            </div>
                            <div class="code-content">
                                <pre><span class="keyword">def</span> <span class="function">max_match_tokenize</span>(text, dictionary):
    <span class="string">"""
    实现正向最大匹配分词

    输入：
    - text: 待分词文本
    - dictionary: 词典集合

    输出：
    - tokens: 分词结果列表

    提示：
    1. 从左到右扫描
    2. 每次找最长的匹配词
    3. 找不到就单字成词
    """</span>
    <span class="comment"># 你的代码</span>
    <span class="keyword">pass</span>

<span class="comment"># 测试</span>
dictionary = {<span class="string">'研究'</span>, <span class="string">'研究生'</span>, <span class="string">'生命'</span>, <span class="string">'起源'</span>}
text = <span class="string">"研究生命起源"</span>
<span class="comment"># 期望输出：['研究', '生命', '起源']</span></pre>
                            </div>
                        </div>
                    </div>
                </div>

                <div class="step-item">
                    <div class="step-number">2</div>
                    <div class="step-content">
                        <h5>进阶练习：构建文本清洗管道</h5>
                        <p>设计一个可配置的文本清洗系统，处理真实的社交媒体数据</p>
                        <div class="demo-container">
                            <p><strong>需求：</strong></p>
                            <ul>
                                <li>支持链式处理</li>
                                <li>可配置清洗规则</li>
                                <li>提供清洗报告</li>
                                <li>处理emoji、@提及、#话题等</li>
                            </ul>
                        </div>
                    </div>
                </div>

                <div class="step-item">
                    <div class="step-number">3</div>
                    <div class="step-content">
                        <h5>挑战练习：性能优化实战</h5>
                        <p>给定100万条电商评论，优化预处理速度</p>
                        <div class="demo-container">
                            <p><strong>目标：</strong></p>
                            <ul>
                                <li>处理速度 > 10000条/秒</li>
                                <li>内存占用 < 1GB</li>
                                <li>支持增量处理</li>
                                <li>结果可复现</li>
                            </ul>
                        </div>
                    </div>
                </div>
            </div>

            <div class="tip info mt-4">
                <span class="tip-icon">💭</span>
                <strong>思考题</strong>
                <ul class="mt-2">
                    <li>为什么英文分词相对简单，但英文NLP仍然很难？</li>
                    <li>深度学习时代，传统的分词技术还有价值吗？</li>
                    <li>如何评估预处理的效果？有哪些指标？</li>
                    <li>预处理会不会丢失信息？如何权衡？</li>
                </ul>
            </div>
        </section>
    </div>
</main>

<!-- JavaScript -->
<script>
    // 进度条
    window.addEventListener('scroll', function() {
        const winScroll = document.documentElement.scrollTop;
        const height = document.documentElement.scrollHeight - document.documentElement.clientHeight;
        const scrolled = (winScroll / height) * 100;
        document.getElementById('progress-bar').style.width = scrolled + '%';
    });

    // 侧边栏切换
    document.getElementById('toggle-sidebar').addEventListener('click', function() {
        document.getElementById('sidebar').classList.toggle('open');
    });

    // 目录高亮
    const sections = document.querySelectorAll('section[id]');
    const tocItems = document.querySelectorAll('.toc-item');

    window.addEventListener('scroll', () => {
        let current = '';
        sections.forEach(section => {
            const sectionTop = section.offsetTop;
            const sectionHeight = section.clientHeight;
            if (scrollY >= sectionTop - 100) {
                current = section.getAttribute('id');
            }
        });

        tocItems.forEach(item => {
            item.classList.remove('active');
            if (item.getAttribute('href') === `#${current}`) {
                item.classList.add('active');
            }
        });
    });

    // 快速导航
    const quickNavItems = document.querySelectorAll('.quick-nav-item');
    quickNavItems.forEach(item => {
        item.addEventListener('click', function() {
            const section = this.getAttribute('data-section');
            document.getElementById(section).scrollIntoView({ behavior: 'smooth' });
        });
    });

    // 分词演示
    function tokenizeDemo() {
        const input = document.getElementById('demo-input').value;
        const resultDiv = document.getElementById('demo-result');

        if (!input.trim()) {
            resultDiv.innerHTML = '<p class="text-muted">请输入文本...</p>';
            return;
        }

        // 模拟分词（实际应调用后端API）
        const tokens = simulateTokenize(input);

        let html = '<div class="mb-3"><strong>分词结果：</strong></div><div>';
        tokens.forEach(token => {
            html += `<span class="token token-word">${token}</span>`;
        });
        html += '</div>';

        html += `<div class="mt-3 text-muted">共 ${tokens.length} 个词</div>`;

        resultDiv.innerHTML = html;
    }

    function simulateTokenize(text) {
        // 简单的模拟分词
        const dict = ['我', '爱', '自然', '语言', '处理', '技术', '自然语言', '处理技术'];
        const tokens = [];
        let i = 0;

        while (i < text.length) {
            let matched = false;
            // 从长到短尝试匹配
            for (let len = Math.min(7, text.length - i); len > 0; len--) {
                const sub = text.substr(i, len);
                if (dict.includes(sub) || len === 1) {
                    tokens.push(sub);
                    i += len;
                    matched = true;
                    break;
                }
            }
            if (!matched) i++;
        }

        return tokens;
    }

    function clearDemo() {
        document.getElementById('demo-input').value = '';
        document.getElementById('demo-result').innerHTML = '<p class="text-muted">分词结果将显示在这里...</p>';
    }

    // 代码折叠
    function toggleCode(btn) {
        const codeContent = btn.parentElement.parentElement.nextElementSibling;
        if (codeContent.classList.contains('collapsed')) {
            codeContent.classList.remove('collapsed');
            btn.textContent = '折叠';
        } else {
            codeContent.classList.add('collapsed');
            btn.textContent = '展开';
        }
    }

    // 复制代码
    function copyCode(btn) {
        const codeContent = btn.parentElement.parentElement.nextElementSibling;
        const code = codeContent.querySelector('pre').textContent;

        navigator.clipboard.writeText(code).then(() => {
            const originalText = btn.textContent;
            btn.textContent = '已复制！';
            setTimeout(() => {
                btn.textContent = originalText;
            }, 2000);
        });
    }
</script>

</body>
</html>