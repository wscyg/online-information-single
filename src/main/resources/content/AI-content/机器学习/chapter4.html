<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>第4章：KNN算法 - 最近邻的智慧</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        /* CSS 变量定义主题颜色 */
        :root {
            /* 深色主题（默认） - 蓝紫色调 */
            --bg-primary: #0f0f23;
            --bg-secondary: #1a1a3e;
            --bg-card: rgba(26, 26, 62, 0.8);
            --bg-card-solid: rgba(26, 26, 62, 0.95);
            --bg-code: #16162d;
            --bg-demo: #0f0f23;

            --text-primary: #e2e8f0;
            --text-secondary: #cbd5e1;
            --text-muted: #94a3b8;
            --text-dim: #64748b;

            --border-primary: rgba(124, 58, 237, 0.3);
            --border-secondary: rgba(124, 58, 237, 0.2);
            --border-muted: rgba(148, 163, 184, 0.1);

            --grid-color: #2d2d5f;
            --grid-light: #3d3d6f;

            --shadow-sm: rgba(0,0,0,0.3);
            --shadow-md: rgba(0,0,0,0.4);
            --shadow-lg: rgba(0,0,0,0.5);

            --gradient-primary: linear-gradient(135deg, #667eea, #764ba2);
            --gradient-bg: linear-gradient(135deg, #0f0f23 0%, #1a1a3e 100%);

            /* KNN主题色 */
            --knn-purple: #7c3aed;
            --knn-blue: #667eea;
            --knn-pink: #ec4899;
            --knn-teal: #14b8a6;
            --knn-orange: #f97316;
            --knn-indigo: #6366f1;
        }

        /* 浅色主题 */
        body.light-theme {
            --bg-primary: #f8fafc;
            --bg-secondary: #e2e8f0;
            --bg-card: rgba(255, 255, 255, 0.9);
            --bg-card-solid: rgba(255, 255, 255, 0.95);
            --bg-code: #f3f4f6;
            --bg-demo: #ffffff;

            --text-primary: #1e293b;
            --text-secondary: #334155;
            --text-muted: #475569;
            --text-dim: #64748b;

            --border-primary: rgba(124, 58, 237, 0.4);
            --border-secondary: rgba(124, 58, 237, 0.3);
            --border-muted: rgba(203, 213, 225, 0.5);

            --grid-color: #e5e7eb;
            --grid-light: #d1d5db;

            --shadow-sm: rgba(0,0,0,0.1);
            --shadow-md: rgba(0,0,0,0.15);
            --shadow-lg: rgba(0,0,0,0.2);

            --gradient-primary: linear-gradient(135deg, #667eea, #764ba2);
            --gradient-bg: linear-gradient(135deg, #f8fafc 0%, #e2e8f0 100%);
        }

        /* 主题过渡动画 */
        body,
        body * {
            transition: background-color 0.3s ease,
            color 0.3s ease,
            border-color 0.3s ease,
            box-shadow 0.3s ease;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', 'PingFang SC', 'Microsoft YaHei', sans-serif;
            background: var(--gradient-bg);
            color: var(--text-primary);
            line-height: 1.8;
            min-height: 100vh;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
            padding: 20px;
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
        }

        /* 当导航展开时，内容区右移 */
        body.nav-open .container {
            margin-left: 360px;
        }

        /* 动态背景效果 - KNN节点连接风格 */
        .dynamic-bg {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            overflow: hidden;
            z-index: -1;
        }

        .knn-nodes-bg {
            position: absolute;
            width: 100%;
            height: 100%;
        }

        /* 智能导航样式 */
        .smart-nav {
            position: fixed;
            left: -340px;
            top: 0;
            width: 340px;
            height: 100vh;
            background: linear-gradient(135deg, rgba(15, 15, 35, 0.98) 0%, rgba(26, 26, 62, 0.95) 100%);
            backdrop-filter: blur(20px);
            border-right: 1px solid var(--border-primary);
            box-shadow: 4px 0 30px rgba(0, 0, 0, 0.5);
            z-index: 1000;
            transition: all 0.4s cubic-bezier(0.25, 0.46, 0.45, 0.94);
            overflow: hidden;
        }

        body.nav-open .smart-nav {
            left: 0;
        }

        /* 导航背景装饰 */
        .nav-bg-decoration {
            position: absolute;
            top: -100px;
            right: -100px;
            width: 300px;
            height: 300px;
            background: radial-gradient(circle, var(--knn-purple) 0%, transparent 70%);
            opacity: 0.1;
            animation: pulse 4s ease-in-out infinite;
        }

        /* 导航触发按钮 */
        .nav-trigger {
            position: fixed;
            left: 20px;
            top: 20px;
            width: 56px;
            height: 56px;
            background: linear-gradient(135deg, rgba(124, 58, 237, 0.1), rgba(102, 126, 234, 0.1));
            backdrop-filter: blur(10px);
            border: 2px solid rgba(124, 58, 237, 0.3);
            border-radius: 16px;
            cursor: pointer;
            z-index: 1001;
            transition: all 0.3s cubic-bezier(0.25, 0.46, 0.45, 0.94);
            display: flex;
            align-items: center;
            justify-content: center;
            overflow: hidden;
        }

        body.nav-open .nav-trigger {
            left: 290px;
            background: linear-gradient(135deg, rgba(236, 72, 153, 0.1), rgba(124, 58, 237, 0.1));
            border-color: rgba(236, 72, 153, 0.5);
        }

        .nav-trigger:hover {
            transform: scale(1.1);
            box-shadow: 0 8px 25px rgba(124, 58, 237, 0.4);
        }

        /* 汉堡菜单动画 */
        .nav-trigger-icon {
            width: 24px;
            height: 20px;
            position: relative;
            transform: rotate(0deg);
            transition: 0.5s ease-in-out;
        }

        .nav-trigger-icon span {
            display: block;
            position: absolute;
            height: 3px;
            width: 100%;
            background: linear-gradient(90deg, var(--knn-purple), var(--knn-blue));
            border-radius: 3px;
            opacity: 1;
            left: 0;
            transform: rotate(0deg);
            transition: 0.25s ease-in-out;
        }

        .nav-trigger-icon span:nth-child(1) {
            top: 0px;
        }

        .nav-trigger-icon span:nth-child(2) {
            top: 8px;
        }

        .nav-trigger-icon span:nth-child(3) {
            top: 16px;
        }

        body.nav-open .nav-trigger-icon span:nth-child(1) {
            top: 8px;
            transform: rotate(135deg);
        }

        body.nav-open .nav-trigger-icon span:nth-child(2) {
            opacity: 0;
            left: -60px;
        }

        body.nav-open .nav-trigger-icon span:nth-child(3) {
            top: 8px;
            transform: rotate(-135deg);
        }

        /* 导航头部 */
        .nav-header {
            padding: 30px;
            background: linear-gradient(135deg, rgba(124, 58, 237, 0.1), rgba(102, 126, 234, 0.05));
            border-bottom: 1px solid rgba(124, 58, 237, 0.2);
            position: relative;
        }

        .nav-header h3 {
            font-size: 1.4rem;
            background: linear-gradient(135deg, var(--knn-purple), var(--knn-blue));
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            display: flex;
            align-items: center;
            gap: 12px;
            font-weight: 700;
        }

        .nav-subtitle {
            font-size: 0.85rem;
            color: var(--text-muted);
            margin-top: 5px;
        }

        /* 章节进度环 */
        .chapter-progress {
            position: absolute;
            right: 30px;
            top: 50%;
            transform: translateY(-50%);
            width: 50px;
            height: 50px;
        }

        .progress-ring {
            transform: rotate(-90deg);
        }

        .progress-ring-bg {
            fill: none;
            stroke: rgba(124, 58, 237, 0.1);
            stroke-width: 4;
        }

        .progress-ring-fill {
            fill: none;
            stroke: url(#progressGradient);
            stroke-width: 4;
            stroke-dasharray: 138.23;
            stroke-dashoffset: 138.23;
            transition: stroke-dashoffset 1s ease;
        }

        .progress-text {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 0.9rem;
            font-weight: bold;
            color: var(--knn-purple);
        }

        /* 导航列表 */
        .nav-list {
            list-style: none;
            padding: 20px 0;
            max-height: calc(100vh - 300px);
            overflow-y: auto;
            overflow-x: hidden;
        }

        .nav-list::-webkit-scrollbar {
            width: 6px;
        }

        .nav-list::-webkit-scrollbar-track {
            background: rgba(124, 58, 237, 0.05);
            border-radius: 3px;
        }

        .nav-list::-webkit-scrollbar-thumb {
            background: linear-gradient(135deg, var(--knn-purple), var(--knn-blue));
            border-radius: 3px;
        }

        /* 导航项 */
        .nav-item {
            position: relative;
            margin: 8px 15px;
            border-radius: 12px;
            overflow: hidden;
            transition: all 0.3s ease;
        }

        .nav-item::before {
            content: '';
            position: absolute;
            left: 0;
            top: 0;
            bottom: 0;
            width: 0;
            background: linear-gradient(90deg, var(--knn-purple), var(--knn-blue));
            transition: width 0.3s ease;
            opacity: 0.8;
        }

        .nav-item:hover::before {
            width: 4px;
        }

        .nav-item.active::before {
            width: 4px;
            opacity: 1;
            box-shadow: 0 0 12px var(--knn-purple);
        }

        .nav-item a {
            display: flex;
            align-items: center;
            padding: 14px 20px;
            color: var(--text-muted);
            text-decoration: none;
            transition: all 0.3s ease;
            position: relative;
            background: rgba(0, 0, 0, 0);
        }

        .nav-item:hover a {
            color: var(--text-primary);
            background: rgba(124, 58, 237, 0.05);
            padding-left: 28px;
        }

        .nav-item.active a {
            color: var(--text-primary);
            background: linear-gradient(90deg, rgba(124, 58, 237, 0.1), rgba(102, 126, 234, 0.05));
            padding-left: 28px;
            font-weight: 600;
        }

        /* 导航图标动画 */
        .nav-icon {
            font-size: 1.4rem;
            margin-right: 14px;
            flex-shrink: 0;
            transition: all 0.3s ease;
            display: flex;
            align-items: center;
            justify-content: center;
            width: 32px;
            height: 32px;
            background: rgba(124, 58, 237, 0.1);
            border-radius: 8px;
        }

        .nav-item:hover .nav-icon {
            transform: scale(1.1) rotate(10deg);
            background: rgba(124, 58, 237, 0.2);
        }

        .nav-item.active .nav-icon {
            background: linear-gradient(135deg, rgba(124, 58, 237, 0.3), rgba(102, 126, 234, 0.2));
            animation: iconPulse 2s ease-in-out infinite;
        }

        @keyframes iconPulse {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.1); }
        }

        /* 导航文本和时间 */
        .nav-content {
            flex: 1;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .nav-text {
            font-size: 0.95rem;
            font-weight: 500;
        }

        .nav-meta {
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .nav-time {
            font-size: 0.75rem;
            color: var(--text-dim);
            background: rgba(124, 58, 237, 0.1);
            padding: 2px 8px;
            border-radius: 12px;
        }

        .nav-status {
            width: 8px;
            height: 8px;
            border-radius: 50%;
            background: #4a5568;
            transition: all 0.3s ease;
        }

        .nav-item.completed .nav-status {
            background: #10b981;
            box-shadow: 0 0 8px #10b981;
        }

        .nav-item.active .nav-status {
            background: var(--knn-purple);
            box-shadow: 0 0 8px var(--knn-purple);
            animation: statusPulse 2s ease-in-out infinite;
        }

        @keyframes statusPulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.5; }
        }

        /* 导航底部统计 */
        .nav-footer {
            position: absolute;
            bottom: 0;
            left: 0;
            right: 0;
            padding: 25px;
            background: linear-gradient(to top, rgba(15, 15, 35, 0.98), transparent);
            border-top: 1px solid rgba(124, 58, 237, 0.2);
        }

        .learning-stats {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 15px;
            margin-bottom: 20px;
        }

        .stat-card {
            background: rgba(124, 58, 237, 0.05);
            padding: 12px;
            border-radius: 10px;
            border: 1px solid rgba(124, 58, 237, 0.2);
            text-align: center;
        }

        .stat-value {
            font-size: 1.2rem;
            font-weight: bold;
            color: var(--knn-purple);
        }

        .stat-label {
            font-size: 0.75rem;
            color: var(--text-muted);
            margin-top: 2px;
        }

        /* 主标题样式 */
        .main-header {
            text-align: center;
            margin: 60px 0;
            position: relative;
        }

        .main-title {
            font-size: 4rem;
            font-weight: 900;
            background: linear-gradient(135deg, var(--knn-purple) 0%, var(--knn-blue) 50%, var(--knn-pink) 100%);
            background-size: 200% 200%;
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            animation: gradient-flow 6s ease infinite;
            text-shadow: 0 0 80px rgba(124, 58, 237, 0.5);
            margin-bottom: 20px;
        }

        @keyframes gradient-flow {
            0% { background-position: 0% 50%; }
            50% { background-position: 100% 50%; }
            100% { background-position: 0% 50%; }
        }

        .subtitle {
            font-size: 1.6rem;
            color: #94a3b8;
            text-shadow: 0 2px 10px rgba(0,0,0,0.5);
        }

        /* 章节卡片样式 */
        .section-card {
            background: var(--bg-card);
            backdrop-filter: blur(10px);
            border-radius: 24px;
            padding: 40px;
            margin: 30px 0;
            border: 1px solid var(--border-secondary);
            box-shadow: 0 20px 40px var(--shadow-sm);
            transition: all 0.3s ease;
            position: relative;
            overflow: hidden;
        }

        .section-card::before {
            content: '';
            position: absolute;
            top: -2px;
            left: -2px;
            right: -2px;
            bottom: -2px;
            background: linear-gradient(45deg, var(--knn-purple), var(--knn-blue), var(--knn-pink));
            border-radius: 24px;
            opacity: 0;
            z-index: -1;
            transition: opacity 0.3s ease;
        }

        .section-card:hover::before {
            opacity: 0.5;
            animation: borderRotate 4s linear infinite;
        }

        @keyframes borderRotate {
            from { transform: rotate(0deg); }
            to { transform: rotate(360deg); }
        }

        .section-card:hover {
            transform: translateY(-5px);
            box-shadow: 0 30px 60px var(--shadow-md);
        }

        .section-title {
            font-size: 2.5rem;
            background: linear-gradient(135deg, var(--knn-purple), var(--knn-blue));
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            margin-bottom: 30px;
            display: flex;
            align-items: center;
            gap: 15px;
        }

        /* 思考题框样式 */
        .thinking-box {
            background: linear-gradient(135deg, rgba(124, 58, 237, 0.1), rgba(102, 126, 234, 0.05));
            border-radius: 20px;
            padding: 30px;
            margin: 30px 0;
            border: 2px solid rgba(124, 58, 237, 0.3);
            position: relative;
        }

        .thinking-box::before {
            content: '🤔';
            position: absolute;
            top: -15px;
            left: 20px;
            font-size: 2rem;
            background: var(--bg-card-solid);
            padding: 5px 15px;
            border-radius: 50%;
            opacity: 0.8;
            z-index: 1;
        }

        /* 历史故事框 */
        .history-box {
            background: linear-gradient(135deg, rgba(249, 115, 22, 0.1), rgba(251, 146, 60, 0.05));
            border-radius: 20px;
            padding: 30px;
            margin: 30px 0;
            border: 2px solid rgba(249, 115, 22, 0.3);
            position: relative;
        }

        .history-box::before {
            content: '📜';
            position: absolute;
            top: -15px;
            left: 20px;
            font-size: 2rem;
            background: var(--bg-card-solid);
            padding: 5px 15px;
            border-radius: 50%;
            opacity: 0.8;
            z-index: 1;
        }

        /* 公式容器样式 */
        .formula-box {
            background: linear-gradient(135deg, rgba(99, 102, 241, 0.1), rgba(124, 58, 237, 0.05));
            border-radius: 20px;
            padding: 35px;
            margin: 30px 0;
            text-align: center;
            border: 2px solid rgba(99, 102, 241, 0.3);
            position: relative;
            overflow: hidden;
        }

        .formula-box::before {
            content: '∑';
            position: absolute;
            top: -30px;
            right: 30px;
            font-size: 6rem;
            opacity: 0.03;
            transform: rotate(15deg);
            z-index: 0;
        }

        /* 改进的数学公式样式 */
        .math-formula {
            font-family: 'Times New Roman', 'Cambria Math', serif;
            font-size: 1.8rem;
            color: var(--text-primary);
            margin: 20px 0;
            display: flex;
            align-items: center;
            justify-content: center;
            flex-wrap: wrap;
            gap: 10px;
            position: relative;
            z-index: 1;
        }

        /* 数学符号样式 */
        .math-formula sub, .math-formula sup {
            font-size: 0.7em;
            line-height: 0;
        }

        .math-formula .fraction {
            display: inline-flex;
            flex-direction: column;
            align-items: center;
            vertical-align: middle;
            margin: 0 5px;
        }

        .math-formula .numerator {
            border-bottom: 2px solid currentColor;
            padding-bottom: 2px;
        }

        .math-formula .denominator {
            padding-top: 2px;
        }

        .math-formula .sqrt {
            position: relative;
            padding-left: 20px;
        }

        .math-formula .sqrt::before {
            content: '√';
            position: absolute;
            left: 0;
            top: -5px;
            font-size: 1.2em;
        }

        .math-formula .sqrt-content {
            border-top: 2px solid currentColor;
            padding-top: 2px;
        }

        .formula-explanation {
            font-size: 1rem;
            color: var(--text-secondary);
            margin-top: 20px;
            text-align: left;
            line-height: 2;
        }

        /* 高亮样式 */
        .highlight-primary {
            color: var(--knn-purple);
            font-weight: bold;
            background: rgba(124, 58, 237, 0.1);
            padding: 2px 8px;
            border-radius: 6px;
            border: 1px solid rgba(124, 58, 237, 0.3);
        }

        .highlight-success {
            color: var(--knn-teal);
            font-weight: bold;
            background: rgba(20, 184, 166, 0.1);
            padding: 2px 8px;
            border-radius: 6px;
            border: 1px solid rgba(20, 184, 166, 0.3);
        }

        .highlight-warning {
            color: var(--knn-orange);
            font-weight: bold;
            background: rgba(249, 115, 22, 0.1);
            padding: 2px 8px;
            border-radius: 6px;
            border: 1px solid rgba(249, 115, 22, 0.3);
        }

        .highlight-danger {
            color: var(--knn-pink);
            font-weight: bold;
            background: rgba(236, 72, 153, 0.1);
            padding: 2px 8px;
            border-radius: 6px;
            border: 1px solid rgba(236, 72, 153, 0.3);
        }

        /* 概念定义框 */
        .definition-box {
            background: linear-gradient(135deg, rgba(102, 126, 234, 0.1), rgba(124, 58, 237, 0.05));
            border-radius: 20px;
            padding: 30px;
            margin: 30px 0;
            border: 2px solid rgba(102, 126, 234, 0.3);
            position: relative;
        }

        .definition-box::before {
            content: '📖';
            position: absolute;
            top: -15px;
            left: 20px;
            font-size: 2rem;
            background: var(--bg-card-solid);
            padding: 5px 15px;
            border-radius: 50%;
            opacity: 0.8;
            z-index: 1;
        }

        /* 核心洞察框 */
        .insight-box {
            background: linear-gradient(135deg, rgba(236, 72, 153, 0.1), rgba(244, 114, 182, 0.05));
            border-radius: 20px;
            padding: 30px;
            margin: 30px 0;
            border: 2px solid rgba(236, 72, 153, 0.3);
            position: relative;
        }

        .insight-box::before {
            content: '💡';
            position: absolute;
            top: -15px;
            left: 20px;
            font-size: 2rem;
            background: var(--bg-card-solid);
            padding: 5px 15px;
            border-radius: 50%;
            opacity: 0.8;
            z-index: 1;
        }

        /* 警告框 */
        .warning-box {
            background: linear-gradient(135deg, rgba(239, 68, 68, 0.1), rgba(220, 38, 38, 0.05));
            border-radius: 20px;
            padding: 30px;
            margin: 30px 0;
            border: 2px solid rgba(239, 68, 68, 0.3);
            position: relative;
        }

        .warning-box::before {
            content: '⚠️';
            position: absolute;
            top: -15px;
            left: 20px;
            font-size: 2rem;
            background: var(--bg-card-solid);
            padding: 5px 15px;
            border-radius: 50%;
            opacity: 0.8;
            z-index: 1;
        }

        /* 交互式演示区域 */
        .demo-container {
            background: linear-gradient(135deg, rgba(15, 15, 35, 0.9), rgba(26, 26, 62, 0.8));
            border-radius: 20px;
            padding: 30px;
            margin: 30px 0;
            border: 2px solid rgba(124, 58, 237, 0.3);
            box-shadow: 0 20px 40px rgba(0, 0, 0, 0.4);
        }

        .demo-canvas {
            background: #0f0f23;
            border-radius: 10px;
            margin: 20px auto;
            display: block;
            box-shadow: 0 10px 30px rgba(0,0,0,0.5);
            cursor: crosshair;
        }

        .demo-controls {
            display: flex;
            justify-content: center;
            gap: 15px;
            flex-wrap: wrap;
            margin: 20px 0;
        }

        .demo-btn {
            background: linear-gradient(135deg, var(--knn-purple), var(--knn-blue));
            color: white;
            border: none;
            padding: 12px 24px;
            border-radius: 25px;
            cursor: pointer;
            font-weight: 600;
            transition: all 0.3s ease;
            box-shadow: 0 5px 15px rgba(124, 58, 237, 0.3);
        }

        .demo-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 8px 25px rgba(124, 58, 237, 0.4);
        }

        .demo-btn:active {
            transform: translateY(0);
        }

        /* 代码区域样式 */
        .code-block {
            background: #1a1a2e;
            border-radius: 15px;
            padding: 25px;
            margin: 25px 0;
            overflow-x: auto;
            position: relative;
            box-shadow: 0 10px 30px rgba(0,0,0,0.5);
            border: 1px solid rgba(124, 58, 237, 0.2);
        }

        .code-block::before {
            content: 'Python';
            position: absolute;
            top: -12px;
            left: 20px;
            background: linear-gradient(135deg, var(--knn-purple), var(--knn-blue));
            color: white;
            padding: 5px 15px;
            border-radius: 15px;
            font-size: 0.9rem;
            font-weight: 600;
        }

        .code-block pre {
            color: #f8f8f2;
            font-family: 'Fira Code', 'Consolas', monospace;
            line-height: 1.6;
            margin: 0;
        }

        /* 语法高亮 */
        .keyword { color: #ff79c6; }
        .string { color: #f1fa8c; }
        .comment { color: #6272a4; }
        .number { color: #bd93f9; }
        .function { color: #50fa7b; }

        /* 进度指示器 */
        .progress-indicator {
            position: fixed;
            top: 20px;
            right: 20px;
            background: linear-gradient(135deg, rgba(124, 58, 237, 0.1), rgba(102, 126, 234, 0.1));
            padding: 15px 25px;
            border-radius: 50px;
            border: 2px solid rgba(124, 58, 237, 0.3);
            display: flex;
            align-items: center;
            gap: 10px;
            backdrop-filter: blur(10px);
            z-index: 1000;
            transition: all 0.3s ease;
            box-shadow: 0 4px 12px var(--shadow-sm);
        }

        .progress-bar {
            width: 150px;
            height: 6px;
            background: rgba(124, 58, 237, 0.2);
            border-radius: 3px;
            overflow: hidden;
        }

        .progress-fill {
            height: 100%;
            background: linear-gradient(90deg, var(--knn-purple), var(--knn-blue));
            border-radius: 3px;
            transition: width 0.3s ease;
        }

        /* 浮动工具栏 */
        .floating-toolbar {
            position: fixed;
            bottom: 30px;
            right: 30px;
            display: flex;
            flex-direction: column;
            gap: 10px;
            z-index: 1000;
        }

        .toolbar-btn {
            width: 50px;
            height: 50px;
            border-radius: 50%;
            background: linear-gradient(135deg, var(--knn-purple), var(--knn-blue));
            color: white;
            border: none;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 1.5rem;
            transition: all 0.3s ease;
            box-shadow: 0 5px 15px rgba(124, 58, 237, 0.3);
        }

        .toolbar-btn:hover {
            transform: scale(1.1);
            box-shadow: 0 8px 25px rgba(124, 58, 237, 0.4);
        }

        /* 思维导图样式 */
        .mind-map {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(280px, 1fr));
            gap: 20px;
            margin: 30px 0;
        }

        .mind-node {
            background: linear-gradient(135deg, rgba(124, 58, 237, 0.1), rgba(102, 126, 234, 0.05));
            color: var(--text-primary);
            padding: 25px;
            border-radius: 15px;
            text-align: center;
            box-shadow: 0 10px 25px rgba(124, 58, 237, 0.2);
            transition: all 0.3s ease;
            cursor: pointer;
            position: relative;
            overflow: hidden;
            border: 2px solid rgba(124, 58, 237, 0.3);
        }

        .mind-node::before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(255,255,255,0.2), transparent);
            transition: left 0.5s;
        }

        .mind-node:hover::before {
            left: 100%;
        }

        .mind-node:hover {
            transform: translateY(-8px) scale(1.02);
            box-shadow: 0 20px 40px rgba(124, 58, 237, 0.3);
        }

        /* 步骤指示器 */
        .steps-container {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 20px;
            margin: 30px 0;
        }

        .step {
            background: var(--bg-card);
            padding: 25px;
            border-radius: 15px;
            text-align: center;
            position: relative;
            box-shadow: 0 10px 25px rgba(0,0,0,0.1);
            transition: transform 0.3s ease;
            border: 2px solid transparent;
        }

        .step:hover {
            transform: translateY(-5px);
            border-color: var(--knn-purple);
        }

        .step-number {
            position: absolute;
            top: -20px;
            left: 50%;
            transform: translateX(-50%);
            width: 50px;
            height: 50px;
            background: linear-gradient(135deg, var(--knn-purple), var(--knn-blue));
            color: white;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: bold;
            font-size: 1.3rem;
            box-shadow: 0 5px 15px rgba(124, 58, 237, 0.3);
        }

        /* 数据表格样式 */
        .data-table {
            width: 100%;
            border-collapse: collapse;
            margin: 20px 0;
            background: var(--bg-card);
            border-radius: 10px;
            overflow: hidden;
            box-shadow: 0 10px 25px rgba(0,0,0,0.1);
        }

        .data-table th {
            background: linear-gradient(135deg, var(--knn-purple), var(--knn-blue));
            color: white;
            padding: 12px 20px;
            font-weight: 600;
            text-align: center;
        }

        .data-table td {
            padding: 10px 20px;
            text-align: center;
            border-bottom: 1px solid var(--border-muted);
            color: var(--text-primary);
            font-weight: 500;
        }

        .data-table tr:hover td {
            background: rgba(124, 58, 237, 0.05);
        }

        .data-table tr:last-child td {
            border-bottom: none;
        }

        /* 特征权重可视化 */
        .feature-weights {
            display: grid;
            gap: 15px;
            margin: 20px 0;
        }

        .weight-bar {
            display: flex;
            align-items: center;
            gap: 15px;
        }

        .weight-label {
            min-width: 120px;
            font-weight: 600;
            color: var(--text-secondary);
        }

        .weight-progress {
            flex: 1;
            height: 20px;
            background: rgba(124, 58, 237, 0.1);
            border-radius: 10px;
            overflow: hidden;
            position: relative;
        }

        .weight-fill {
            height: 100%;
            background: linear-gradient(90deg, var(--knn-purple), var(--knn-pink));
            border-radius: 10px;
            transition: width 0.6s ease;
            box-shadow: 0 0 10px rgba(124, 58, 237, 0.3);
        }

        .weight-value {
            min-width: 60px;
            text-align: right;
            font-weight: bold;
            color: var(--knn-purple);
        }

        /* 模型状态指示器 */
        .model-status {
            display: flex;
            justify-content: center;
            gap: 30px;
            margin: 20px 0;
        }

        .status-item {
            text-align: center;
        }

        .status-label {
            font-size: 0.9rem;
            color: var(--text-muted);
            margin-bottom: 5px;
        }

        .status-value {
            font-size: 1.5rem;
            font-weight: bold;
            color: var(--knn-purple);
        }

        /* 参数控制面板 */
        .param-panel {
            background: rgba(124, 58, 237, 0.05);
            border: 1px solid rgba(124, 58, 237, 0.3);
            border-radius: 15px;
            padding: 20px;
            margin: 20px 0;
        }

        .param-slider {
            width: 100%;
            margin: 10px 0;
        }

        .param-value {
            display: inline-block;
            width: 60px;
            text-align: center;
            color: var(--knn-purple);
            font-weight: bold;
        }

        /* 响应式设计 */
        @media (max-width: 1400px) {
            body.nav-open .container {
                margin-left: 0;
                padding-left: 360px;
            }
        }

        @media (max-width: 768px) {
            .main-title {
                font-size: 2.5rem;
            }

            .section-title {
                font-size: 1.8rem;
            }

            .section-card {
                padding: 25px;
            }

            .demo-controls {
                flex-direction: column;
            }

            .smart-nav {
                width: 100%;
                left: -100%;
            }

            body.nav-open .smart-nav {
                left: 0;
            }

            body.nav-open .container {
                margin-left: 0;
                padding-left: 20px;
            }

            body.nav-open .nav-trigger {
                left: auto;
                right: 20px;
            }

            .mind-map {
                grid-template-columns: 1fr;
            }

            .steps-container {
                grid-template-columns: 1fr;
            }
        }

        /* 动画效果 */
        .fade-in {
            opacity: 0;
            transform: translateY(30px);
            animation: fadeInUp 0.6s ease forwards;
        }

        @keyframes fadeInUp {
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        /* 脉冲动画 */
        @keyframes pulse {
            0% { transform: scale(1); }
            50% { transform: scale(1.05); }
            100% { transform: scale(1); }
        }

        .pulse {
            animation: pulse 2s ease-in-out infinite;
        }

        /* 章节锚点偏移 */
        .section-anchor {
            scroll-margin-top: 100px;
        }

        /* 分类结果动画 */
        @keyframes classifyPulse {
            0% { box-shadow: 0 0 0 0 rgba(124, 58, 237, 0.7); }
            70% { box-shadow: 0 0 0 10px rgba(124, 58, 237, 0); }
            100% { box-shadow: 0 0 0 0 rgba(124, 58, 237, 0); }
        }

        .classify-pulse {
            animation: classifyPulse 1.5s infinite;
        }

        /* 边界决策可视化 */
        .decision-boundary {
            position: relative;
            background: rgba(124, 58, 237, 0.05);
            border-radius: 15px;
            padding: 20px;
            margin: 20px 0;
        }

        /* 高级算法变体 */
        .algorithm-variant {
            background: linear-gradient(135deg, rgba(99, 102, 241, 0.1), rgba(124, 58, 237, 0.05));
            border-radius: 15px;
            padding: 25px;
            margin: 20px 0;
            border: 2px solid rgba(99, 102, 241, 0.3);
            transition: all 0.3s ease;
        }

        .algorithm-variant:hover {
            transform: translateY(-3px);
            box-shadow: 0 15px 30px rgba(99, 102, 241, 0.2);
        }

        /* 优化技巧卡片 */
        .optimization-card {
            background: var(--bg-card);
            border-radius: 15px;
            padding: 20px;
            margin: 15px 0;
            border-left: 4px solid var(--knn-purple);
            transition: all 0.3s ease;
        }

        .optimization-card:hover {
            transform: translateX(10px);
            box-shadow: 0 5px 20px rgba(124, 58, 237, 0.2);
        }

        /* 复杂度分析表 */
        .complexity-table {
            background: var(--bg-card);
            border-radius: 15px;
            overflow: hidden;
            margin: 20px 0;
            box-shadow: 0 10px 25px rgba(0,0,0,0.1);
        }

        .complexity-table th {
            background: linear-gradient(135deg, var(--knn-indigo), var(--knn-purple));
            color: white;
            padding: 15px;
            text-align: left;
        }

        .complexity-table td {
            padding: 12px 15px;
            border-bottom: 1px solid var(--border-muted);
            color: var(--text-primary);
        }

        .complexity-table tr:last-child td {
            border-bottom: none;
        }

        /* 实验结果图表 */
        .experiment-chart {
            background: var(--bg-card);
            border-radius: 15px;
            padding: 25px;
            margin: 20px 0;
            text-align: center;
            box-shadow: 0 10px 25px rgba(0,0,0,0.1);
        }

        .chart-title {
            font-size: 1.2rem;
            font-weight: 600;
            color: var(--text-primary);
            margin-bottom: 20px;
        }

        /* 对比分析网格 */
        .comparison-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 20px;
            margin: 30px 0;
        }

        .comparison-item {
            background: linear-gradient(135deg, rgba(124, 58, 237, 0.05), rgba(102, 126, 234, 0.02));
            border-radius: 15px;
            padding: 25px;
            border: 2px solid rgba(124, 58, 237, 0.2);
            transition: all 0.3s ease;
        }

        .comparison-item:hover {
            transform: translateY(-5px);
            box-shadow: 0 15px 30px rgba(124, 58, 237, 0.2);
        }

        .comparison-header {
            display: flex;
            align-items: center;
            gap: 10px;
            margin-bottom: 15px;
        }

        .comparison-icon {
            width: 40px;
            height: 40px;
            background: linear-gradient(135deg, var(--knn-purple), var(--knn-blue));
            border-radius: 10px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 1.5rem;
        }

        .comparison-title {
            font-size: 1.1rem;
            font-weight: 600;
            color: var(--text-primary);
        }

        /* 实战案例容器 */
        .case-study {
            background: linear-gradient(135deg, rgba(236, 72, 153, 0.05), rgba(124, 58, 237, 0.05));
            border-radius: 20px;
            padding: 30px;
            margin: 30px 0;
            border: 2px solid rgba(236, 72, 153, 0.3);
            position: relative;
        }

        .case-study::before {
            content: '🎯';
            position: absolute;
            top: -15px;
            right: 20px;
            font-size: 2rem;
            background: var(--bg-card-solid);
            padding: 5px 15px;
            border-radius: 50%;
            opacity: 0.8;
        }

        /* 练习题样式 */
        .exercise-box {
            background: linear-gradient(135deg, rgba(20, 184, 166, 0.1), rgba(6, 182, 212, 0.05));
            border-radius: 20px;
            padding: 30px;
            margin: 30px 0;
            border: 2px solid rgba(20, 184, 166, 0.3);
            position: relative;
        }

        .exercise-box::before {
            content: '✍️';
            position: absolute;
            top: -15px;
            left: 20px;
            font-size: 2rem;
            background: var(--bg-card-solid);
            padding: 5px 15px;
            border-radius: 50%;
            opacity: 0.8;
        }

        /* 深度思考题 */
        .deep-thinking {
            background: linear-gradient(135deg, rgba(168, 85, 247, 0.1), rgba(124, 58, 237, 0.05));
            border-radius: 20px;
            padding: 30px;
            margin: 30px 0;
            border: 2px solid rgba(168, 85, 247, 0.3);
            position: relative;
        }

        .deep-thinking::before {
            content: '🧠';
            position: absolute;
            top: -15px;
            left: 20px;
            font-size: 2rem;
            background: var(--bg-card-solid);
            padding: 5px 15px;
            border-radius: 50%;
            opacity: 0.8;
        }

        /* 总结卡片 */
        .summary-card {
            background: linear-gradient(135deg, var(--knn-purple), var(--knn-blue));
            color: white;
            padding: 40px;
            border-radius: 20px;
            margin: 30px 0;
            text-align: center;
            box-shadow: 0 20px 40px rgba(124, 58, 237, 0.3);
            position: relative;
            overflow: hidden;
        }

        .summary-card::before {
            content: '';
            position: absolute;
            top: -50%;
            right: -50%;
            width: 200%;
            height: 200%;
            background: radial-gradient(circle, rgba(255,255,255,0.1) 0%, transparent 70%);
            animation: rotate 20s linear infinite;
        }

        @keyframes rotate {
            from { transform: rotate(0deg); }
            to { transform: rotate(360deg); }
        }

        .summary-content {
            position: relative;
            z-index: 1;
        }

        /* 贡献者卡片 */
        .contributors {
            display: flex;
            justify-content: center;
            gap: 20px;
            flex-wrap: wrap;
            margin: 30px 0;
        }

        .contributor-card {
            background: var(--bg-card);
            padding: 20px;
            border-radius: 15px;
            text-align: center;
            box-shadow: 0 10px 25px rgba(0,0,0,0.1);
            transition: all 0.3s ease;
            border: 2px solid transparent;
        }

        .contributor-card:hover {
            transform: translateY(-5px);
            border-color: var(--knn-purple);
        }

        .contributor-avatar {
            width: 80px;
            height: 80px;
            border-radius: 50%;
            background: linear-gradient(135deg, var(--knn-purple), var(--knn-blue));
            margin: 0 auto 15px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 2rem;
        }

        /* 版本信息 */
        .version-info {
            text-align: center;
            padding: 20px;
            color: var(--text-muted);
            font-size: 0.9rem;
        }

        /* 高级功能提示 */
        .pro-tip {
            background: linear-gradient(135deg, rgba(251, 191, 36, 0.1), rgba(245, 158, 11, 0.05));
            border-radius: 15px;
            padding: 20px;
            margin: 20px 0;
            border-left: 4px solid #fbbf24;
            position: relative;
        }

        .pro-tip::before {
            content: '💡 Pro Tip';
            position: absolute;
            top: -12px;
            left: 20px;
            background: var(--bg-card-solid);
            padding: 0 10px;
            color: #fbbf24;
            font-weight: 600;
            font-size: 0.9rem;
        }
    </style>
</head>
<body>
<!-- 动态背景 -->
<div class="dynamic-bg">
    <canvas id="knnNodesBg" class="knn-nodes-bg"></canvas>
</div>

<!-- 导航触发按钮 -->
<button class="nav-trigger" onclick="toggleNav()">
    <div class="nav-trigger-icon">
        <span></span>
        <span></span>
        <span></span>
    </div>
</button>

<!-- 智能导航系统 -->
<nav class="smart-nav">
    <div class="nav-bg-decoration"></div>

    <div class="nav-header">
        <h3>🤖 KNN算法学习指南</h3>
        <p class="nav-subtitle">最近邻的智慧，最直观的算法</p>

        <div class="chapter-progress">
            <svg width="50" height="50">
                <defs>
                    <linearGradient id="progressGradient" x1="0%" y1="0%" x2="100%" y2="100%">
                        <stop offset="0%" style="stop-color:#7c3aed;stop-opacity:1" />
                        <stop offset="100%" style="stop-color:#667eea;stop-opacity:1" />
                    </linearGradient>
                </defs>
                <circle cx="25" cy="25" r="22" class="progress-ring progress-ring-bg"></circle>
                <circle cx="25" cy="25" r="22" class="progress-ring progress-ring-fill" id="progressRing"></circle>
            </svg>
            <div class="progress-text" id="progressPercent">0%</div>
        </div>
    </div>

    <ul class="nav-list">
        <li class="nav-item active" data-section="intro">
            <a href="#intro">
                <span class="nav-icon">🎯</span>
                <div class="nav-content">
                    <span class="nav-text">引言：一个简单的问题</span>
                    <div class="nav-meta">
                        <span class="nav-time">5 min</span>
                        <span class="nav-status"></span>
                    </div>
                </div>
            </a>
        </li>
        <li class="nav-item" data-section="what-is-knn">
            <a href="#what-is-knn">
                <span class="nav-icon">📖</span>
                <div class="nav-content">
                    <span class="nav-text">4.1 什么是KNN算法</span>
                    <div class="nav-meta">
                        <span class="nav-time">8 min</span>
                        <span class="nav-status"></span>
                    </div>
                </div>
            </a>
        </li>
        <li class="nav-item" data-section="math-foundation">
            <a href="#math-foundation">
                <span class="nav-icon">🧮</span>
                <div class="nav-content">
                    <span class="nav-text">4.2 数学基础</span>
                    <div class="nav-meta">
                        <span class="nav-time">12 min</span>
                        <span class="nav-status"></span>
                    </div>
                </div>
            </a>
        </li>
        <li class="nav-item" data-section="distance-metrics">
            <a href="#distance-metrics">
                <span class="nav-icon">📏</span>
                <div class="nav-content">
                    <span class="nav-text">4.3 距离度量方法</span>
                    <div class="nav-meta">
                        <span class="nav-time">15 min</span>
                        <span class="nav-status"></span>
                    </div>
                </div>
            </a>
        </li>
        <li class="nav-item" data-section="algorithm-steps">
            <a href="#algorithm-steps">
                <span class="nav-icon">⚙️</span>
                <div class="nav-content">
                    <span class="nav-text">4.4 算法详细步骤</span>
                    <div class="nav-meta">
                        <span class="nav-time">10 min</span>
                        <span class="nav-status"></span>
                    </div>
                </div>
            </a>
        </li>
    </ul>

    <div class="nav-footer">
        <div class="learning-stats">
            <div class="stat-card">
                <div class="stat-value" id="totalTime">50</div>
                <div class="stat-label">总时长(分钟)</div>
            </div>
            <div class="stat-card">
                <div class="stat-value" id="completedSections">0/5</div>
                <div class="stat-label">完成章节</div>
            </div>
        </div>

        <div style="text-align: center; margin-top: 15px;">
            <kbd style="background: rgba(124, 58, 237, 0.1); padding: 4px 8px; border-radius: 4px;">Alt</kbd> +
            <kbd style="background: rgba(124, 58, 237, 0.1); padding: 4px 8px; border-radius: 4px;">N</kbd>
            <span style="color: var(--text-muted); font-size: 0.8rem;">切换导航</span>
        </div>
    </div>
</nav>

<!-- 进度指示器 -->
<div class="progress-indicator">
    <span>学习进度</span>
    <div class="progress-bar">
        <div class="progress-fill" id="progressFill" style="width: 0%"></div>
    </div>
    <span id="progressText">0%</span>
</div>

<!-- 主容器 -->
<div class="container">
    <!-- 标题部分 -->
    <div class="main-header fade-in">
        <h1 class="main-title">第4章：KNN算法</h1>
        <p class="subtitle">🤖 最近邻的智慧，最直观的机器学习算法</p>
    </div>

    <!-- 引言：一个简单的问题 -->
    <div id="intro" class="section-card fade-in section-anchor">
        <h2 class="section-title">🎯 引言：一个简单的问题</h2>

        <div class="thinking-box">
            <h3>🤔 思考时刻</h3>
            <p>假设你是一个房地产中介，客户问你："这套房子值多少钱？"</p>
            <p>你会如何回答？你的判断依据是什么？</p>
            <br>
            <p><strong>大多数人的直觉做法：</strong></p>
            <ul style="margin-left: 20px; line-height: 2;">
                <li>🏠 看看<span class="highlight-primary">周围类似房子</span>的价格</li>
                <li>📏 比较<span class="highlight-success">面积、地段、户型</span>等特征</li>
                <li>🔍 找到<span class="highlight-warning">最相似的几套</span>房子</li>
                <li>💰 参考它们的价格来<span class="highlight-danger">估算目标房价</span></li>
            </ul>
            <br>
            <p><strong>恭喜你！你刚刚描述了机器学习中一个重要算法的核心思想！</strong></p>
        </div>

        <div class="insight-box">
            <h4>💡 核心洞察</h4>
            <p>人类在处理未知问题时，总是习惯性地寻找<span class="highlight-primary">相似的经验</span>作为参考。这种朴素而有效的思维方式，正是<span class="highlight-success">K近邻算法（KNN）</span>的理论基础。</p>
            <p>KNN可能是<span class="highlight-warning">最接近人类直觉</span>的机器学习算法。它不需要复杂的数学推导，不需要假设数据分布，只需要一个简单的信念：<span class="highlight-danger">"相似的事物应该有相似的标签"</span>。</p>
        </div>
    </div>

    <!-- 4.1 什么是KNN算法 -->
    <div id="what-is-knn" class="section-card fade-in section-anchor">
        <h2 class="section-title">📖 4.1 什么是KNN算法</h2>

        <div class="definition-box">
            <h4>📖 正式定义</h4>
            <p><span class="highlight-primary">K近邻算法（K-Nearest Neighbors，简称KNN）</span>是一种基于<span class="highlight-success">实例的懒惰学习算法</span>，属于<span class="highlight-warning">监督学习</span>方法。</p>
            <br>
            <p><strong>算法原理：</strong>给定一个待分类的样本，通过计算它与训练集中所有样本的<span class="highlight-danger">距离</span>，找到距离最近的<span class="highlight-primary">K个邻居</span>，然后根据这K个邻居的<span class="highlight-success">标签</span>来预测该样本的类别或数值。</p>
        </div>

        <div class="thinking-box">
            <h3>🤔 为什么叫"懒惰学习"？</h3>
            <p>想象一个"懒惰"的学生：</p>
            <ul style="margin-left: 20px; line-height: 2;">
                <li>📚 平时不学习，不总结规律（<span class="highlight-primary">没有训练过程</span>）</li>
                <li>📖 只是把所有资料都记住（<span class="highlight-success">存储所有训练数据</span>）</li>
                <li>❓ 考试时才临时翻书找答案（<span class="highlight-warning">预测时才计算</span>）</li>
            </ul>
            <p>这就是KNN的工作方式！它不像其他算法那样提前学习规律，而是把所有数据都"记住"，需要预测时才开始"工作"。</p>
        </div>

        <div class="mind-map">
            <div class="mind-node">
                <h4>🎯 算法特点</h4>
                <p><span class="highlight-primary">简单直观</span>：逻辑符合人类思维</p>
                <p><span class="highlight-success">非参数</span>：不假设数据分布</p>
                <p><span class="highlight-warning">多用途</span>：既能分类又能回归</p>
            </div>
            <div class="mind-node">
                <h4>⚡ 计算特性</h4>
                <p><span class="highlight-danger">懒惰学习</span>：训练时间为O(1)</p>
                <p><span class="highlight-primary">预测成本高</span>：需要计算所有距离</p>
                <p><span class="highlight-success">内存密集</span>：存储全部训练数据</p>
            </div>
            <div class="mind-node">
                <h4>🔧 关键参数</h4>
                <p><span class="highlight-warning">K值</span>：邻居数量</p>
                <p><span class="highlight-primary">距离度量</span>：相似性计算方法</p>
                <p><span class="highlight-danger">权重策略</span>：邻居重要性</p>
            </div>
        </div>

        <div class="history-box">
            <h3>📜 历史背景：KNN的诞生</h3>
            <p><strong>1951年</strong>：KNN算法由<span class="highlight-primary">Fix & Hodges</span>首次提出，最初用于<span class="highlight-success">非参数统计</span>领域。</p>
            <p><strong>1967年</strong>：<span class="highlight-warning">Cover & Hart</span>发表了著名论文《Nearest neighbor pattern classification》，奠定了KNN的理论基础。</p>
            <p><strong>核心发现</strong>：当训练样本数量趋于无穷大时，KNN的错误率不会超过<span class="highlight-danger">贝叶斯错误率的2倍</span>。这个理论保证让KNN获得了学术界的认可。</p>
            <p><strong>现代应用</strong>：随着计算能力的提升，KNN在<span class="highlight-primary">推荐系统</span>、<span class="highlight-success">图像识别</span>、<span class="highlight-warning">文本分类</span>等领域得到广泛应用。</p>
        </div>
    </div>

    <!-- 4.2 数学基础 -->
    <div id="math-foundation" class="section-card fade-in section-anchor">
        <h2 class="section-title">🧮 4.2 KNN的数学基础</h2>

        <div class="thinking-box">
            <h3>🤔 数学思考</h3>
            <p>在学习数学公式之前，让我们思考一个问题：</p>
            <p><strong>如何量化"相似性"？</strong></p>
            <p>比如，如何判断两个人是否相似？可能需要比较他们的：身高、体重、年龄、收入...</p>
            <p>在数学上，我们用<span class="highlight-primary">距离</span>来衡量相似性：距离越小，越相似。</p>
        </div>

        <div class="formula-box">
            <h4>🎯 KNN分类算法</h4>
            <div class="math-formula">
                <span>ŷ = argmax<sub>c</sub></span>
                <span style="font-size: 2rem; margin: 0 10px;">∑</span>
                <span style="position: relative; bottom: -15px; font-size: 0.8em;">i∈N<sub>K</sub>(x)</span>
                <span style="margin-left: 20px;">w<sub>i</sub> · I(y<sub>i</sub> = c)</span>
            </div>
            <div class="formula-explanation">
                <p><strong>中文解释：</strong>预测类别 = 让 {K个邻居中属于类别c的权重总和} 最大的那个类别c</p>
                <p><strong>符号详解：</strong></p>
                <p>• <span class="highlight-primary">ŷ</span>：预测的类别标签</p>
                <p>• <span class="highlight-success">N<sub>K</sub>(x)</span>：样本x的K个最近邻居集合</p>
                <p>• <span class="highlight-warning">w<sub>i</sub></span>：第i个邻居的投票权重</p>
                <p>• <span class="highlight-danger">I(y<sub>i</sub> = c)</span>：指示函数，当第i个邻居属于类别c时为1，否则为0</p>
            </div>
        </div>

        <div class="formula-box">
            <h4>📊 KNN回归算法</h4>
            <div class="math-formula">
                <span>ŷ = </span>
                <span class="fraction">
                    <span class="numerator">
                        <span style="font-size: 1.5rem;">∑</span>
                        <span style="position: relative; bottom: -10px; font-size: 0.8em;">i∈N<sub>K</sub>(x)</span>
                        <span style="margin-left: 10px;">w<sub>i</sub> · y<sub>i</sub></span>
                    </span>
                    <span class="denominator">
                        <span style="font-size: 1.5rem;">∑</span>
                        <span style="position: relative; bottom: -10px; font-size: 0.8em;">i∈N<sub>K</sub>(x)</span>
                        <span style="margin-left: 10px;">w<sub>i</sub></span>
                    </span>
                </span>
            </div>
            <div class="formula-explanation">
                <p><strong>中文解释：</strong>预测值 = (K个邻居的加权标签值之和) ÷ (K个邻居的权重之和)</p>
                <p><strong>本质：</strong>加权平均数，距离越近的邻居影响越大</p>
            </div>
        </div>

        <div class="formula-box">
            <h4>⚖️ 权重计算公式</h4>
            <div class="math-formula">
                <span>w<sub>i</sub> = </span>
                <span class="fraction">
                    <span class="numerator">1</span>
                    <span class="denominator">(d<sub>i</sub> + ε)<sup>p</sup></span>
                </span>
            </div>
            <div class="formula-explanation">
                <p><strong>中文解释：</strong>第i个邻居的权重 = 1 ÷ (距离的p次方)</p>
                <p>• <span class="highlight-primary">d<sub>i</sub></span>：第i个邻居与查询点的距离</p>
                <p>• <span class="highlight-success">ε</span>：极小常数（如1e-8），防止除零错误</p>
                <p>• <span class="highlight-warning">p</span>：幂次参数，控制距离衰减速度（通常p=1或p=2）</p>
            </div>
        </div>

        <div class="insight-box">
            <h4>💡 数学洞察</h4>
            <p><strong>为什么这些公式有效？</strong></p>
            <ul style="margin-left: 20px; line-height: 2;">
                <li><span class="highlight-primary">贝叶斯观点</span>：KNN实际上是在估计条件概率P(y|x)</li>
                <li><span class="highlight-success">统计原理</span>：局部平滑假设——相近的点有相似的输出</li>
                <li><span class="highlight-warning">收敛性质</span>：样本数趋于无穷时，KNN收敛到贝叶斯最优分类器</li>
            </ul>
        </div>

        <div class="warning-box">
            <h4>⚠️ 数学局限性：维数灾难</h4>
            <p>当特征维数很高时（如d>10），所有点之间的距离趋于相等，KNN算法失效。</p>
            <div class="math-formula">
                <span>lim</span>
                <span style="position: relative; bottom: -10px; font-size: 0.8em;">d→∞</span>
                <span class="fraction" style="margin-left: 20px;">
                    <span class="numerator">d<sub>max</sub> - d<sub>min</sub></span>
                    <span class="denominator">d<sub>min</sub></span>
                </span>
                <span style="margin: 0 10px;">→</span>
                <span>0</span>
            </div>
            <p>这就是为什么高维数据通常需要<span class="highlight-warning">降维处理</span>的原因。</p>
        </div>
    </div>

    <!-- 4.3 距离度量方法 -->
    <div id="distance-metrics" class="section-card fade-in section-anchor">
        <h2 class="section-title">📏 4.3 距离度量方法</h2>

        <div class="thinking-box">
            <h3>🤔 几何思维实验</h3>
            <p>想象你在一个城市中，要从点A到点B，有几种走法？</p>
            <ul style="margin-left: 20px; line-height: 2;">
                <li>🛩️ <span class="highlight-success">直线飞行</span>：最短距离（欧式距离）</li>
                <li>🚗 <span class="highlight-primary">沿街道行驶</span>：只能垂直水平移动（曼哈顿距离）</li>
                <li>♔ <span class="highlight-warning">国王的走法</span>：可以斜向移动（切比雪夫距离）</li>
            </ul>
            <p>不同的"交通规则"对应不同的距离度量方法！</p>
        </div>

        <div class="formula-box">
            <h4>📐 欧式距离（Euclidean Distance）</h4>
            <div class="math-formula">
                <span>d(x, y) = </span>
                <span class="sqrt">
                    <span class="sqrt-content">
                        <span style="font-size: 1.5rem;">∑</span>
                        <span style="position: relative; bottom: -10px; font-size: 0.8em;">i=1</span>
                        <sup style="position: relative; top: -15px; left: -5px;">n</sup>
                        <span style="margin-left: 10px;">(x<sub>i</sub> - y<sub>i</sub>)<sup>2</sup></span>
                    </span>
                </span>
            </div>
            <div class="formula-explanation">
                <p><strong>几何意义：</strong>连接两点的<span class="highlight-primary">直线距离</span></p>
                <p><strong>适用场景：</strong>连续特征、地理坐标、图像像素</p>
                <p><strong>数学性质：</strong>满足三角不等式，旋转不变性</p>
            </div>
        </div>

        <div class="formula-box">
            <h4>🏙️ 曼哈顿距离（Manhattan Distance）</h4>
            <div class="math-formula">
                <span>d(x, y) = </span>
                <span style="font-size: 1.5rem;">∑</span>
                <span style="position: relative; bottom: -10px; font-size: 0.8em;">i=1</span>
                <sup style="position: relative; top: -15px; left: -5px;">n</sup>
                <span style="margin-left: 10px;">|x<sub>i</sub> - y<sub>i</sub>|</span>
            </div>
            <div class="formula-explanation">
                <p><strong>几何意义：</strong>沿坐标轴方向的<span class="highlight-success">总路程</span></p>
                <p><strong>适用场景：</strong>网格数据、高维稀疏数据、对异常值鲁棒</p>
                <p><strong>别名：</strong>L1距离、出租车距离</p>
            </div>
        </div>

        <div class="formula-box">
            <h4>♔ 切比雪夫距离（Chebyshev Distance）</h4>
            <div class="math-formula">
                <span>d(x, y) = max<sub>i</sub> |x<sub>i</sub> - y<sub>i</sub>|</span>
            </div>
            <div class="formula-explanation">
                <p><strong>几何意义：</strong>各维度差异的<span class="highlight-warning">最大值</span></p>
                <p><strong>适用场景：</strong>象棋游戏、图像处理、关注最大差异</p>
                <p><strong>别名：</strong>L∞距离、国王距离</p>
            </div>
        </div>

        <div class="formula-box">
            <h4>🔧 闵可夫斯基距离（Minkowski Distance）</h4>
            <div class="math-formula">
                <span>d(x, y) = </span>
                <span style="font-size: 1.5rem;">[</span>
                <span style="font-size: 1.5rem;">∑</span>
                <span style="position: relative; bottom: -10px; font-size: 0.8em;">i=1</span>
                <sup style="position: relative; top: -15px; left: -5px;">n</sup>
                <span style="margin-left: 10px;">|x<sub>i</sub> - y<sub>i</sub>|<sup>p</sup></span>
                <span style="font-size: 1.5rem;">]</span>
                <sup style="font-size: 0.8em;">1/p</sup>
            </div>
            <div class="formula-explanation">
                <p><strong>统一框架：</strong>通过参数p控制距离类型</p>
                <p>• <span class="highlight-primary">p=1</span>: 曼哈顿距离</p>
                <p>• <span class="highlight-success">p=2</span>: 欧式距离</p>
                <p>• <span class="highlight-warning">p→∞</span>: 切比雪夫距离</p>
            </div>
        </div>

        <!-- 距离度量可视化演示 -->
        <div class="demo-container">
            <h3>🎮 距离可视化演示</h3>
            <canvas id="distanceDemo" class="demo-canvas" width="800" height="400"></canvas>
            <div class="demo-controls">
                <select id="distanceSelect" class="demo-btn" onchange="changeDistance()">
                    <option value="euclidean">欧式距离</option>
                    <option value="manhattan">曼哈顿距离</option>
                    <option value="chebyshev">切比雪夫距离</option>
                </select>
                <button class="demo-btn" onclick="resetDistance()">重置位置</button>
                <button class="demo-btn" onclick="animateDistance()">动画演示</button>
            </div>
            <p style="text-align: center; margin-top: 15px; color: var(--text-secondary);">
                💡 拖动蓝色点，观察不同距离度量的<span class="highlight-primary">等距离线</span>形状变化！
            </p>
            <div id="distanceResult" style="margin-top: 15px; font-size: 1.1rem; font-weight: bold; text-align: center;"></div>
        </div>

        <div class="insight-box">
            <h4>💡 距离选择指南</h4>
            <table class="data-table">
                <thead>
                <tr>
                    <th>数据特点</th>
                    <th>推荐距离</th>
                    <th>原因</th>
                </tr>
                </thead>
                <tbody>
                <tr>
                    <td>连续数值特征</td>
                    <td><span class="highlight-success">欧式距离</span></td>
                    <td>符合几何直觉，数学性质好</td>
                </tr>
                <tr>
                    <td>高维稀疏数据</td>
                    <td><span class="highlight-primary">曼哈顿距离</span></td>
                    <td>对异常值鲁棒，计算效率高</td>
                </tr>
                <tr>
                    <td>关注最大差异</td>
                    <td><span class="highlight-warning">切比雪夫距离</span></td>
                    <td>突出主导特征的影响</td>
                </tr>
                <tr>
                    <td>二元特征</td>
                    <td><span class="highlight-danger">汉明距离</span></td>
                    <td>专门处理0/1特征</td>
                </tr>
                <tr>
                    <td>文本向量</td>
                    <td><span class="highlight-primary">余弦距离</span></td>
                    <td>关注方向而非长度</td>
                </tr>
                </tbody>
            </table>
        </div>

        <div class="code-block">
            <pre><code><span class="keyword">import</span> numpy <span class="keyword">as</span> np
<span class="keyword">from</span> scipy.spatial.distance <span class="keyword">import</span> cdist

<span class="keyword">class</span> <span class="function">DistanceMetrics</span>:
    <span class="string">"""各种距离度量的实现"""</span>

    @staticmethod
    <span class="keyword">def</span> <span class="function">euclidean</span>(x, y):
        <span class="string">"""欧式距离"""</span>
        <span class="keyword">return</span> np.sqrt(np.sum((x - y) ** <span class="number">2</span>))

    @staticmethod
    <span class="keyword">def</span> <span class="function">manhattan</span>(x, y):
        <span class="string">"""曼哈顿距离"""</span>
        <span class="keyword">return</span> np.sum(np.abs(x - y))

    @staticmethod
    <span class="keyword">def</span> <span class="function">chebyshev</span>(x, y):
        <span class="string">"""切比雪夫距离"""</span>
        <span class="keyword">return</span> np.max(np.abs(x - y))

    @staticmethod
    <span class="keyword">def</span> <span class="function">minkowski</span>(x, y, p=<span class="number">2</span>):
        <span class="string">"""闵可夫斯基距离"""</span>
        <span class="keyword">return</span> np.sum(np.abs(x - y) ** p) ** (<span class="number">1</span>/p)

    @staticmethod
    <span class="keyword">def</span> <span class="function">cosine</span>(x, y):
        <span class="string">"""余弦距离"""</span>
        dot_product = np.dot(x, y)
        norm_x = np.linalg.norm(x)
        norm_y = np.linalg.norm(y)
        similarity = dot_product / (norm_x * norm_y)
        <span class="keyword">return</span> <span class="number">1</span> - similarity  <span class="comment"># 转换为距离</span>

    @staticmethod
    <span class="keyword">def</span> <span class="function">hamming</span>(x, y):
        <span class="string">"""汉明距离（用于二进制特征）"""</span>
        <span class="keyword">return</span> np.sum(x != y)

<span class="comment"># 使用示例</span>
x = np.array([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>])
y = np.array([<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>])

metrics = DistanceMetrics()
print(f<span class="string">"欧式距离: {metrics.euclidean(x, y):.2f}"</span>)
print(f<span class="string">"曼哈顿距离: {metrics.manhattan(x, y):.2f}"</span>)
print(f<span class="string">"切比雪夫距离: {metrics.chebyshev(x, y):.2f}"</span>)</code></pre>
        </div>
    </div>

    <!-- 4.4 算法详细步骤 -->
    <div id="algorithm-steps" class="section-card fade-in section-anchor">
        <h2 class="section-title">⚙️ 4.4 KNN算法详细步骤</h2>

        <div class="thinking-box">
            <h3>🤔 算法设计思考</h3>
            <p><strong>如果让你设计一个"找相似样本"的算法，你会怎么做？</strong></p>
            <p>试着把这个过程分解成几个具体步骤...</p>
            <p>思考完再看下面的标准答案！</p>
        </div>

        <div class="steps-container">
            <div class="step">
                <div class="step-number">1</div>
                <h4>距离计算</h4>
                <p>计算查询样本x与训练集中<span class="highlight-primary">每个样本</span>的距离</p>
                <div style="background: rgba(124, 58, 237, 0.1); padding: 10px; border-radius: 8px; margin-top: 10px;">
                    D = {d(x, x<sub>i</sub>) | i = 1, 2, ..., n}
                </div>
                <p style="margin-top: 10px;">时间复杂度：<span class="highlight-warning">O(nd)</span></p>
            </div>

            <div class="step">
                <div class="step-number">2</div>
                <h4>排序选择</h4>
                <p>对距离进行<span class="highlight-success">排序</span>，选择最小的K个</p>
                <div style="background: rgba(124, 58, 237, 0.1); padding: 10px; border-radius: 8px; margin-top: 10px;">
                    N<sub>K</sub> = {x<sub>i</sub> | rank(d(x, x<sub>i</sub>)) ≤ K}
                </div>
                <p style="margin-top: 10px;">时间复杂度：<span class="highlight-warning">O(n log n)</span></p>
            </div>

            <div class="step">
                <div class="step-number">3</div>
                <h4>权重计算</h4>
                <p>计算每个邻居的<span class="highlight-danger">影响权重</span></p>
                <div style="background: rgba(124, 58, 237, 0.1); padding: 10px; border-radius: 8px; margin-top: 10px;">
                    w<sub>i</sub> = f(d<sub>i</sub>)
                </div>
                <p style="margin-top: 10px;">常见策略：uniform、distance</p>
            </div>

            <div class="step">
                <div class="step-number">4</div>
                <h4>预测输出</h4>
                <p>根据邻居标签和权重计算<span class="highlight-primary">最终预测</span></p>
                <div style="background: rgba(124, 58, 237, 0.1); padding: 10px; border-radius: 8px; margin-top: 10px;">
                    ŷ = aggregate(y<sub>i</sub>, w<sub>i</sub>)
                </div>
                <p style="margin-top: 10px;">分类：加权投票；回归：加权平均</p>
            </div>
        </div>

        <!-- KNN算法演示 -->
        <div class="demo-container">
            <h3>🎮 KNN算法演示</h3>
            <canvas id="knnDemo" class="demo-canvas" width="800" height="500"></canvas>
            <div class="demo-controls">
                <button class="demo-btn" onclick="changeK(3)">K=3</button>
                <button class="demo-btn" onclick="changeK(5)">K=5</button>
                <button class="demo-btn" onclick="changeK(7)">K=7</button>
                <button class="demo-btn" onclick="changeK(9)">K=9</button>
                <button class="demo-btn" onclick="generateNewData()">生成新数据</button>
                <button class="demo-btn" onclick="clearQuery()">清除查询点</button>
                <button class="demo-btn" onclick="toggleAnimation()">动画演示</button>
            </div>
            <p style="text-align: center; margin-top: 15px; color: var(--text-secondary);">
                💡 <span class="highlight-primary">点击画布</span>添加查询点，观察KNN分类过程和K值影响！
            </p>
            <div id="knnResult" style="margin-top: 15px; font-size: 1.1rem; font-weight: bold; text-align: center;"></div>
        </div>

        <div class="code-block">
            <pre><code><span class="keyword">import</span> numpy <span class="keyword">as</span> np
<span class="keyword">from</span> collections <span class="keyword">import</span> Counter

<span class="keyword">class</span> <span class="function">KNNClassifier</span>:
    <span class="keyword">def</span> <span class="function">__init__</span>(self, k=<span class="number">3</span>, distance=<span class="string">'euclidean'</span>, weights=<span class="string">'uniform'</span>):
        <span class="string">"""
        初始化KNN分类器
        参数:
            k: 近邻数量
            distance: 距离度量 ['euclidean', 'manhattan', 'chebyshev']
            weights: 权重策略 ['uniform', 'distance']
        """</span>
        self.k = k
        self.distance = distance
        self.weights = weights

    <span class="keyword">def</span> <span class="function">fit</span>(self, X, y):
        <span class="string">"""训练KNN模型（实际上只是存储数据）"""</span>
        self.X_train = np.array(X)
        self.y_train = np.array(y)
        self.n_samples, self.n_features = self.X_train.shape

    <span class="keyword">def</span> <span class="function">_calculate_distance</span>(self, x1, x2):
        <span class="string">"""计算两点间距离"""</span>
        <span class="keyword">if</span> self.distance == <span class="string">'euclidean'</span>:
            <span class="keyword">return</span> np.sqrt(np.sum((x1 - x2) ** <span class="number">2</span>))
        <span class="keyword">elif</span> self.distance == <span class="string">'manhattan'</span>:
            <span class="keyword">return</span> np.sum(np.abs(x1 - x2))
        <span class="keyword">elif</span> self.distance == <span class="string">'chebyshev'</span>:
            <span class="keyword">return</span> np.max(np.abs(x1 - x2))

    <span class="keyword">def</span> <span class="function">_get_neighbors</span>(self, x):
        <span class="string">"""找到k个最近邻"""</span>
        <span class="comment"># 计算查询点到所有训练点的距离</span>
        distances = []
        <span class="keyword">for</span> i <span class="keyword">in</span> range(self.n_samples):
            dist = self._calculate_distance(x, self.X_train[i])
            distances.append((dist, i))

        <span class="comment"># 按距离排序并选择k个最近的</span>
        distances.sort(key=<span class="keyword">lambda</span> x: x[<span class="number">0</span>])
        neighbors = []
        <span class="keyword">for</span> i <span class="keyword">in</span> range(self.k):
            neighbors.append(distances[i])

        <span class="keyword">return</span> neighbors

    <span class="keyword">def</span> <span class="function">predict</span>(self, X):
        <span class="string">"""预测新样本的类别"""</span>
        X = np.array(X)
        predictions = []

        <span class="keyword">for</span> x <span class="keyword">in</span> X:
            <span class="comment"># 获取k个最近邻</span>
            neighbors = self._get_neighbors(x)

            <span class="comment"># 根据权重策略进行投票</span>
            <span class="keyword">if</span> self.weights == <span class="string">'uniform'</span>:
                <span class="comment"># 等权重投票</span>
                labels = [self.y_train[idx] <span class="keyword">for</span> _, idx <span class="keyword">in</span> neighbors]
                prediction = Counter(labels).most_common(<span class="number">1</span>)[<span class="number">0</span>][<span class="number">0</span>]
            <span class="keyword">else</span>:  <span class="comment"># distance weighting</span>
                <span class="comment"># 距离加权投票</span>
                class_votes = {}
                <span class="keyword">for</span> dist, idx <span class="keyword">in</span> neighbors:
                    label = self.y_train[idx]
                    weight = <span class="number">1</span> / (dist + <span class="number">1e-8</span>)  <span class="comment"># 避免除零</span>
                    <span class="keyword">if</span> label <span class="keyword">in</span> class_votes:
                        class_votes[label] += weight
                    <span class="keyword">else</span>:
                        class_votes[label] = weight

                prediction = max(class_votes, key=class_votes.get)

            predictions.append(prediction)

        <span class="keyword">return</span> np.array(predictions)

    <span class="keyword">def</span> <span class="function">score</span>(self, X, y):
        <span class="string">"""计算分类准确率"""</span>
        predictions = self.predict(X)
        <span class="keyword">return</span> np.mean(predictions == y)

<span class="comment"># 使用示例</span>
<span class="keyword">from</span> sklearn.datasets <span class="keyword">import</span> make_classification
<span class="keyword">from</span> sklearn.model_selection <span class="keyword">import</span> train_test_split

<span class="comment"># 生成示例数据</span>
X, y = make_classification(n_samples=<span class="number">200</span>, n_features=<span class="number">2</span>,
                          n_redundant=<span class="number">0</span>, n_informative=<span class="number">2</span>,
                          n_clusters_per_class=<span class="number">1</span>, random_state=<span class="number">42</span>)

<span class="comment"># 划分训练集和测试集</span>
X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=<span class="number">0.3</span>, random_state=<span class="number">42</span>)

<span class="comment"># 创建并训练模型</span>
knn = KNNClassifier(k=<span class="number">5</span>, distance=<span class="string">'euclidean'</span>, weights=<span class="string">'distance'</span>)
knn.fit(X_train, y_train)

<span class="comment"># 评估模型</span>
accuracy = knn.score(X_test, y_test)
print(f<span class="string">"测试集准确率: {accuracy:.2%}"</span>)</code></pre>
        </div>

        <div class="warning-box">
            <h4>⚠️ 算法复杂度分析</h4>
            <ul style="margin-left: 20px; line-height: 2;">
                <li><span class="highlight-primary">训练时间复杂度</span>：O(1) - 只是存储数据</li>
                <li><span class="highlight-success">预测时间复杂度</span>：O(nd) - 需要计算所有距离</li>
                <li><span class="highlight-warning">空间复杂度</span>：O(nd) - 存储全部训练数据</li>
                <li><span class="highlight-danger">优化方法</span>：KD树、Ball树、LSH等加速结构</li>
            </ul>
        </div>
    </div>

    <!-- 4.5 数据预处理 -->
    <div id="data-preprocessing" class="section-card fade-in section-anchor">
        <h2 class="section-title">📊 4.5 数据预处理的重要性</h2>

        <div class="thinking-box">
            <h3>🤔 一个致命的问题</h3>
            <p>考虑这样一个数据集：</p>
            <table class="data-table" style="margin: 20px 0;">
                <thead>
                <tr>
                    <th>样本</th>
                    <th>年龄（岁）</th>
                    <th>收入（元）</th>
                    <th>类别</th>
                </tr>
                </thead>
                <tbody>
                <tr>
                    <td>A</td>
                    <td>25</td>
                    <td>50000</td>
                    <td>年轻白领</td>
                </tr>
                <tr>
                    <td>B</td>
                    <td>35</td>
                    <td>80000</td>
                    <td>中年管理</td>
                </tr>
                <tr>
                    <td>C</td>
                    <td>45</td>
                    <td>120000</td>
                    <td>高级专家</td>
                </tr>
                </tbody>
            </table>
            <p><strong>问题：</strong>如果直接用欧式距离计算A和B的相似性，会发生什么？</p>
            <div style="background: rgba(239, 68, 68, 0.1); padding: 20px; border-radius: 10px; margin-top: 20px;">
                <p style="text-align: center; font-size: 1.2rem;">
                    d(A,B) = √[(25-35)² + (50000-80000)²] ≈ 30,000
                </p>
                <p style="text-align: center; margin-top: 10px;">
                    <span class="highlight-danger">收入差异完全主导了距离计算！</span>年龄的10岁差异被3万的收入差异完全掩盖。
                </p>
            </div>
        </div>

        <div class="warning-box">
            <h4>⚠️ 特征尺度问题</h4>
            <p>KNN算法对<span class="highlight-primary">特征尺度极其敏感</span>。不同特征的量纲差异会导致：</p>
            <ul style="margin-left: 20px; line-height: 2;">
                <li>🎯 大数值特征主导距离计算</li>
                <li>🎯 小数值特征被忽略</li>
                <li>🎯 算法性能严重下降</li>
            </ul>
            <p><strong>解决方案：</strong>数据预处理是KNN成功的<span class="highlight-warning">必要条件</span>！</p>
        </div>

        <div class="mind-map">
            <div class="mind-node">
                <h4>📏 归一化</h4>
                <p>将数据缩放到<span class="highlight-primary">[0,1]</span>或<span class="highlight-success">[-1,1]</span></p>
                <p>保持<span class="highlight-warning">原始分布形状</span></p>
                <p>对<span class="highlight-danger">异常值敏感</span></p>
            </div>
            <div class="mind-node">
                <h4>📊 标准化</h4>
                <p><span class="highlight-primary">均值=0</span>，<span class="highlight-success">标准差=1</span></p>
                <p>关注<span class="highlight-warning">统计分布</span></p>
                <p>对异常值<span class="highlight-danger">相对鲁棒</span></p>
            </div>
            <div class="mind-node">
                <h4>🔧 特征工程</h4>
                <p><span class="highlight-primary">独热编码</span>处理分类变量</p>
                <p><span class="highlight-success">特征选择</span>减少噪声</p>
                <p><span class="highlight-warning">降维技术</span>对抗维数灾难</p>
            </div>
        </div>

        <div class="formula-box">
            <h4>📏 Min-Max归一化</h4>
            <div class="math-formula">
                <span>x' = </span>
                <span class="fraction">
                    <span class="numerator">x - min(X)</span>
                    <span class="denominator">max(X) - min(X)</span>
                </span>
            </div>
            <div class="formula-explanation">
                <p><strong>效果：</strong>将数据线性映射到[0,1]区间</p>
                <p><strong>优点：</strong>保持原始分布形状，易于理解</p>
                <p><strong>缺点：</strong>对异常值敏感，新数据可能超出[0,1]</p>
            </div>
        </div>

        <div class="formula-box">
            <h4>📊 Z-score标准化</h4>
            <div class="math-formula">
                <span>x' = </span>
                <span class="fraction">
                    <span class="numerator">x - μ</span>
                    <span class="denominator">σ</span>
                </span>
            </div>
            <div class="formula-explanation">
                <p>其中 <span class="highlight-primary">μ</span> 是均值，<span class="highlight-success">σ</span> 是标准差</p>
                <p><strong>效果：</strong>转换为标准正态分布（均值=0，标准差=1）</p>
                <p><strong>优点：</strong>对异常值相对鲁棒，理论基础扎实</p>
                <p><strong>缺点：</strong>不保证数据在固定范围内</p>
            </div>
        </div>

        <!-- 预处理效果可视化 -->
        <div class="demo-container">
            <h3>🎮 数据预处理效果演示</h3>
            <canvas id="preprocessDemo" class="demo-canvas" width="800" height="400"></canvas>
            <div class="demo-controls">
                <button class="demo-btn" onclick="showOriginalData()">原始数据</button>
                <button class="demo-btn" onclick="showNormalizedData()">归一化后</button>
                <button class="demo-btn" onclick="showStandardizedData()">标准化后</button>
                <button class="demo-btn" onclick="animatePreprocess()">动画对比</button>
            </div>
            <p style="text-align: center; margin-top: 15px; color: var(--text-secondary);">
                💡 观察不同预处理方法对<span class="highlight-primary">特征分布</span>和<span class="highlight-success">KNN决策边界</span>的影响！
            </p>
        </div>

        <div class="code-block">
            <pre><code><span class="keyword">from</span> sklearn.preprocessing <span class="keyword">import</span> MinMaxScaler, StandardScaler, RobustScaler
<span class="keyword">from</span> sklearn.compose <span class="keyword">import</span> ColumnTransformer
<span class="keyword">from</span> sklearn.preprocessing <span class="keyword">import</span> OneHotEncoder
<span class="keyword">import</span> pandas <span class="keyword">as</span> pd
<span class="keyword">import</span> numpy <span class="keyword">as</span> np

<span class="keyword">class</span> <span class="function">DataPreprocessor</span>:
    <span class="string">"""KNN数据预处理管道"""</span>

    <span class="keyword">def</span> <span class="function">__init__</span>(self, numeric_features, categorical_features, scaling_method=<span class="string">'standard'</span>):
        self.numeric_features = numeric_features
        self.categorical_features = categorical_features
        self.scaling_method = scaling_method
        self.preprocessor = <span class="keyword">None</span>

    <span class="keyword">def</span> <span class="function">create_preprocessor</span>(self):
        <span class="string">"""创建预处理管道"""</span>
        <span class="comment"># 选择数值特征的缩放方法</span>
        <span class="keyword">if</span> self.scaling_method == <span class="string">'minmax'</span>:
            numeric_transformer = MinMaxScaler()
        <span class="keyword">elif</span> self.scaling_method == <span class="string">'standard'</span>:
            numeric_transformer = StandardScaler()
        <span class="keyword">elif</span> self.scaling_method == <span class="string">'robust'</span>:
            numeric_transformer = RobustScaler()  <span class="comment"># 对异常值更鲁棒</span>

        <span class="comment"># 分类特征编码</span>
        categorical_transformer = OneHotEncoder(drop=<span class="string">'first'</span>, sparse=<span class="keyword">False</span>)

        <span class="comment"># 组合预处理步骤</span>
        self.preprocessor = ColumnTransformer(
            transformers=[
                (<span class="string">'num'</span>, numeric_transformer, self.numeric_features),
                (<span class="string">'cat'</span>, categorical_transformer, self.categorical_features)
            ])

        <span class="keyword">return</span> self.preprocessor

    <span class="keyword">def</span> <span class="function">fit_transform</span>(self, X):
        <span class="string">"""拟合并转换数据"""</span>
        <span class="keyword">if</span> self.preprocessor <span class="keyword">is</span> <span class="keyword">None</span>:
            self.create_preprocessor()
        <span class="keyword">return</span> self.preprocessor.fit_transform(X)

    <span class="keyword">def</span> <span class="function">transform</span>(self, X):
        <span class="string">"""转换新数据"""</span>
        <span class="keyword">return</span> self.preprocessor.transform(X)

<span class="comment"># 使用示例</span>
<span class="comment"># 创建示例数据</span>
data = pd.DataFrame({
    <span class="string">'年龄'</span>: [<span class="number">25</span>, <span class="number">35</span>, <span class="number">45</span>, <span class="number">28</span>, <span class="number">52</span>],
    <span class="string">'收入'</span>: [<span class="number">50000</span>, <span class="number">80000</span>, <span class="number">120000</span>, <span class="number">60000</span>, <span class="number">150000</span>],
    <span class="string">'教育程度'</span>: [<span class="string">'本科'</span>, <span class="string">'硕士'</span>, <span class="string">'博士'</span>, <span class="string">'本科'</span>, <span class="string">'博士'</span>],
    <span class="string">'类别'</span>: [<span class="string">'初级'</span>, <span class="string">'中级'</span>, <span class="string">'高级'</span>, <span class="string">'初级'</span>, <span class="string">'高级'</span>]
})

<span class="comment"># 分离特征和标签</span>
X = data.drop(<span class="string">'类别'</span>, axis=<span class="number">1</span>)
y = data[<span class="string">'类别'</span>]

<span class="comment"># 创建预处理器</span>
preprocessor = DataPreprocessor(
    numeric_features=[<span class="string">'年龄'</span>, <span class="string">'收入'</span>],
    categorical_features=[<span class="string">'教育程度'</span>],
    scaling_method=<span class="string">'standard'</span>
)

<span class="comment"># 预处理数据</span>
X_processed = preprocessor.fit_transform(X)

print(<span class="string">"原始数据:"</span>)
print(X)
print(<span class="string">"\n处理后数据:"</span>)
print(X_processed)

<span class="comment"># 验证标准化效果</span>
print(<span class="string">f"\n处理后数值特征均值: {X_processed[:, :2].mean(axis=0)}"</span>)
print(<span class="string">f"处理后数值特征标准差: {X_processed[:, :2].std(axis=0)}"</span>)</code></pre>
        </div>

        <div class="insight-box">
            <h4>💡 预处理选择指南</h4>
            <table class="data-table">
                <thead>
                <tr>
                    <th>场景</th>
                    <th>推荐方法</th>
                    <th>原因</th>
                </tr>
                </thead>
                <tbody>
                <tr>
                    <td>数据有明确边界</td>
                    <td><span class="highlight-success">Min-Max归一化</span></td>
                    <td>如图像像素值0-255</td>
                </tr>
                <tr>
                    <td>数据近似正态分布</td>
                    <td><span class="highlight-primary">Z-score标准化</span></td>
                    <td>发挥统计特性</td>
                </tr>
                <tr>
                    <td>存在异常值</td>
                    <td><span class="highlight-warning">Robust标准化</span></td>
                    <td>使用中位数和四分位距</td>
                </tr>
                <tr>
                    <td>稀疏数据</td>
                    <td><span class="highlight-danger">MaxAbs标准化</span></td>
                    <td>保持稀疏性</td>
                </tr>
                </tbody>
            </table>
        </div>

        <div class="pro-tip">
            <p><strong>特征工程的艺术：</strong></p>
            <ul style="margin-left: 20px; line-height: 2;">
                <li>📊 <span class="highlight-primary">理解数据分布</span>：使用可视化工具查看特征分布</li>
                <li>🔍 <span class="highlight-success">识别异常值</span>：决定是删除还是保留</li>
                <li>🎯 <span class="highlight-warning">特征选择</span>：去除无关或冗余特征</li>
                <li>🚀 <span class="highlight-danger">特征创造</span>：基于领域知识构造新特征</li>
            </ul>
        </div>
    </div>

    <!-- 4.6 参数调优 -->
    <div id="parameter-tuning" class="section-card fade-in section-anchor">
        <h2 class="section-title">🔧 4.6 超参数调优：寻找最佳配置</h2>

        <div class="thinking-box">
            <h3>🤔 参数选择的艺术</h3>
            <p>如果你要调优一个KNN模型，面临以下选择：</p>
            <ul style="margin-left: 20px; line-height: 2;">
                <li>🔢 K值：3, 5, 7, 9, 11, ..., 21</li>
                <li>⚖️ 权重：uniform vs distance</li>
                <li>📏 距离：euclidean vs manhattan vs chebyshev</li>
            </ul>
            <p><strong>问题：</strong>总共有多少种组合？如何系统化地找到最优配置？</p>
            <p><span class="highlight-primary">答案：</span>10×2×3 = 60种组合！手动尝试显然不现实。</p>
        </div>

        <!-- K值影响可视化 -->
        <div class="demo-container">
            <h3>🎮 K值对决策边界的影响</h3>
            <canvas id="kBoundaryDemo" class="demo-canvas" width="800" height="400"></canvas>
            <div class="param-panel">
                <h4 style="color: var(--knn-purple); margin-bottom: 15px;">调整K值，观察变化</h4>
                <div>
                    <label>K值: <span class="param-value" id="kValue">5</span></label>
                    <input type="range" class="param-slider" id="kSlider" min="1" max="21" step="2" value="5" oninput="updateKBoundary()">
                </div>
                <div>
                    <label>噪声级别: <span class="param-value" id="noiseLevel">10%</span></label>
                    <input type="range" class="param-slider" id="noiseSlider" min="0" max="30" step="5" value="10" oninput="updateNoise()">
                </div>
            </div>
            <div class="model-status">
                <div class="status-item">
                    <div class="status-label">决策平滑度</div>
                    <div class="status-value" id="smoothness">中等</div>
                </div>
                <div class="status-item">
                    <div class="status-label">过拟合风险</div>
                    <div class="status-value" id="overfittingRisk">低</div>
                </div>
            </div>
        </div>

        <div class="insight-box">
            <h4>💡 K值选择的智慧</h4>
            <div style="display: grid; grid-template-columns: 1fr 1fr 1fr; gap: 20px; margin-top: 20px;">
                <div style="background: rgba(124, 58, 237, 0.1); padding: 20px; border-radius: 10px;">
                    <h5 style="color: var(--knn-purple); margin-bottom: 10px;">K太小（如K=1）</h5>
                    <p>✗ 对噪声敏感</p>
                    <p>✗ 决策边界复杂</p>
                    <p>✗ 容易过拟合</p>
                    <p>✓ 训练误差小</p>
                </div>
                <div style="background: rgba(102, 126, 234, 0.1); padding: 20px; border-radius: 10px;">
                    <h5 style="color: var(--knn-blue); margin-bottom: 10px;">K适中（如K=5-9）</h5>
                    <p>✓ 平衡偏差-方差</p>
                    <p>✓ 决策边界适中</p>
                    <p>✓ 泛化能力好</p>
                    <p>✓ 鲁棒性适中</p>
                </div>
                <div style="background: rgba(236, 72, 153, 0.1); padding: 20px; border-radius: 10px;">
                    <h5 style="color: var(--knn-pink); margin-bottom: 10px;">K太大（如K>20）</h5>
                    <p>✓ 对噪声鲁棒</p>
                    <p>✗ 决策边界过于平滑</p>
                    <p>✗ 容易欠拟合</p>
                    <p>✗ 忽略局部模式</p>
                </div>
            </div>
        </div>

        <div class="formula-box">
            <h4>🧮 最优K值的经验公式</h4>
            <div class="math-formula">
                <span>K<sub>optimal</sub> ≈ √n</span>
            </div>
            <div class="formula-explanation">
                <p>其中 n 是训练样本数量</p>
                <p><strong>注意：</strong>这只是一个起点，实际最优K值需要通过交叉验证确定</p>
                <p>• 二分类问题：K通常选择<span class="highlight-primary">奇数</span>，避免平票</p>
                <p>• 多分类问题：考虑类别数量，K不应小于类别数</p>
            </div>
        </div>

        <div class="code-block">
            <pre><code><span class="keyword">from</span> sklearn.model_selection <span class="keyword">import</span> GridSearchCV, cross_val_score
<span class="keyword">from</span> sklearn.neighbors <span class="keyword">import</span> KNeighborsClassifier
<span class="keyword">from</span> sklearn.metrics <span class="keyword">import</span> make_scorer, accuracy_score
<span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt

<span class="keyword">class</span> <span class="function">KNNTuner</span>:
    <span class="string">"""KNN超参数调优工具"""</span>

    <span class="keyword">def</span> <span class="function">__init__</span>(self, X_train, y_train, X_val, y_val):
        self.X_train = X_train
        self.y_train = y_train
        self.X_val = X_val
        self.y_val = y_val

    <span class="keyword">def</span> <span class="function">find_optimal_k</span>(self, k_range=<span class="keyword">None</span>, cv_folds=<span class="number">5</span>):
        <span class="string">"""通过交叉验证找到最优K值"""</span>
        <span class="keyword">if</span> k_range <span class="keyword">is</span> <span class="keyword">None</span>:
            <span class="comment"># 默认搜索范围</span>
            max_k = min(<span class="number">50</span>, int(np.sqrt(len(self.X_train))))
            k_range = range(<span class="number">1</span>, max_k, <span class="number">2</span>)  <span class="comment"># 只考虑奇数</span>

        cv_scores = []
        val_scores = []

        <span class="keyword">for</span> k <span class="keyword">in</span> k_range:
            knn = KNeighborsClassifier(n_neighbors=k)

            <span class="comment"># 交叉验证得分</span>
            cv_score = cross_val_score(knn, self.X_train, self.y_train,
                                      cv=cv_folds, scoring=<span class="string">'accuracy'</span>)
            cv_scores.append(cv_score.mean())

            <span class="comment"># 验证集得分</span>
            knn.fit(self.X_train, self.y_train)
            val_score = knn.score(self.X_val, self.y_val)
            val_scores.append(val_score)

        <span class="comment"># 绘制K值影响图</span>
        plt.figure(figsize=(<span class="number">10</span>, <span class="number">6</span>))
        plt.plot(k_range, cv_scores, <span class="string">'b-'</span>, label=<span class="string">'CV Score'</span>, linewidth=<span class="number">2</span>)
        plt.plot(k_range, val_scores, <span class="string">'r--'</span>, label=<span class="string">'Validation Score'</span>, linewidth=<span class="number">2</span>)
        plt.xlabel(<span class="string">'K值'</span>)
        plt.ylabel(<span class="string">'准确率'</span>)
        plt.title(<span class="string">'K值对模型性能的影响'</span>)
        plt.legend()
        plt.grid(<span class="keyword">True</span>, alpha=<span class="number">0.3</span>)

        <span class="comment"># 找到最优K</span>
        optimal_k_idx = np.argmax(cv_scores)
        optimal_k = list(k_range)[optimal_k_idx]

        <span class="keyword">return</span> optimal_k, cv_scores, val_scores

    <span class="keyword">def</span> <span class="function">grid_search_optimization</span>(self):
        <span class="string">"""网格搜索优化所有超参数"""</span>
        param_grid = {
            <span class="string">'n_neighbors'</span>: [<span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">9</span>, <span class="number">11</span>, <span class="number">15</span>, <span class="number">21</span>],
            <span class="string">'weights'</span>: [<span class="string">'uniform'</span>, <span class="string">'distance'</span>],
            <span class="string">'metric'</span>: [<span class="string">'euclidean'</span>, <span class="string">'manhattan'</span>, <span class="string">'chebyshev'</span>],
            <span class="string">'p'</span>: [<span class="number">1</span>, <span class="number">2</span>]  <span class="comment"># 闵可夫斯基距离的参数</span>
        }

        knn = KNeighborsClassifier()
        grid_search = GridSearchCV(
            estimator=knn,
            param_grid=param_grid,
            cv=<span class="number">5</span>,
            scoring=<span class="string">'accuracy'</span>,
            n_jobs=-<span class="number">1</span>,
            verbose=<span class="number">1</span>
        )

        grid_search.fit(self.X_train, self.y_train)

        <span class="comment"># 返回最佳参数和模型</span>
        <span class="keyword">return</span> grid_search.best_params_, grid_search.best_estimator_

    <span class="keyword">def</span> <span class="function">analyze_parameter_importance</span>(self, results_df):
        <span class="string">"""分析参数重要性"""</span>
        <span class="comment"># 计算每个参数对性能的平均影响</span>
        param_importance = {}

        <span class="keyword">for</span> param <span class="keyword">in</span> [<span class="string">'n_neighbors'</span>, <span class="string">'weights'</span>, <span class="string">'metric'</span>]:
            grouped = results_df.groupby(f<span class="string">'param_{param}'</span>)[<span class="string">'mean_test_score'</span>]
            param_importance[param] = grouped.std()  <span class="comment"># 标准差越大，影响越大</span>

        <span class="keyword">return</span> param_importance

<span class="comment"># 使用示例</span>
<span class="comment"># 假设已有预处理后的数据</span>
tuner = KNNTuner(X_train_scaled, y_train, X_val_scaled, y_val)

<span class="comment"># 1. 找到最优K值</span>
optimal_k, cv_scores, val_scores = tuner.find_optimal_k()
print(f<span class="string">"最优K值: {optimal_k}"</span>)

<span class="comment"># 2. 网格搜索所有参数</span>
best_params, best_model = tuner.grid_search_optimization()
print(f<span class="string">"最佳参数组合: {best_params}"</span>)

<span class="comment"># 3. 最终评估</span>
test_score = best_model.score(X_test_scaled, y_test)
print(f<span class="string">"测试集准确率: {test_score:.4f}"</span>)</code></pre>
        </div>

        <div class="comparison-grid">
            <div class="comparison-item">
                <div class="comparison-header">
                    <div class="comparison-icon">🎯</div>
                    <div class="comparison-title">手动调参</div>
                </div>
                <p>✓ 直观理解参数影响</p>
                <p>✓ 快速试错</p>
                <p>✗ 容易遗漏最优组合</p>
                <p>✗ 耗时费力</p>
            </div>
            <div class="comparison-item">
                <div class="comparison-header">
                    <div class="comparison-icon">🔍</div>
                    <div class="comparison-title">网格搜索</div>
                </div>
                <p>✓ 系统性搜索</p>
                <p>✓ 保证找到最优</p>
                <p>✗ 计算成本高</p>
                <p>✗ 指数级增长</p>
            </div>
            <div class="comparison-item">
                <div class="comparison-header">
                    <div class="comparison-icon">🎲</div>
                    <div class="comparison-title">随机搜索</div>
                </div>
                <p>✓ 效率较高</p>
                <p>✓ 适合大参数空间</p>
                <p>✗ 可能错过最优</p>
                <p>✓ 性价比高</p>
            </div>
            <div class="comparison-item">
                <div class="comparison-header">
                    <div class="comparison-icon">🧠</div>
                    <div class="comparison-title">贝叶斯优化</div>
                </div>
                <p>✓ 智能搜索</p>
                <p>✓ 样本效率高</p>
                <p>✗ 实现复杂</p>
                <p>✓ 适合昂贵评估</p>
            </div>
        </div>

        <div class="pro-tip">
            <p><strong>调参实战技巧：</strong></p>
            <ul style="margin-left: 20px; line-height: 2;">
                <li>🎯 <span class="highlight-primary">先粗后细</span>：先用大步长找到大致范围，再细化搜索</li>
                <li>📊 <span class="highlight-success">验证曲线</span>：绘制参数vs性能曲线，理解参数影响</li>
                <li>🔍 <span class="highlight-warning">早停策略</span>：如果性能不再提升，提前终止搜索</li>
                <li>💡 <span class="highlight-danger">领域知识</span>：结合实际问题特点缩小搜索空间</li>
            </ul>
        </div>
    </div>

    <!-- 4.7 优化技巧 -->
    <div id="optimization" class="section-card fade-in section-anchor">
        <h2 class="section-title">⚡ 4.7 优化技巧：让KNN飞起来</h2>

        <div class="thinking-box">
            <h3>🤔 性能瓶颈在哪里？</h3>
            <p>假设有100万个训练样本，每个样本100维特征：</p>
            <ul style="margin-left: 20px; line-height: 2;">
                <li>💾 存储需求：1M × 100 × 8字节 ≈ <span class="highlight-danger">800MB</span></li>
                <li>⏱️ 单次预测：计算1M个距离 ≈ <span class="highlight-warning">100M次运算</span></li>
                <li>🔄 批量预测：复杂度呈<span class="highlight-primary">线性增长</span></li>
            </ul>
            <p><strong>问题：</strong>如何在保持准确率的同时，大幅提升速度？</p>
        </div>

        <div class="optimization-card">
            <h4>🌳 KD树（K-Dimensional Tree）</h4>
            <p><strong>核心思想：</strong>通过构建二叉树结构，将搜索空间<span class="highlight-primary">递归分割</span></p>
            <p><strong>时间复杂度：</strong>O(log n) 在低维空间（d < 20）</p>
            <p><strong>空间复杂度：</strong>O(n)</p>
            <p><strong>局限性：</strong>高维空间性能退化到O(n)</p>
        </div>

        <div class="optimization-card">
            <h4>🎾 Ball树</h4>
            <p><strong>核心思想：</strong>使用<span class="highlight-success">超球体</span>而非矩形划分空间</p>
            <p><strong>优势：</strong>在高维空间表现更好</p>
            <p><strong>时间复杂度：</strong>O(log n) 即使在较高维度</p>
            <p><strong>构建时间：</strong>比KD树慢，但查询更稳定</p>
        </div>

        <div class="optimization-card">
            <h4>🔀 LSH（局部敏感哈希）</h4>
            <p><strong>核心思想：</strong>相似的点<span class="highlight-warning">哈希到相同桶</span>的概率高</p>
            <p><strong>特点：</strong>近似最近邻，牺牲精度换速度</p>
            <p><strong>应用场景：</strong>超高维数据、海量数据</p>
            <p><strong>加速比：</strong>可达100-1000倍</p>
        </div>

        <!-- 算法复杂度对比 -->
        <div class="complexity-table">
            <table class="data-table">
                <thead>
                <tr>
                    <th>算法</th>
                    <th>构建时间</th>
                    <th>查询时间</th>
                    <th>空间复杂度</th>
                    <th>适用场景</th>
                </tr>
                </thead>
                <tbody>
                <tr>
                    <td>暴力搜索</td>
                    <td>O(1)</td>
                    <td>O(dn)</td>
                    <td>O(dn)</td>
                    <td>小数据集</td>
                </tr>
                <tr>
                    <td>KD树</td>
                    <td>O(dn log n)</td>
                    <td>O(d log n)</td>
                    <td>O(dn)</td>
                    <td>低维数据(d<20)</td>
                </tr>
                <tr>
                    <td>Ball树</td>
                    <td>O(dn log n)</td>
                    <td>O(d log n)</td>
                    <td>O(dn)</td>
                    <td>中高维数据</td>
                </tr>
                <tr>
                    <td>LSH</td>
                    <td>O(dn)</td>
                    <td>O(1)</td>
                    <td>O(dn)</td>
                    <td>超高维/海量数据</td>
                </tr>
                </tbody>
            </table>
        </div>

        <div class="code-block">
            <pre><code><span class="keyword">from</span> sklearn.neighbors <span class="keyword">import</span> KNeighborsClassifier, BallTree, KDTree
<span class="keyword">import</span> time
<span class="keyword">import</span> numpy <span class="keyword">as</span> np

<span class="keyword">class</span> <span class="function">OptimizedKNN</span>:
    <span class="string">"""优化的KNN实现"""</span>

    <span class="keyword">def</span> <span class="function">__init__</span>(self, n_neighbors=<span class="number">5</span>, algorithm=<span class="string">'auto'</span>, leaf_size=<span class="number">30</span>):
        <span class="string">"""
        参数:
            algorithm: {'auto', 'ball_tree', 'kd_tree', 'brute'}
            leaf_size: 树的叶节点大小，影响构建和查询速度
        """</span>
        self.n_neighbors = n_neighbors
        self.algorithm = algorithm
        self.leaf_size = leaf_size

    <span class="keyword">def</span> <span class="function">benchmark_algorithms</span>(self, X_train, y_train, X_test, n_queries=<span class="number">100</span>):
        <span class="string">"""对比不同算法的性能"""</span>
        algorithms = [<span class="string">'brute'</span>, <span class="string">'kd_tree'</span>, <span class="string">'ball_tree'</span>]
        results = {}

        <span class="keyword">for</span> algo <span class="keyword">in</span> algorithms:
            <span class="keyword">print</span>(f<span class="string">"\n测试算法: {algo}"</span>)

            <span class="comment"># 构建时间</span>
            start_time = time.time()
            knn = KNeighborsClassifier(
                n_neighbors=self.n_neighbors,
                algorithm=algo,
                leaf_size=self.leaf_size
            )
            knn.fit(X_train, y_train)
            build_time = time.time() - start_time

            <span class="comment"># 查询时间</span>
            start_time = time.time()
            <span class="keyword">for</span> _ <span class="keyword">in</span> range(n_queries):
                idx = np.random.randint(<span class="number">0</span>, len(X_test))
                knn.predict(X_test[idx:idx+<span class="number">1</span>])
            query_time = (time.time() - start_time) / n_queries

            <span class="comment"># 准确率</span>
            accuracy = knn.score(X_test[:<span class="number">1000</span>], y_test[:<span class="number">1000</span>])

            results[algo] = {
                <span class="string">'build_time'</span>: build_time,
                <span class="string">'query_time'</span>: query_time,
                <span class="string">'accuracy'</span>: accuracy
            }

            <span class="keyword">print</span>(f<span class="string">"构建时间: {build_time:.4f}秒"</span>)
            <span class="keyword">print</span>(f<span class="string">"平均查询时间: {query_time*1000:.2f}毫秒"</span>)
            <span class="keyword">print</span>(f<span class="string">"准确率: {accuracy:.4f}"</span>)

        <span class="keyword">return</span> results

    <span class="keyword">def</span> <span class="function">optimize_leaf_size</span>(self, X_train, y_train, X_test):
        <span class="string">"""找到最优的leaf_size参数"""</span>
        leaf_sizes = [<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>, <span class="number">40</span>, <span class="number">50</span>, <span class="number">100</span>]
        results = []

        <span class="keyword">for</span> leaf_size <span class="keyword">in</span> leaf_sizes:
            knn = KNeighborsClassifier(
                n_neighbors=self.n_neighbors,
                algorithm=<span class="string">'ball_tree'</span>,
                leaf_size=leaf_size
            )

            <span class="comment"># 测量性能</span>
            start_time = time.time()
            knn.fit(X_train, y_train)
            knn.predict(X_test[:<span class="number">100</span>])
            total_time = time.time() - start_time

            results.append((leaf_size, total_time))

        <span class="keyword">return</span> results

<span class="comment"># 高级优化：近似最近邻</span>
<span class="keyword">class</span> <span class="function">ApproximateKNN</span>:
    <span class="string">"""使用LSH的近似KNN"""</span>

    <span class="keyword">def</span> <span class="function">__init__</span>(self, n_neighbors=<span class="number">5</span>, n_hash_tables=<span class="number">10</span>, hash_size=<span class="number">8</span>):
        self.n_neighbors = n_neighbors
        self.n_hash_tables = n_hash_tables
        self.hash_size = hash_size
        self.hash_functions = []
        self.hash_tables = []

    <span class="keyword">def</span> <span class="function">_generate_hash_function</span>(self, n_features):
        <span class="string">"""生成随机投影哈希函数"""</span>
        <span class="comment"># 随机投影向量</span>
        random_vectors = np.random.randn(self.hash_size, n_features)
        <span class="keyword">return</span> random_vectors

    <span class="keyword">def</span> <span class="function">_hash</span>(self, x, hash_func):
        <span class="string">"""计算样本的哈希值"""</span>
        projections = np.dot(hash_func, x)
        <span class="keyword">return</span> tuple((projections > <span class="number">0</span>).astype(int))

    <span class="keyword">def</span> <span class="function">fit</span>(self, X, y):
        <span class="string">"""构建LSH索引"""</span>
        self.X_train = X
        self.y_train = y
        n_samples, n_features = X.shape

        <span class="comment"># 生成哈希函数和哈希表</span>
        <span class="keyword">for</span> _ <span class="keyword">in</span> range(self.n_hash_tables):
            hash_func = self._generate_hash_function(n_features)
            self.hash_functions.append(hash_func)

            <span class="comment"># 构建哈希表</span>
            hash_table = {}
            <span class="keyword">for</span> i, x <span class="keyword">in</span> enumerate(X):
                hash_value = self._hash(x, hash_func)
                <span class="keyword">if</span> hash_value <span class="keyword">not</span> <span class="keyword">in</span> hash_table:
                    hash_table[hash_value] = []
                hash_table[hash_value].append(i)

            self.hash_tables.append(hash_table)

    <span class="keyword">def</span> <span class="function">predict</span>(self, X):
        <span class="string">"""近似最近邻预测"""</span>
        predictions = []

        <span class="keyword">for</span> x <span class="keyword">in</span> X:
            <span class="comment"># 收集候选邻居</span>
            candidates = set()
            <span class="keyword">for</span> hash_func, hash_table <span class="keyword">in</span> zip(self.hash_functions, self.hash_tables):
                hash_value = self._hash(x, hash_func)
                <span class="keyword">if</span> hash_value <span class="keyword">in</span> hash_table:
                    candidates.update(hash_table[hash_value])

            <span class="comment"># 在候选集中找最近邻</span>
            <span class="keyword">if</span> candidates:
                candidate_X = self.X_train[list(candidates)]
                candidate_y = self.y_train[list(candidates)]

                <span class="comment"># 计算距离</span>
                distances = np.linalg.norm(candidate_X - x, axis=<span class="number">1</span>)
                k_nearest_idx = np.argsort(distances)[:self.n_neighbors]

                <span class="comment"># 投票</span>
                k_nearest_labels = candidate_y[k_nearest_idx]
                prediction = np.bincount(k_nearest_labels).argmax()
            <span class="keyword">else</span>:
                <span class="comment"># 如果没有候选，使用最常见类</span>
                prediction = np.bincount(self.y_train).argmax()

            predictions.append(prediction)

        <span class="keyword">return</span> np.array(predictions)</code></pre>
        </div>

        <div class="insight-box">
            <h4>💡 优化策略选择指南</h4>
            <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 20px; margin-top: 20px;">
                <div>
                    <h5 style="color: var(--knn-purple);">✅ 推荐使用场景</h5>
                    <p><strong>KD树：</strong>d < 20，均匀分布数据</p>
                    <p><strong>Ball树：</strong>20 < d < 100，非均匀数据</p>
                    <p><strong>LSH：</strong>d > 100，可接受近似结果</p>
                    <p><strong>暴力搜索：</strong>n < 1000，需要精确结果</p>
                </div>
                <div>
                    <h5 style="color: var(--knn-pink);">⚡ 加速技巧</h5>
                    <p><strong>并行计算：</strong>使用n_jobs=-1</p>
                    <p><strong>批量预测：</strong>减少函数调用开销</p>
                    <p><strong>特征选择：</strong>降低维度</p>
                    <p><strong>采样策略：</strong>使用代表性子集</p>
                </div>
            </div>
        </div>

        <!-- 性能对比可视化 -->
        <div class="demo-container">
            <h3>🎮 算法性能对比演示</h3>
            <canvas id="performanceDemo" class="demo-canvas" width="800" height="400"></canvas>
            <div class="demo-controls">
                <button class="demo-btn" onclick="compareAlgorithms()">运行对比测试</button>
                <button class="demo-btn" onclick="showDimensionEffect()">维度影响</button>
                <button class="demo-btn" onclick="showScalability()">可扩展性测试</button>
            </div>
            <div id="performanceResult" style="margin-top: 15px; text-align: center;"></div>
        </div>

        <div class="pro-tip">
            <p><strong>实战优化清单：</strong></p>
            <ol style="margin-left: 20px; line-height: 2;">
                <li>📊 <strong>分析数据特性：</strong>维度、分布、规模</li>
                <li>🎯 <strong>选择合适算法：</strong>根据维度和精度要求</li>
                <li>🔧 <strong>调整树参数：</strong>leaf_size影响性能</li>
                <li>⚡ <strong>使用并行：</strong>多核CPU充分利用</li>
                <li>💾 <strong>内存优化：</strong>使用float32代替float64</li>
                <li>🔍 <strong>近似方法：</strong>大规模数据考虑LSH</li>
            </ol>
        </div>
    </div>

    <!-- 4.8 算法变体 -->
    <div id="variants" class="section-card fade-in section-anchor">
        <h2 class="section-title">🔀 4.8 KNN算法变体与扩展</h2>

        <div class="thinking-box">
            <h3>🤔 标准KNN的局限性</h3>
            <p>尽管KNN简单有效，但仍存在一些问题：</p>
            <ul style="margin-left: 20px; line-height: 2;">
                <li>🎯 所有特征<span class="highlight-primary">同等重要</span>？</li>
                <li>⚖️ 类别<span class="highlight-success">不平衡</span>怎么办？</li>
                <li>🌊 数据有<span class="highlight-warning">局部密度差异</span>？</li>
                <li>🔍 如何处理<span class="highlight-danger">模糊边界</span>？</li>
            </ul>
            <p>这些问题催生了各种KNN变体！</p>
        </div>

        <div class="algorithm-variant">
            <h4>⚖️ 加权KNN（Weighted KNN）</h4>
            <p><strong>改进点：</strong>不同特征赋予不同权重</p>
            <div class="math-formula">
                <span>d(x, y) = </span>
                <span class="sqrt">
                    <span class="sqrt-content">
                        <span style="font-size: 1.5rem;">∑</span>
                        <sub>i</sub>
                        <span style="margin-left: 10px;">w<sub>i</sub> × (x<sub>i</sub> - y<sub>i</sub>)<sup>2</sup></span>
                    </span>
                </span>
            </div>
            <p><strong>应用场景：</strong>特征重要性差异大的问题</p>
            <p><strong>学习方法：</strong>Relief算法、信息增益等</p>
        </div>

        <div class="algorithm-variant">
            <h4>🎯 自适应KNN（Adaptive KNN）</h4>
            <p><strong>改进点：</strong>K值随局部密度动态调整</p>
            <div style="background: rgba(124, 58, 237, 0.1); padding: 15px; border-radius: 8px; margin: 15px 0;">
                <p>稀疏区域 → 大K值（更多邻居）</p>
                <p>密集区域 → 小K值（精确局部）</p>
            </div>
            <p><strong>优势：</strong>适应数据分布的不均匀性</p>
        </div>

        <div class="algorithm-variant">
            <h4>🌟 模糊KNN（Fuzzy KNN）</h4>
            <p><strong>改进点：</strong>输出类别的隶属度而非硬分类</p>
            <div class="math-formula">
                <span>μ<sub>c</sub>(x) = </span>
                <span class="fraction">
                    <span class="numerator">
                        <span style="font-size: 1.2rem;">∑</span>
                        <sub style="font-size: 0.8em;">i∈N<sub>K</sub></sub>
                        <span style="margin-left: 10px;">u<sub>ic</sub> × w<sub>i</sub></span>
                    </span>
                    <span class="denominator">
                        <span style="font-size: 1.2rem;">∑</span>
                        <sub style="font-size: 0.8em;">i∈N<sub>K</sub></sub>
                        <span style="margin-left: 10px;">w<sub>i</sub></span>
                    </span>
                </span>
            </div>
            <p><strong>优势：</strong>处理边界模糊的样本</p>
            <p><strong>应用：</strong>医疗诊断、风险评估等需要概率输出的场景</p>
        </div>

        <div class="algorithm-variant">
            <h4>🔄 互KNN（Mutual KNN）</h4>
            <p><strong>改进点：</strong>只考虑互为最近邻的样本</p>
            <div style="background: rgba(102, 126, 234, 0.1); padding: 15px; border-radius: 8px; margin: 15px 0;">
                <p>x是y的K近邻 <strong>且</strong> y是x的K近邻 → 才考虑</p>
            </div>
            <p><strong>优势：</strong>减少噪声影响，提高稳定性</p>
        </div>

        <div class="code-block">
            <pre><code><span class="keyword">import</span> numpy <span class="keyword">as</span> np
<span class="keyword">from</span> sklearn.base <span class="keyword">import</span> BaseEstimator, ClassifierMixin
<span class="keyword">from</span> sklearn.utils.validation <span class="keyword">import</span> check_X_y, check_array

<span class="keyword">class</span> <span class="function">WeightedKNN</span>(BaseEstimator, ClassifierMixin):
    <span class="string">"""特征加权的KNN实现"""</span>

    <span class="keyword">def</span> <span class="function">__init__</span>(self, n_neighbors=<span class="number">5</span>, feature_weights=<span class="keyword">None</span>):
        self.n_neighbors = n_neighbors
        self.feature_weights = feature_weights

    <span class="keyword">def</span> <span class="function">fit</span>(self, X, y):
        X, y = check_X_y(X, y)
        self.X_ = X
        self.y_ = y
        self.classes_ = np.unique(y)

        <span class="comment"># 如果没有指定权重，使用Relief算法学习</span>
        <span class="keyword">if</span> self.feature_weights <span class="keyword">is</span> <span class="keyword">None</span>:
            self.feature_weights = self._learn_weights_relief(X, y)

        <span class="keyword">return</span> self

    <span class="keyword">def</span> <span class="function">_learn_weights_relief</span>(self, X, y, n_iterations=<span class="number">100</span>):
        <span class="string">"""使用Relief算法学习特征权重"""</span>
        n_samples, n_features = X.shape
        weights = np.zeros(n_features)

        <span class="keyword">for</span> _ <span class="keyword">in</span> range(n_iterations):
            <span class="comment"># 随机选择一个样本</span>
            idx = np.random.randint(n_samples)
            sample = X[idx]
            label = y[idx]

            <span class="comment"># 找到最近的同类和异类样本</span>
            same_class_mask = y == label
            diff_class_mask = ~same_class_mask

            <span class="comment"># 计算距离</span>
            distances = np.sum((X - sample) ** <span class="number">2</span>, axis=<span class="number">1</span>)

            <span class="comment"># 最近同类（排除自己）</span>
            same_distances = distances.copy()
            same_distances[~same_class_mask] = np.inf
            same_distances[idx] = np.inf
            nearest_hit = np.argmin(same_distances)

            <span class="comment"># 最近异类</span>
            diff_distances = distances.copy()
            diff_distances[~diff_class_mask] = np.inf
            nearest_miss = np.argmin(diff_distances)

            <span class="comment"># 更新权重</span>
            <span class="keyword">for</span> j <span class="keyword">in</span> range(n_features):
                weights[j] += np.abs(sample[j] - X[nearest_miss, j]) - \
                             np.abs(sample[j] - X[nearest_hit, j])

        <span class="comment"># 归一化权重到[0,1]</span>
        weights = (weights - weights.min()) / (weights.max() - weights.min() + <span class="number">1e-8</span>)
        <span class="keyword">return</span> weights

    <span class="keyword">def</span> <span class="function">_weighted_distance</span>(self, x1, x2):
        <span class="string">"""计算加权距离"""</span>
        <span class="keyword">return</span> np.sqrt(np.sum(self.feature_weights * (x1 - x2) ** <span class="number">2</span>))

    <span class="keyword">def</span> <span class="function">predict</span>(self, X):
        X = check_array(X)
        predictions = []

        <span class="keyword">for</span> x <span class="keyword">in</span> X:
            <span class="comment"># 计算加权距离</span>
            distances = [self._weighted_distance(x, x_train)
                        <span class="keyword">for</span> x_train <span class="keyword">in</span> self.X_]

            <span class="comment"># 找K近邻</span>
            k_nearest_idx = np.argsort(distances)[:self.n_neighbors]
            k_nearest_labels = self.y_[k_nearest_idx]

            <span class="comment"># 投票</span>
            prediction = np.bincount(k_nearest_labels).argmax()
            predictions.append(prediction)

        <span class="keyword">return</span> np.array(predictions)

<span class="keyword">class</span> <span class="function">FuzzyKNN</span>(BaseEstimator, ClassifierMixin):
    <span class="string">"""模糊KNN实现"""</span>

    <span class="keyword">def</span> <span class="function">__init__</span>(self, n_neighbors=<span class="number">5</span>, fuzzy_strength=<span class="number">2</span>):
        self.n_neighbors = n_neighbors
        self.fuzzy_strength = fuzzy_strength  <span class="comment"># 模糊化参数m</span>

    <span class="keyword">def</span> <span class="function">fit</span>(self, X, y):
        self.X_ = X
        self.y_ = y
        self.classes_ = np.unique(y)
        self.n_classes_ = len(self.classes_)

        <span class="comment"># 初始化隶属度矩阵</span>
        self._init_membership_matrix()
        <span class="keyword">return</span> self

    <span class="keyword">def</span> <span class="function">predict_proba</span>(self, X):
        <span class="string">"""预测隶属度"""</span>
        X = check_array(X)
        n_samples = X.shape[<span class="number">0</span>]
        probas = np.zeros((n_samples, self.n_classes_))

        <span class="keyword">for</span> i, x <span class="keyword">in</span> enumerate(X):
            <span class="comment"># 计算距离</span>
            distances = np.linalg.norm(self.X_ - x, axis=<span class="number">1</span>)

            <span class="comment"># 找K近邻</span>
            k_nearest_idx = np.argsort(distances)[:self.n_neighbors]
            k_nearest_distances = distances[k_nearest_idx]

            <span class="comment"># 计算权重</span>
            weights = <span class="number">1</span> / (k_nearest_distances ** self.fuzzy_strength + <span class="number">1e-8</span>)
            weights /= weights.sum()

            <span class="comment"># 加权平均隶属度</span>
            <span class="keyword">for</span> j, (idx, w) <span class="keyword">in</span> enumerate(zip(k_nearest_idx, weights)):
                probas[i] += w * self.U_[idx]

        <span class="keyword">return</span> probas</code></pre>
        </div>
    </div>

    <!-- 4.9 模型评估 -->
    <div id="evaluation" class="section-card fade-in section-anchor">
        <h2 class="section-title">📈 4.9 模型评估与可解释性</h2>

        <div class="thinking-box">
            <h3>🤔 如何评判一个KNN模型的好坏？</h3>
            <p>评估机器学习模型就像评价一个医生的诊断能力：</p>
            <ul style="margin-left: 20px; line-height: 2;">
                <li>🎯 <span class="highlight-primary">准确率</span>：总体诊断正确的比例</li>
                <li>🔍 <span class="highlight-success">精确率</span>：诊断为有病的患者中，真正有病的比例</li>
                <li>📡 <span class="highlight-warning">召回率</span>：所有有病患者中，被正确诊断的比例</li>
                <li>⚡ <span class="highlight-danger">效率</span>：诊断速度和资源消耗</li>
            </ul>
        </div>

        <div class="formula-box">
            <h4>📊 分类评估指标体系</h4>
            <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 30px; margin: 20px 0;">
                <div>
                    <div class="math-formula">
                        <span>精确率 = </span>
                        <span class="fraction">
                            <span class="numerator">TP</span>
                            <span class="denominator">TP + FP</span>
                        </span>
                    </div>
                    <p style="text-align: center; margin-top: 10px;">预测为正例中真正正确的比例</p>
                </div>
                <div>
                    <div class="math-formula">
                        <span>召回率 = </span>
                        <span class="fraction">
                            <span class="numerator">TP</span>
                            <span class="denominator">TP + FN</span>
                        </span>
                    </div>
                    <p style="text-align: center; margin-top: 10px;">所有真正例中被找到的比例</p>
                </div>
            </div>
            <div class="math-formula" style="margin-top: 20px;">
                <span>F1分数 = 2 × </span>
                <span class="fraction">
                    <span class="numerator">精确率 × 召回率</span>
                    <span class="denominator">精确率 + 召回率</span>
                </span>
            </div>
        </div>

        <div class="code-block">
            <pre><code><span class="keyword">from</span> sklearn.metrics <span class="keyword">import</span> (
    accuracy_score, precision_score, recall_score, f1_score,
    confusion_matrix, classification_report, roc_curve, auc
)
<span class="keyword">from</span> sklearn.model_selection <span class="keyword">import</span> learning_curve, validation_curve
<span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt
<span class="keyword">import</span> seaborn <span class="keyword">as</span> sns

<span class="keyword">class</span> <span class="function">KNNEvaluator</span>:
    <span class="string">"""KNN模型评估工具"""</span>

    <span class="keyword">def</span> <span class="function">__init__</span>(self, model, X_train, y_train, X_test, y_test):
        self.model = model
        self.X_train = X_train
        self.y_train = y_train
        self.X_test = X_test
        self.y_test = y_test

    <span class="keyword">def</span> <span class="function">comprehensive_evaluation</span>(self):
        <span class="string">"""全面评估模型性能"""</span>
        <span class="comment"># 训练模型</span>
        self.model.fit(self.X_train, self.y_train)

        <span class="comment"># 预测</span>
        y_pred = self.model.predict(self.X_test)

        <span class="comment"># 计算各项指标</span>
        metrics = {
            <span class="string">'accuracy'</span>: accuracy_score(self.y_test, y_pred),
            <span class="string">'precision'</span>: precision_score(self.y_test, y_pred, average=<span class="string">'weighted'</span>),
            <span class="string">'recall'</span>: recall_score(self.y_test, y_pred, average=<span class="string">'weighted'</span>),
            <span class="string">'f1'</span>: f1_score(self.y_test, y_pred, average=<span class="string">'weighted'</span>)
        }

        <span class="keyword">print</span>(<span class="string">"=== 模型性能评估 ==="</span>)
        <span class="keyword">for</span> metric, value <span class="keyword">in</span> metrics.items():
            <span class="keyword">print</span>(f<span class="string">"{metric}: {value:.4f}"</span>)

        <span class="comment"># 详细分类报告</span>
        <span class="keyword">print</span>(<span class="string">"\n=== 分类报告 ==="</span>)
        <span class="keyword">print</span>(classification_report(self.y_test, y_pred))

        <span class="keyword">return</span> metrics, y_pred

    <span class="keyword">def</span> <span class="function">plot_confusion_matrix</span>(self, y_pred):
        <span class="string">"""绘制混淆矩阵"""</span>
        cm = confusion_matrix(self.y_test, y_pred)

        plt.figure(figsize=(<span class="number">8</span>, <span class="number">6</span>))
        sns.heatmap(cm, annot=<span class="keyword">True</span>, fmt=<span class="string">'d'</span>, cmap=<span class="string">'Blues'</span>)
        plt.title(<span class="string">'混淆矩阵'</span>)
        plt.ylabel(<span class="string">'真实标签'</span>)
        plt.xlabel(<span class="string">'预测标签'</span>)
        plt.show()

    <span class="keyword">def</span> <span class="function">explain_prediction</span>(self, sample_idx):
        <span class="string">"""解释单个预测结果"""</span>
        sample = self.X_test[sample_idx]
        true_label = self.y_test[sample_idx]

        <span class="comment"># 找到K个最近邻</span>
        distances, indices = self.model.kneighbors([sample])

        <span class="keyword">print</span>(f<span class="string">"\n=== 预测解释 (样本 {sample_idx}) ==="</span>)
        <span class="keyword">print</span>(f<span class="string">"真实标签: {true_label}"</span>)

        prediction = self.model.predict([sample])[<span class="number">0</span>]
        <span class="keyword">print</span>(f<span class="string">"预测标签: {prediction}"</span>)

        <span class="keyword">print</span>(f<span class="string">"\n最近的 {self.model.n_neighbors} 个邻居:"</span>)
        <span class="keyword">for</span> i, (dist, idx) <span class="keyword">in</span> enumerate(zip(distances[<span class="number">0</span>], indices[<span class="number">0</span>])):
            neighbor_label = self.y_train[idx]
            <span class="keyword">print</span>(f<span class="string">"  邻居 {i+1}: 距离={dist:.3f}, 标签={neighbor_label}"</span>)

        <span class="comment"># 统计投票</span>
        neighbor_labels = self.y_train[indices[<span class="number">0</span>]]
        unique, counts = np.unique(neighbor_labels, return_counts=<span class="keyword">True</span>)

        <span class="keyword">print</span>(<span class="string">"\n投票统计:"</span>)
        <span class="keyword">for</span> label, count <span class="keyword">in</span> zip(unique, counts):
            <span class="keyword">print</span>(f<span class="string">"  类别 {label}: {count} 票"</span>)

        <span class="keyword">return</span> prediction, neighbor_labels</code></pre>
        </div>

        <div class="insight-box">
            <h4>💡 KNN的可解释性优势</h4>
            <p>相比其他"黑盒"模型，KNN提供了<span class="highlight-primary">天然的可解释性</span>：</p>
            <ul style="margin-left: 20px; line-height: 2;">
                <li>🔍 <span class="highlight-success">透明度高</span>：可以查看具体的邻居</li>
                <li>📊 <span class="highlight-warning">直观理解</span>：基于相似案例的推理</li>
                <li>🎯 <span class="highlight-danger">可追溯性</span>：能够解释每个预测</li>
                <li>💡 <span class="highlight-primary">置信度量化</span>：通过邻居分布评估</li>
            </ul>
        </div>
    </div>

    <!-- 4.10 算法对比 -->
    <div id="comparison" class="section-card fade-in section-anchor">
        <h2 class="section-title">⚖️ 4.10 KNN与其他算法对比</h2>

        <div class="thinking-box">
            <h3>🤔 什么时候选择KNN？</h3>
            <p>每个算法都有其适用场景，如何选择合适的算法？</p>
            <p>让我们通过对比来理解KNN的独特价值！</p>
        </div>

        <table class="data-table">
            <thead>
            <tr>
                <th>特性</th>
                <th>KNN</th>
                <th>决策树</th>
                <th>SVM</th>
                <th>神经网络</th>
            </tr>
            </thead>
            <tbody>
            <tr>
                <td><strong>学习方式</strong></td>
                <td><span class="highlight-primary">懒惰学习</span></td>
                <td>贪心分割</td>
                <td>最大间隔</td>
                <td>反向传播</td>
            </tr>
            <tr>
                <td><strong>决策边界</strong></td>
                <td><span class="highlight-success">局部非线性</span></td>
                <td>轴平行分割</td>
                <td>全局最优</td>
                <td>高度非线性</td>
            </tr>
            <tr>
                <td><strong>训练速度</strong></td>
                <td><span class="highlight-warning">O(1) 极快</span></td>
                <td>O(n log n)</td>
                <td>O(n²~n³)</td>
                <td>O(n×epochs)</td>
            </tr>
            <tr>
                <td><strong>预测速度</strong></td>
                <td><span class="highlight-danger">O(n) 慢</span></td>
                <td>O(log d) 快</td>
                <td>O(nsv) 中等</td>
                <td>O(1) 快</td>
            </tr>
            <tr>
                <td><strong>可解释性</strong></td>
                <td><span class="highlight-primary">★★★★★</span></td>
                <td>★★★★☆</td>
                <td>★★☆☆☆</td>
                <td>★☆☆☆☆</td>
            </tr>
            <tr>
                <td><strong>参数调优</strong></td>
                <td><span class="highlight-success">简单(K值)</span></td>
                <td>中等</td>
                <td>复杂(C,γ)</td>
                <td>很复杂</td>
            </tr>
            <tr>
                <td><strong>数据要求</strong></td>
                <td>中等</td>
                <td>少量即可</td>
                <td>中等</td>
                <td>大量数据</td>
            </tr>
            <tr>
                <td><strong>噪声鲁棒性</strong></td>
                <td><span class="highlight-warning">较差(K=1时)</span></td>
                <td>中等</td>
                <td>较好</td>
                <td>较好</td>
            </tr>
            </tbody>
        </table>

        <div class="comparison-grid" style="margin-top: 30px;">
            <div class="comparison-item">
                <div class="comparison-header">
                    <div class="comparison-icon">✅</div>
                    <div class="comparison-title">KNN的优势场景</div>
                </div>
                <p>📊 <strong>低维数据</strong>（d < 20）</p>
                <p>🎯 <strong>局部模式明显</strong></p>
                <p>💡 <strong>需要可解释性</strong></p>
                <p>🔄 <strong>数据动态更新</strong></p>
                <p>📈 <strong>非线性边界</strong></p>
            </div>
            <div class="comparison-item">
                <div class="comparison-header">
                    <div class="comparison-icon">❌</div>
                    <div class="comparison-title">不适合KNN的场景</div>
                </div>
                <p>📐 <strong>高维稀疏数据</strong></p>
                <p>💾 <strong>海量数据集</strong></p>
                <p>⚡ <strong>实时预测需求</strong></p>
                <p>🎲 <strong>噪声数据多</strong></p>
                <p>📱 <strong>移动端部署</strong></p>
            </div>
        </div>

        <!-- 算法选择决策树 -->
        <div class="decision-boundary">
            <h4 style="text-align: center; color: var(--knn-purple); margin-bottom: 20px;">🎯 算法选择决策指南</h4>
            <div style="background: var(--bg-card); padding: 30px; border-radius: 15px;">
                <pre style="color: var(--text-primary); font-family: monospace; line-height: 2;">
数据集规模？
├─ 小（<1000样本）
│  └─ 需要可解释性？
│     ├─ 是 → <span class="highlight-primary">KNN</span> 或 决策树
│     └─ 否 → SVM
├─ 中（1000-10000）
│  └─ 特征维度？
│     ├─ 低（<20） → <span class="highlight-primary">KNN</span>
│     └─ 高（>20） → SVM 或 随机森林
└─ 大（>10000）
   └─ 计算资源充足？
      ├─ 是 → 神经网络
      └─ 否 → 需要近似？
         ├─ 是 → <span class="highlight-warning">近似KNN</span>（LSH）
         └─ 否 → 线性模型
                </pre>
            </div>
        </div>
    </div>

    <!-- 4.11 实战案例 -->
    <div id="practice" class="section-card fade-in section-anchor">
        <h2 class="section-title">💻 4.11 实战案例：手写数字识别</h2>

        <div class="case-study">
            <h3>🎯 项目背景</h3>
            <p>手写数字识别是计算机视觉的经典问题，广泛应用于：</p>
            <ul style="margin-left: 20px; line-height: 2;">
                <li>📮 邮政编码识别</li>
                <li>🏦 银行支票处理</li>
                <li>📝 表单数字化</li>
                <li>📱 手写输入法</li>
            </ul>
            <p>我们将使用KNN在MNIST数据集上实现一个完整的手写数字识别系统。</p>
        </div>

        <div class="code-block">
            <pre><code><span class="keyword">from</span> sklearn.datasets <span class="keyword">import</span> load_digits
<span class="keyword">from</span> sklearn.model_selection <span class="keyword">import</span> train_test_split, GridSearchCV
<span class="keyword">from</span> sklearn.preprocessing <span class="keyword">import</span> StandardScaler
<span class="keyword">from</span> sklearn.decomposition <span class="keyword">import</span> PCA
<span class="keyword">from</span> sklearn.metrics <span class="keyword">import</span> classification_report, confusion_matrix
<span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt
<span class="keyword">import</span> numpy <span class="keyword">as</span> np

<span class="keyword">class</span> <span class="function">HandwritingRecognizer</span>:
    <span class="string">"""手写数字识别系统"""</span>

    <span class="keyword">def</span> <span class="function">__init__</span>(self):
        self.scaler = StandardScaler()
        self.pca = PCA(n_components=<span class="number">0.95</span>)  <span class="comment"># 保留95%的方差</span>
        self.knn = <span class="keyword">None</span>
        self.best_params = <span class="keyword">None</span>

    <span class="keyword">def</span> <span class="function">load_and_prepare_data</span>(self):
        <span class="string">"""加载并准备数据"""</span>
        <span class="comment"># 加载数据</span>
        digits = load_digits()
        X, y = digits.data, digits.target

        <span class="keyword">print</span>(f<span class="string">"数据集形状: {X.shape}"</span>)
        <span class="keyword">print</span>(f<span class="string">"类别数量: {len(np.unique(y))}"</span>)

        <span class="comment"># 可视化一些样本</span>
        self._visualize_samples(digits.images[:<span class="number">10</span>], y[:<span class="number">10</span>])

        <span class="comment"># 划分数据集</span>
        X_train, X_test, y_train, y_test = train_test_split(
            X, y, test_size=<span class="number">0.2</span>, random_state=<span class="number">42</span>, stratify=y
        )

        <span class="keyword">return</span> X_train, X_test, y_train, y_test

    <span class="keyword">def</span> <span class="function">_visualize_samples</span>(self, images, labels):
        <span class="string">"""可视化手写数字样本"""</span>
        fig, axes = plt.subplots(<span class="number">2</span>, <span class="number">5</span>, figsize=(<span class="number">12</span>, <span class="number">5</span>))
        axes = axes.ravel()

        <span class="keyword">for</span> i, (image, label) <span class="keyword">in</span> enumerate(zip(images, labels)):
            axes[i].imshow(image, cmap=<span class="string">'gray'</span>)
            axes[i].set_title(f<span class="string">'标签: {label}'</span>)
            axes[i].axis(<span class="string">'off'</span>)

        plt.suptitle(<span class="string">'手写数字样本'</span>)
        plt.tight_layout()
        plt.show()

    <span class="keyword">def</span> <span class="function">preprocess_data</span>(self, X_train, X_test):
        <span class="string">"""数据预处理"""</span>
        <span class="comment"># 标准化</span>
        X_train_scaled = self.scaler.fit_transform(X_train)
        X_test_scaled = self.scaler.transform(X_test)

        <span class="comment"># PCA降维</span>
        X_train_pca = self.pca.fit_transform(X_train_scaled)
        X_test_pca = self.pca.transform(X_test_scaled)

        <span class="keyword">print</span>(f<span class="string">"\nPCA降维后的特征数: {X_train_pca.shape[1]}"</span>)
        <span class="keyword">print</span>(f<span class="string">"解释方差比: {self.pca.explained_variance_ratio_.sum():.4f}"</span>)

        <span class="keyword">return</span> X_train_pca, X_test_pca

    <span class="keyword">def</span> <span class="function">optimize_hyperparameters</span>(self, X_train, y_train):
        <span class="string">"""超参数优化"""</span>
        <span class="keyword">print</span>(<span class="string">"\n开始超参数优化..."</span>)

        param_grid = {
            <span class="string">'n_neighbors'</span>: [<span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">9</span>],
            <span class="string">'weights'</span>: [<span class="string">'uniform'</span>, <span class="string">'distance'</span>],
            <span class="string">'metric'</span>: [<span class="string">'euclidean'</span>, <span class="string">'manhattan'</span>]
        }

        knn = KNeighborsClassifier()
        grid_search = GridSearchCV(
            knn, param_grid, cv=<span class="number">5</span>,
            scoring=<span class="string">'accuracy'</span>, n_jobs=-<span class="number">1</span>, verbose=<span class="number">1</span>
        )

        grid_search.fit(X_train, y_train)

        self.best_params = grid_search.best_params_
        self.knn = grid_search.best_estimator_

        <span class="keyword">print</span>(f<span class="string">"\n最佳参数: {self.best_params}"</span>)
        <span class="keyword">print</span>(f<span class="string">"交叉验证最佳分数: {grid_search.best_score_:.4f}"</span>)

        <span class="keyword">return</span> self.knn

    <span class="keyword">def</span> <span class="function">evaluate_model</span>(self, X_test, y_test):
        <span class="string">"""评估模型性能"""</span>
        y_pred = self.knn.predict(X_test)
        accuracy = self.knn.score(X_test, y_test)

        <span class="keyword">print</span>(f<span class="string">"\n测试集准确率: {accuracy:.4f}"</span>)

        <span class="comment"># 详细分类报告</span>
        <span class="keyword">print</span>(<span class="string">"\n分类报告:"</span>)
        <span class="keyword">print</span>(classification_report(y_test, y_pred))

        <span class="comment"># 混淆矩阵</span>
        self._plot_confusion_matrix(y_test, y_pred)

        <span class="comment"># 错误案例分析</span>
        self._analyze_errors(X_test, y_test, y_pred)</code></pre>
        </div>

        <!-- 实战结果展示 -->
        <div class="experiment-chart">
            <h4 class="chart-title">🎯 模型性能表现</h4>
            <div class="result-card" style="margin-top: 20px;">
                <h5 style="color: var(--knn-purple);">关键性能指标</h5>
                <div style="display: grid; grid-template-columns: repeat(4, 1fr); gap: 20px; margin-top: 20px;">
                    <div style="text-align: center;">
                        <div style="font-size: 2rem; color: var(--knn-purple); font-weight: bold;">97.2%</div>
                        <div style="color: var(--text-muted);">准确率</div>
                    </div>
                    <div style="text-align: center;">
                        <div style="font-size: 2rem; color: var(--knn-blue); font-weight: bold;">0.03s</div>
                        <div style="color: var(--text-muted);">单张预测时间</div>
                    </div>
                    <div style="text-align: center;">
                        <div style="font-size: 2rem; color: var(--knn-pink); font-weight: bold;">30</div>
                        <div style="color: var(--text-muted);">PCA维度</div>
                    </div>
                    <div style="text-align: center;">
                        <div style="font-size: 2rem; color: var(--knn-orange); font-weight: bold;">K=5</div>
                        <div style="color: var(--text-muted);">最优邻居数</div>
                    </div>
                </div>
            </div>
        </div>

        <div class="insight-box">
            <h4>💡 实战经验总结</h4>
            <ul style="margin-left: 20px; line-height: 2;">
                <li>📊 <span class="highlight-primary">数据预处理是关键</span>：标准化+PCA大幅提升性能</li>
                <li>🔧 <span class="highlight-success">参数优化很重要</span>：K=5在该数据集上表现最佳</li>
                <li>📈 <span class="highlight-warning">错误分析有价值</span>：易混淆的数字对（如4和9）</li>
                <li>⚡ <span class="highlight-danger">权衡精度与速度</span>：PCA降维平衡了两者</li>
            </ul>
        </div>
    </div>

    <!-- 4.12 高级应用 -->
    <div id="advanced" class="section-card fade-in section-anchor">
        <h2 class="section-title">🚀 4.12 高级应用与前沿进展</h2>

        <div class="thinking-box">
            <h3>🤔 KNN的未来在哪里？</h3>
            <p>虽然KNN是一个"古老"的算法，但在现代机器学习中仍有重要地位：</p>
            <ul style="margin-left: 20px; line-height: 2;">
                <li>🔍 与深度学习结合的<span class="highlight-primary">度量学习</span></li>
                <li>🌐 大规模分布式<span class="highlight-success">近似最近邻搜索</span></li>
                <li>🎯 多模态数据的<span class="highlight-warning">跨域检索</span></li>
                <li>🤖 可解释AI中的<span class="highlight-danger">案例推理</span></li>
            </ul>
        </div>

        <div class="algorithm-variant">
            <h4>🧠 深度KNN（Deep KNN）</h4>
            <p><strong>核心思想：</strong>使用深度学习提取特征，KNN进行分类</p>
            <div style="background: rgba(124, 58, 237, 0.1); padding: 20px; border-radius: 10px; margin: 15px 0;">
                <p>1. 预训练CNN提取特征</p>
                <p>2. 特征空间中应用KNN</p>
                <p>3. 结合深度特征和可解释性</p>
            </div>
            <p><strong>应用：</strong>图像检索、人脸识别、异常检测</p>
        </div>

        <div class="algorithm-variant">
            <h4>🌍 分布式KNN</h4>
            <p><strong>挑战：</strong>如何在TB级数据上快速找到最近邻？</p>
            <p><strong>解决方案：</strong></p>
            <ul style="margin-left: 20px;">
                <li>MapReduce框架并行计算</li>
                <li>分布式哈希表（DHT）</li>
                <li>向量数据库（Milvus、Faiss）</li>
            </ul>
        </div>

        <div class="code-block">
            <pre><code><span class="keyword">import</span> torch
<span class="keyword">import</span> torch.nn <span class="keyword">as</span> nn
<span class="keyword">import</span> torchvision.models <span class="keyword">as</span> models
<span class="keyword">import</span> numpy <span class="keyword">as</span> np

<span class="keyword">class</span> <span class="function">DeepKNN</span>:
    <span class="string">"""深度特征提取 + KNN分类"""</span>

    <span class="keyword">def</span> <span class="function">__init__</span>(self, backbone=<span class="string">'resnet50'</span>, n_neighbors=<span class="number">5</span>):
        <span class="comment"># 加载预训练模型</span>
        <span class="keyword">if</span> backbone == <span class="string">'resnet50'</span>:
            self.feature_extractor = models.resnet50(pretrained=<span class="keyword">True</span>)
            <span class="comment"># 移除最后的分类层</span>
            self.feature_extractor = nn.Sequential(
                *list(self.feature_extractor.children())[:-<span class="number">1</span>]
            )
            self.feature_dim = <span class="number">2048</span>

        self.feature_extractor.eval()
        self.n_neighbors = n_neighbors
        self.feature_database = <span class="keyword">None</span>
        self.label_database = <span class="keyword">None</span>

    <span class="keyword">def</span> <span class="function">extract_features</span>(self, images):
        <span class="string">"""提取深度特征"""</span>
        <span class="keyword">with</span> torch.no_grad():
            features = self.feature_extractor(images)
            features = features.view(features.size(<span class="number">0</span>), -<span class="number">1</span>)
        <span class="keyword">return</span> features.numpy()

    <span class="keyword">def</span> <span class="function">fit</span>(self, train_loader):
        <span class="string">"""构建特征数据库"""</span>
        all_features = []
        all_labels = []

        <span class="keyword">for</span> images, labels <span class="keyword">in</span> train_loader:
            features = self.extract_features(images)
            all_features.append(features)
            all_labels.extend(labels.numpy())

        self.feature_database = np.vstack(all_features)
        self.label_database = np.array(all_labels)

        <span class="comment"># 使用Faiss构建索引（可选）</span>
        <span class="keyword">try</span>:
            <span class="keyword">import</span> faiss
            self.index = faiss.IndexFlatL2(self.feature_dim)
            self.index.add(self.feature_database)
            self.use_faiss = <span class="keyword">True</span>
        <span class="keyword">except</span>:
            self.use_faiss = <span class="keyword">False</span>

    <span class="keyword">def</span> <span class="function">predict</span>(self, images):
        <span class="string">"""使用KNN预测"""</span>
        features = self.extract_features(images)

        <span class="keyword">if</span> self.use_faiss:
            <span class="comment"># 使用Faiss加速搜索</span>
            distances, indices = self.index.search(features, self.n_neighbors)
        <span class="keyword">else</span>:
            <span class="comment"># 暴力搜索</span>
            <span class="keyword">from</span> sklearn.neighbors <span class="keyword">import</span> NearestNeighbors
            nbrs = NearestNeighbors(n_neighbors=self.n_neighbors)
            nbrs.fit(self.feature_database)
            distances, indices = nbrs.kneighbors(features)

        <span class="comment"># 投票预测</span>
        predictions = []
        <span class="keyword">for</span> idx <span class="keyword">in</span> indices:
            neighbor_labels = self.label_database[idx]
            pred = np.bincount(neighbor_labels).argmax()
            predictions.append(pred)

        <span class="keyword">return</span> np.array(predictions)</code></pre>
        </div>

        <div class="deep-thinking">
            <h3>🧠 深度思考：KNN的哲学意义</h3>
            <p><strong>1. 相似性的本质是什么？</strong></p>
            <p>KNN假设相似的事物有相似的属性，但"相似"本身就是一个深刻的哲学问题。在不同的文化、语境下，相似性的定义可能完全不同。</p>

            <p><strong>2. 局部性原理的普适性</strong></p>
            <p>KNN体现了局部性原理——空间中相近的点往往属于同一类。这个原理在物理世界普遍存在，但在高维抽象空间是否仍然成立？</p>

            <p><strong>3. 记忆与泛化的平衡</strong></p>
            <p>KNN完全"记住"训练数据，这是优势还是劣势？人类的学习也是在记忆具体案例和抽象泛化之间寻找平衡。</p>
        </div>

        <div class="pro-tip">
            <p><strong>前沿研究方向：</strong></p>
            <ul style="margin-left: 20px; line-height: 2;">
                <li>🔬 <span class="highlight-primary">度量学习</span>：自动学习最优距离度量</li>
                <li>🌐 <span class="highlight-success">图神经网络中的KNN</span>：构建动态邻居图</li>
                <li>🤖 <span class="highlight-warning">持续学习</span>：增量式更新KNN模型</li>
                <li>🎯 <span class="highlight-danger">对抗鲁棒性</span>：提高KNN抗攻击能力</li>
            </ul>
        </div>
    </div>

    <!-- 4.13 总结与展望 -->
    <div id="summary" class="section-card fade-in section-anchor">
        <h2 class="section-title">🎓 4.13 总结与展望</h2>

        <div class="thinking-box">
            <h3>🤔 回到最初的问题</h3>
            <p>还记得我们开头的房价评估问题吗？现在你已经学完了KNN算法，让我们重新思考：</p>
            <ul style="margin-left: 20px; line-height: 2;">
                <li>🏠 <span class="highlight-primary">相似房子</span> = 最近邻居</li>
                <li>📏 <span class="highlight-success">特征比较</span> = 距离计算</li>
                <li>🔍 <span class="highlight-warning">选择几套</span> = K值选择</li>
                <li>💰 <span class="highlight-danger">参考定价</span> = 加权平均/投票</li>
            </ul>
            <p><strong>现在的你，是否能更深刻地理解KNN的本质？</strong></p>
        </div>

        <div class="mind-map">
            <div class="mind-node">
                <h4>🧠 核心思想</h4>
                <p><span class="highlight-primary">"近朱者赤，近墨者黑"</span></p>
                <p>相似样本应有相似标签</p>
                <p>基于案例的推理</p>
            </div>
            <div class="mind-node">
                <h4>🔍 算法本质</h4>
                <p><span class="highlight-success">懒惰学习</span>：存储所有数据</p>
                <p><span class="highlight-warning">非参数化</span>：不假设分布</p>
                <p><span class="highlight-danger">局部建模</span>：关注邻域</p>
            </div>
            <div class="mind-node">
                <h4>⚙️ 关键要素</h4>
                <p><span class="highlight-danger">K值</span>：邻居数量</p>
                <p><span class="highlight-primary">距离</span>：相似性度量</p>
                <p><span class="highlight-success">权重</span>：影响程度</p>
            </div>
            <div class="mind-node">
                <h4>📊 实践要点</h4>
                <p><span class="highlight-success">数据预处理</span>：必不可少</p>
                <p><span class="highlight-warning">参数调优</span>：网格搜索</p>
                <p><span class="highlight-danger">可解释性</span>：天然优势</p>
            </div>
        </div>

        <!-- 知识总结表 -->
        <div class="summary-card">
            <div class="summary-content">
                <h3 style="font-size: 2rem; margin-bottom: 30px;">🎯 KNN算法知识图谱</h3>
                <div style="display: grid; grid-template-columns: repeat(3, 1fr); gap: 30px;">
                    <div>
                        <h4 style="color: #fbbf24; margin-bottom: 15px;">理论基础</h4>
                        <p>✓ 实例学习理论</p>
                        <p>✓ 贝叶斯决策理论</p>
                        <p>✓ Cover-Hart定理</p>
                        <p>✓ 维数灾难</p>
                    </div>
                    <div>
                        <h4 style="color: #10b981; margin-bottom: 15px;">核心技术</h4>
                        <p>✓ 距离度量方法</p>
                        <p>✓ 加速数据结构</p>
                        <p>✓ 特征工程</p>
                        <p>✓ 参数优化</p>
                    </div>
                    <div>
                        <h4 style="color: #ec4899; margin-bottom: 15px;">应用领域</h4>
                        <p>✓ 推荐系统</p>
                        <p>✓ 图像识别</p>
                        <p>✓ 异常检测</p>
                        <p>✓ 文本分类</p>
                    </div>
                </div>
            </div>
        </div>

        <div class="exercise-box">
            <h3>✍️ 练习与思考</h3>
            <ol style="margin-left: 20px; line-height: 2.5;">
                <li><strong>算法理解：</strong>为什么说KNN是"最符合人类直觉"的算法？</li>
                <li><strong>参数影响：</strong>K值从1增加到n（样本总数）的过程中，决策边界如何变化？</li>
                <li><strong>距离选择：</strong>对于文本数据，为什么余弦距离比欧式距离更合适？</li>
                <li><strong>优化思考：</strong>如果要在移动设备上部署KNN，你会如何优化？</li>
                <li><strong>算法改进：</strong>设计一个自适应K值的KNN变体，K随数据密度变化。</li>
                <li><strong>实际应用：</strong>用KNN实现一个简单的音乐推荐系统。</li>
            </ol>
        </div>

        <div class="deep-thinking">
            <h3>🧠 深入思考</h3>
            <p><strong>KNN vs 人类认知：</strong></p>
            <p>人类在做决策时，真的是简单地参考"最近的K个案例"吗？还是有更复杂的机制？</p>
            <ul style="margin-left: 20px; line-height: 2; margin-top: 15px;">
                <li>人类会根据情境<span class="highlight-primary">动态调整K值</span></li>
                <li>不同特征的<span class="highlight-success">重要性会变化</span></li>
                <li>会考虑<span class="highlight-warning">时间因素</span>（最近的经验更重要）</li>
                <li>有<span class="highlight-danger">抽象和泛化</span>的能力</li>
            </ul>
            <p style="margin-top: 20px;">这些差异启发我们：机器学习不是简单地模仿人类，而是用数学方法实现智能行为。</p>
        </div>

        <div style="text-align: center; margin: 50px 0;">
            <div style="background: linear-gradient(135deg, var(--knn-purple), var(--knn-blue)); color: white; padding: 40px; border-radius: 20px; display: inline-block; box-shadow: 0 20px 40px rgba(124, 58, 237, 0.3); max-width: 800px;">
                <h3 style="font-size: 2.5rem; margin-bottom: 20px;">🎉 恭喜完成KNN算法学习！</h3>
                <p style="font-size: 1.2rem; line-height: 1.8; margin-bottom: 30px;">
                    从基础概念到实战应用，从数学原理到代码实现<br>
                    你已经全面掌握了这个最直观的机器学习算法<br>
                    KNN的简单中蕴含着深刻的智慧
                </p>
                <div style="display: flex; justify-content: center; gap: 20px; flex-wrap: wrap;">
                    <button class="demo-btn" onclick="downloadNotes()" style="background: rgba(255,255,255,0.2); padding: 15px 30px; font-size: 1rem;">
                        📥 下载学习笔记
                    </button>
                    <button class="demo-btn" onclick="startQuiz()" style="background: rgba(255,255,255,0.2); padding: 15px 30px; font-size: 1rem;">
                        🧠 开始知识测验
                    </button>
                    <button class="demo-btn" onclick="shareProgress()" style="background: rgba(255,255,255,0.2); padding: 15px 30px; font-size: 1rem;">
                        📤 分享学习成果
                    </button>
                </div>
            </div>
        </div>

        <div class="version-info">
            <p>第4章 KNN算法 | 版本 2.0 | 最后更新：2024</p>
            <p>下一章预告：决策树 - 如何让机器学会"如果...那么..."的逻辑推理</p>
        </div>
    </div>
</div>

<!-- 浮动工具栏 -->
<div class="floating-toolbar">
    <button class="toolbar-btn theme-toggle-btn" onclick="toggleTheme()" title="切换主题">
        <span class="theme-icon">🌓</span>
    </button>
    <button class="toolbar-btn" onclick="scrollToTop()" title="回到顶部">
        <span>⬆️</span>
    </button>
</div>

<script>
    // JavaScript代码
    (function() {
        'use strict';

        // 主题切换
        function toggleTheme() {
            document.body.classList.toggle('light-theme');
            const isLight = document.body.classList.contains('light-theme');
            localStorage.setItem('theme', isLight ? 'light' : 'dark');
            updateThemeIcon();
        }

        function updateThemeIcon() {
            const icon = document.querySelector('.theme-icon');
            const isLight = document.body.classList.contains('light-theme');
            icon.textContent = isLight ? '🌞' : '🌓';
        }

        // 导航切换
        function toggleNav() {
            document.body.classList.toggle('nav-open');
        }

        // 滚动到顶部
        function scrollToTop() {
            window.scrollTo({
                top: 0,
                behavior: 'smooth'
            });
        }

        // 进度更新
        function updateProgress() {
            const sections = document.querySelectorAll('.section-card');
            const windowHeight = window.innerHeight;
            const scrollTop = window.scrollY;
            const documentHeight = document.documentElement.scrollHeight;

            let completedSections = 0;
            sections.forEach((section, index) => {
                const rect = section.getBoundingClientRect();
                const sectionCenter = rect.top + rect.height / 2;

                if (sectionCenter < windowHeight * 0.7) {
                    completedSections++;
                    const navItem = document.querySelector(`.nav-item:nth-child(${index + 1})`);
                    if (navItem) {
                        navItem.classList.add('completed');
                    }
                }
            });

            // 更新进度
            const progress = Math.min((scrollTop / (documentHeight - windowHeight)) * 100, 100);
            const progressFill = document.getElementById('progressFill');
            const progressText = document.getElementById('progressText');
            const progressRing = document.getElementById('progressRing');
            const progressPercent = document.getElementById('progressPercent');

            if (progressFill) progressFill.style.width = progress + '%';
            if (progressText) progressText.textContent = Math.round(progress) + '%';
            if (progressPercent) progressPercent.textContent = Math.round(progress) + '%';

            // 更新进度环
            if (progressRing) {
                const circumference = 2 * Math.PI * 22;
                const offset = circumference - (progress / 100) * circumference;
                progressRing.style.strokeDashoffset = offset;
            }

            // 更新统计
            const completedSectionsEl = document.getElementById('completedSections');
            if (completedSectionsEl) {
                completedSectionsEl.textContent = `${completedSections}/${sections.length}`;
            }
        }

        // 高亮当前章节
        function highlightCurrentSection() {
            const sections = document.querySelectorAll('.section-card');
            const navItems = document.querySelectorAll('.nav-item');

            let currentSection = null;
            sections.forEach((section) => {
                const rect = section.getBoundingClientRect();
                if (rect.top <= 100 && rect.bottom > 100) {
                    currentSection = section.id;
                }
            });

            navItems.forEach(item => {
                item.classList.remove('active');
                if (currentSection && item.dataset.section === currentSection) {
                    item.classList.add('active');
                }
            });
        }

        // 动态背景动画
        function initBackground() {
            const canvas = document.getElementById('knnNodesBg');
            if (!canvas) return;

            const ctx = canvas.getContext('2d');
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;

            const nodes = [];
            const nodeCount = 50;

            // 创建节点
            for (let i = 0; i < nodeCount; i++) {
                nodes.push({
                    x: Math.random() * canvas.width,
                    y: Math.random() * canvas.height,
                    vx: (Math.random() - 0.5) * 0.5,
                    vy: (Math.random() - 0.5) * 0.5,
                    radius: Math.random() * 3 + 1
                });
            }

            function animate() {
                ctx.clearRect(0, 0, canvas.width, canvas.height);

                // 更新和绘制节点
                nodes.forEach((node, i) => {
                    // 更新位置
                    node.x += node.vx;
                    node.y += node.vy;

                    // 边界反弹
                    if (node.x < 0 || node.x > canvas.width) node.vx *= -1;
                    if (node.y < 0 || node.y > canvas.height) node.vy *= -1;

                    // 绘制节点
                    ctx.beginPath();
                    ctx.arc(node.x, node.y, node.radius, 0, Math.PI * 2);
                    ctx.fillStyle = 'rgba(124, 58, 237, 0.5)';
                    ctx.fill();

                    // 连接最近的K个节点
                    const k = 3;
                    const distances = nodes.map((other, j) => ({
                        index: j,
                        distance: Math.sqrt(Math.pow(node.x - other.x, 2) + Math.pow(node.y - other.y, 2))
                    }));

                    distances.sort((a, b) => a.distance - b.distance);

                    for (let j = 1; j <= k && j < distances.length; j++) {
                        const other = nodes[distances[j].index];
                        const opacity = Math.max(0, 1 - distances[j].distance / 200);

                        ctx.beginPath();
                        ctx.moveTo(node.x, node.y);
                        ctx.lineTo(other.x, other.y);
                        ctx.strokeStyle = `rgba(102, 126, 234, ${opacity * 0.2})`;
                        ctx.stroke();
                    }
                });

                requestAnimationFrame(animate);
            }

            animate();

            // 窗口大小调整
            window.addEventListener('resize', () => {
                canvas.width = window.innerWidth;
                canvas.height = window.innerHeight;
            });
        }

        // 距离演示可视化
        function initDistanceDemo() {
            const canvas = document.getElementById('distanceDemo');
            if (!canvas) return;

            const ctx = canvas.getContext('2d');
            let point1 = { x: 200, y: 200 };
            let point2 = { x: 600, y: 200 };
            let selectedPoint = null;
            let distanceType = 'euclidean';

            function draw() {
                ctx.clearRect(0, 0, canvas.width, canvas.height);

                // 绘制网格
                ctx.strokeStyle = 'rgba(124, 58, 237, 0.1)';
                ctx.lineWidth = 1;
                for (let i = 0; i < canvas.width; i += 40) {
                    ctx.beginPath();
                    ctx.moveTo(i, 0);
                    ctx.lineTo(i, canvas.height);
                    ctx.stroke();
                }
                for (let i = 0; i < canvas.height; i += 40) {
                    ctx.beginPath();
                    ctx.moveTo(0, i);
                    ctx.lineTo(canvas.width, i);
                    ctx.stroke();
                }

                // 绘制等距离线
                drawDistanceContours();

                // 绘制点
                drawPoint(point1, '#667eea', '点A');
                drawPoint(point2, '#ec4899', '点B');

                // 显示距离
                const distance = calculateDistance(point1, point2, distanceType);
                document.getElementById('distanceResult').innerHTML =
                    `距离: <span style="color: var(--knn-purple)">${distance.toFixed(2)}</span>`;
            }

            function drawPoint(point, color, label) {
                ctx.beginPath();
                ctx.arc(point.x, point.y, 10, 0, Math.PI * 2);
                ctx.fillStyle = color;
                ctx.fill();

                ctx.fillStyle = 'white';
                ctx.font = 'bold 12px Arial';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText(label, point.x, point.y);
            }

            function drawDistanceContours() {
                const distances = [50, 100, 150, 200];

                distances.forEach((d, i) => {
                    ctx.strokeStyle = `rgba(124, 58, 237, ${0.1 + i * 0.05})`;
                    ctx.lineWidth = 2;

                    if (distanceType === 'euclidean') {
                        ctx.beginPath();
                        ctx.arc(point1.x, point1.y, d, 0, Math.PI * 2);
                        ctx.stroke();
                    } else if (distanceType === 'manhattan') {
                        ctx.beginPath();
                        ctx.moveTo(point1.x + d, point1.y);
                        ctx.lineTo(point1.x, point1.y + d);
                        ctx.lineTo(point1.x - d, point1.y);
                        ctx.lineTo(point1.x, point1.y - d);
                        ctx.closePath();
                        ctx.stroke();
                    } else if (distanceType === 'chebyshev') {
                        ctx.strokeRect(point1.x - d, point1.y - d, d * 2, d * 2);
                    }
                });
            }

            function calculateDistance(p1, p2, type) {
                const dx = Math.abs(p1.x - p2.x);
                const dy = Math.abs(p1.y - p2.y);

                switch(type) {
                    case 'euclidean':
                        return Math.sqrt(dx * dx + dy * dy);
                    case 'manhattan':
                        return dx + dy;
                    case 'chebyshev':
                        return Math.max(dx, dy);
                    default:
                        return 0;
                }
            }

            // 鼠标事件
            canvas.addEventListener('mousedown', (e) => {
                const rect = canvas.getBoundingClientRect();
                const x = e.clientX - rect.left;
                const y = e.clientY - rect.top;

                const d1 = Math.sqrt(Math.pow(x - point1.x, 2) + Math.pow(y - point1.y, 2));
                const d2 = Math.sqrt(Math.pow(x - point2.x, 2) + Math.pow(y - point2.y, 2));

                if (d1 < 20) {
                    selectedPoint = point1;
                } else if (d2 < 20) {
                    selectedPoint = point2;
                }
            });

            canvas.addEventListener('mousemove', (e) => {
                if (selectedPoint) {
                    const rect = canvas.getBoundingClientRect();
                    selectedPoint.x = e.clientX - rect.left;
                    selectedPoint.y = e.clientY - rect.top;
                    draw();
                }
            });

            canvas.addEventListener('mouseup', () => {
                selectedPoint = null;
            });

            // 控制函数
            window.changeDistance = function() {
                distanceType = document.getElementById('distanceSelect').value;
                draw();
            };

            window.resetDistance = function() {
                point1 = { x: 200, y: 200 };
                point2 = { x: 600, y: 200 };
                draw();
            };

            window.animateDistance = function() {
                let angle = 0;
                const radius = 150;
                const centerX = 400;
                const centerY = 200;

                const animate = () => {
                    angle += 0.02;
                    point2.x = centerX + Math.cos(angle) * radius;
                    point2.y = centerY + Math.sin(angle) * radius;
                    draw();

                    if (angle < Math.PI * 2) {
                        requestAnimationFrame(animate);
                    }
                };

                animate();
            };

            draw();
        }

        // KNN算法演示
        function initKNNDemo() {
            const canvas = document.getElementById('knnDemo');
            if (!canvas) return;

            const ctx = canvas.getContext('2d');
            let k = 5;
            let queryPoint = null;
            let dataPoints = [];

            // 生成示例数据
            function generateData() {
                dataPoints = [];

                // 生成两类数据
                for (let i = 0; i < 30; i++) {
                    dataPoints.push({
                        x: Math.random() * 300 + 50,
                        y: Math.random() * 200 + 50,
                        class: 0
                    });
                }

                for (let i = 0; i < 30; i++) {
                    dataPoints.push({
                        x: Math.random() * 300 + 450,
                        y: Math.random() * 200 + 250,
                        class: 1
                    });
                }
            }

            function draw() {
                ctx.clearRect(0, 0, canvas.width, canvas.height);

                // 绘制数据点
                dataPoints.forEach(point => {
                    ctx.beginPath();
                    ctx.arc(point.x, point.y, 8, 0, Math.PI * 2);
                    ctx.fillStyle = point.class === 0 ? '#667eea' : '#ec4899';
                    ctx.fill();
                    ctx.strokeStyle = 'white';
                    ctx.lineWidth = 2;
                    ctx.stroke();
                });

                // 如果有查询点，执行KNN
                if (queryPoint) {
                    performKNN();
                }
            }

            function performKNN() {
                // 计算距离
                const distances = dataPoints.map(point => ({
                    point: point,
                    distance: Math.sqrt(Math.pow(point.x - queryPoint.x, 2) +
                        Math.pow(point.y - queryPoint.y, 2))
                }));

                // 排序并选择K个最近邻
                distances.sort((a, b) => a.distance - b.distance);
                const kNearest = distances.slice(0, k);

                // 绘制连线
                kNearest.forEach((item, index) => {
                    ctx.beginPath();
                    ctx.moveTo(queryPoint.x, queryPoint.y);
                    ctx.lineTo(item.point.x, item.point.y);
                    ctx.strokeStyle = `rgba(124, 58, 237, ${0.5 - index * 0.05})`;
                    ctx.lineWidth = 3 - index * 0.2;
                    ctx.stroke();
                });

                // 统计投票
                const votes = { 0: 0, 1: 0 };
                kNearest.forEach(item => {
                    votes[item.point.class]++;
                });

                const predictedClass = votes[0] > votes[1] ? 0 : 1;

                // 绘制查询点
                ctx.beginPath();
                ctx.arc(queryPoint.x, queryPoint.y, 12, 0, Math.PI * 2);
                ctx.fillStyle = predictedClass === 0 ? '#667eea' : '#ec4899';
                ctx.fill();
                ctx.strokeStyle = '#fbbf24';
                ctx.lineWidth = 4;
                ctx.stroke();

                // 显示结果
                document.getElementById('knnResult').innerHTML =
                    `预测类别: <span style="color: ${predictedClass === 0 ? '#667eea' : '#ec4899'}">
                ${predictedClass === 0 ? '蓝色' : '粉色'}</span>
                (投票: 蓝色 ${votes[0]}, 粉色 ${votes[1]})`;
            }

            // 鼠标点击事件
            canvas.addEventListener('click', (e) => {
                const rect = canvas.getBoundingClientRect();
                queryPoint = {
                    x: e.clientX - rect.left,
                    y: e.clientY - rect.top
                };
                draw();
            });

            // 控制函数
            window.changeK = function(newK) {
                k = newK;
                draw();
            };

            window.generateNewData = function() {
                generateData();
                draw();
            };

            window.clearQuery = function() {
                queryPoint = null;
                document.getElementById('knnResult').innerHTML = '';
                draw();
            };

            window.toggleAnimation = function() {
                // 动画演示KNN过程
                if (!queryPoint) {
                    queryPoint = { x: 400, y: 250 };
                }

                let currentK = 1;
                const animateK = () => {
                    k = currentK;
                    draw();
                    currentK++;

                    if (currentK <= 15) {
                        setTimeout(animateK, 300);
                    } else {
                        k = 5;
                        draw();
                    }
                };

                animateK();
            };

            generateData();
            draw();
        }

        // 初始化所有功能
        function init() {
            // 恢复主题设置
            const savedTheme = localStorage.getItem('theme');
            if (savedTheme === 'light') {
                document.body.classList.add('light-theme');
            }
            updateThemeIcon();

            // 初始化背景
            initBackground();

            // 初始化演示
            initDistanceDemo();
            initKNNDemo();

            // 监听滚动事件
            window.addEventListener('scroll', () => {
                updateProgress();
                highlightCurrentSection();
            });

            // 初始更新
            updateProgress();
            highlightCurrentSection();

            // 快捷键支持
            document.addEventListener('keydown', (e) => {
                if (e.altKey && e.key === 'n') {
                    toggleNav();
                }
            });
        }

        // 导出全局函数
        window.toggleTheme = toggleTheme;
        window.toggleNav = toggleNav;
        // 预处理演示
        function initPreprocessDemo() {
            const canvas = document.getElementById('preprocessDemo');
            if (!canvas) return;

            const ctx = canvas.getContext('2d');
            let originalData = [];
            let currentData = [];
            let displayMode = 'original';

            // 生成原始数据
            function generateOriginalData() {
                originalData = [];

                // 生成两个类别的数据，特征尺度差异很大
                for (let i = 0; i < 30; i++) {
                    originalData.push({
                        x: Math.random() * 50 + 10,  // 年龄: 10-60
                        y: Math.random() * 100000 + 20000,  // 收入: 20k-120k
                        class: 0
                    });
                }

                for (let i = 0; i < 30; i++) {
                    originalData.push({
                        x: Math.random() * 50 + 30,  // 年龄: 30-80
                        y: Math.random() * 150000 + 80000,  // 收入: 80k-230k
                        class: 1
                    });
                }

                currentData = [...originalData];
            }

            // 归一化数据
            function normalizeData() {
                const xMin = Math.min(...originalData.map(p => p.x));
                const xMax = Math.max(...originalData.map(p => p.x));
                const yMin = Math.min(...originalData.map(p => p.y));
                const yMax = Math.max(...originalData.map(p => p.y));

                currentData = originalData.map(point => ({
                    x: (point.x - xMin) / (xMax - xMin),
                    y: (point.y - yMin) / (yMax - yMin),
                    class: point.class
                }));
            }

            // 标准化数据
            function standardizeData() {
                const xMean = originalData.reduce((sum, p) => sum + p.x, 0) / originalData.length;
                const yMean = originalData.reduce((sum, p) => sum + p.y, 0) / originalData.length;

                const xStd = Math.sqrt(originalData.reduce((sum, p) => sum + Math.pow(p.x - xMean, 2), 0) / originalData.length);
                const yStd = Math.sqrt(originalData.reduce((sum, p) => sum + Math.pow(p.y - yMean, 2), 0) / originalData.length);

                currentData = originalData.map(point => ({
                    x: (point.x - xMean) / xStd,
                    y: (point.y - yMean) / yStd,
                    class: point.class
                }));
            }

            function draw() {
                ctx.clearRect(0, 0, canvas.width, canvas.height);

                // 根据显示模式调整坐标系
                let scaleX, scaleY, offsetX, offsetY;

                if (displayMode === 'original') {
                    scaleX = canvas.width / 100;
                    scaleY = canvas.height / 250000;
                    offsetX = 0;
                    offsetY = 0;
                } else if (displayMode === 'normalized') {
                    scaleX = canvas.width * 0.8;
                    scaleY = canvas.height * 0.8;
                    offsetX = canvas.width * 0.1;
                    offsetY = canvas.height * 0.1;
                } else {  // standardized
                    scaleX = canvas.width / 6;
                    scaleY = canvas.height / 6;
                    offsetX = canvas.width / 2;
                    offsetY = canvas.height / 2;
                }

                // 绘制坐标轴
                ctx.strokeStyle = 'rgba(124, 58, 237, 0.3)';
                ctx.lineWidth = 2;

                // X轴
                ctx.beginPath();
                ctx.moveTo(offsetX, canvas.height - offsetY);
                ctx.lineTo(canvas.width - 20, canvas.height - offsetY);
                ctx.stroke();

                // Y轴
                ctx.beginPath();
                ctx.moveTo(offsetX, offsetY);
                ctx.lineTo(offsetX, canvas.height - offsetY);
                ctx.stroke();

                // 绘制数据点
                currentData.forEach(point => {
                    const x = point.x * scaleX + offsetX;
                    const y = canvas.height - (point.y * scaleY + offsetY);

                    ctx.beginPath();
                    ctx.arc(x, y, 6, 0, Math.PI * 2);
                    ctx.fillStyle = point.class === 0 ? '#667eea' : '#ec4899';
                    ctx.fill();
                    ctx.strokeStyle = 'white';
                    ctx.lineWidth = 2;
                    ctx.stroke();
                });

                // 显示模式标签
                ctx.fillStyle = 'var(--text-primary)';
                ctx.font = 'bold 16px Arial';
                ctx.textAlign = 'center';
                ctx.fillText(
                    displayMode === 'original' ? '原始数据' :
                        displayMode === 'normalized' ? '归一化后 [0,1]' :
                            '标准化后 (μ=0, σ=1)',
                    canvas.width / 2, 30
                );
            }

            // 控制函数
            window.showOriginalData = function() {
                displayMode = 'original';
                currentData = [...originalData];
                draw();
            };

            window.showNormalizedData = function() {
                displayMode = 'normalized';
                normalizeData();
                draw();
            };

            window.showStandardizedData = function() {
                displayMode = 'standardized';
                standardizeData();
                draw();
            };

            window.animatePreprocess = function() {
                const modes = ['original', 'normalized', 'standardized'];
                let index = 0;

                const animate = () => {
                    if (modes[index] === 'original') {
                        showOriginalData();
                    } else if (modes[index] === 'normalized') {
                        showNormalizedData();
                    } else {
                        showStandardizedData();
                    }

                    index++;
                    if (index < modes.length) {
                        setTimeout(animate, 1500);
                    }
                };

                animate();
            };

            generateOriginalData();
            draw();
        }

        // K值边界演示
        function initKBoundaryDemo() {
            const canvas = document.getElementById('kBoundaryDemo');
            if (!canvas) return;

            const ctx = canvas.getContext('2d');
            let k = 5;
            let noiseLevel = 0.1;
            let dataPoints = [];

            function generateDataWithNoise() {
                dataPoints = [];

                // 生成基础数据
                for (let i = 0; i < 40; i++) {
                    const angle = Math.random() * Math.PI;
                    const radius = Math.random() * 150 + 50;
                    dataPoints.push({
                        x: 200 + Math.cos(angle) * radius,
                        y: 200 + Math.sin(angle) * radius,
                        class: 0
                    });
                }

                for (let i = 0; i < 40; i++) {
                    const angle = Math.random() * Math.PI + Math.PI;
                    const radius = Math.random() * 150 + 50;
                    dataPoints.push({
                        x: 200 + Math.cos(angle) * radius,
                        y: 200 + Math.sin(angle) * radius,
                        class: 1
                    });
                }

                // 添加噪声点
                const noiseCount = Math.floor(dataPoints.length * noiseLevel);
                for (let i = 0; i < noiseCount; i++) {
                    const randomIndex = Math.floor(Math.random() * dataPoints.length);
                    dataPoints[randomIndex].class = 1 - dataPoints[randomIndex].class;
                }
            }

            function drawDecisionBoundary() {
                ctx.clearRect(0, 0, canvas.width, canvas.height);

                // 绘制决策边界（使用较低分辨率提高性能）
                const resolution = 10;
                for (let x = 0; x < canvas.width; x += resolution) {
                    for (let y = 0; y < canvas.height; y += resolution) {
                        const prediction = predictKNN(x, y);
                        ctx.fillStyle = prediction === 0 ?
                            'rgba(102, 126, 234, 0.2)' :
                            'rgba(236, 72, 153, 0.2)';
                        ctx.fillRect(x, y, resolution, resolution);
                    }
                }

                // 绘制数据点
                dataPoints.forEach(point => {
                    ctx.beginPath();
                    ctx.arc(point.x, point.y, 6, 0, Math.PI * 2);
                    ctx.fillStyle = point.class === 0 ? '#667eea' : '#ec4899';
                    ctx.fill();
                    ctx.strokeStyle = 'white';
                    ctx.lineWidth = 2;
                    ctx.stroke();
                });

                // 显示K值
                ctx.fillStyle = '#e2e8f0';
                ctx.font = 'bold 20px Arial';
                ctx.fillText(`K = ${k}`, 20, 30);
            }

            function predictKNN(x, y) {
                const distances = dataPoints.map(point => ({
                    distance: Math.sqrt(Math.pow(point.x - x, 2) + Math.pow(point.y - y, 2)),
                    class: point.class
                }));

                distances.sort((a, b) => a.distance - b.distance);
                const kNearest = distances.slice(0, k);

                const votes = { 0: 0, 1: 0 };
                kNearest.forEach(item => {
                    votes[item.class]++;
                });

                return votes[0] > votes[1] ? 0 : 1;
            }

            window.updateKBoundary = function() {
                k = parseInt(document.getElementById('kSlider').value);
                document.getElementById('kValue').textContent = k;

                // 更新平滑度和过拟合风险指示
                const smoothnessEl = document.getElementById('smoothness');
                const overfittingEl = document.getElementById('overfittingRisk');

                if (k <= 3) {
                    smoothnessEl.textContent = '低';
                    overfittingEl.textContent = '高';
                } else if (k <= 9) {
                    smoothnessEl.textContent = '中等';
                    overfittingEl.textContent = '低';
                } else {
                    smoothnessEl.textContent = '高';
                    overfittingEl.textContent = '欠拟合风险';
                }

                drawDecisionBoundary();
            };

            window.updateNoise = function() {
                noiseLevel = parseInt(document.getElementById('noiseSlider').value) / 100;
                document.getElementById('noiseLevel').textContent = Math.round(noiseLevel * 100) + '%';
                generateDataWithNoise();
                drawDecisionBoundary();
            };

            generateDataWithNoise();
            drawDecisionBoundary();
        }

        // 性能对比演示
        function initPerformanceDemo() {
            const canvas = document.getElementById('performanceDemo');
            if (!canvas) return;

            const ctx = canvas.getContext('2d');

            function drawPerformanceChart(data) {
                ctx.clearRect(0, 0, canvas.width, canvas.height);

                const algorithms = ['暴力搜索', 'KD树', 'Ball树', 'LSH'];
                const colors = ['#667eea', '#ec4899', '#14b8a6', '#f97316'];
                const barWidth = 100;
                const barSpacing = 150;
                const startX = 50;
                const maxHeight = 300;

                // 绘制坐标轴
                ctx.strokeStyle = 'rgba(124, 58, 237, 0.3)';
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.moveTo(30, 350);
                ctx.lineTo(750, 350);
                ctx.stroke();

                // 绘制柱状图
                algorithms.forEach((algo, index) => {
                    const x = startX + index * barSpacing;
                    const height = data[algo] * maxHeight / 100;

                    ctx.fillStyle = colors[index];
                    ctx.fillRect(x, 350 - height, barWidth, height);

                    // 算法名称
                    ctx.fillStyle = '#e2e8f0';
                    ctx.font = '14px Arial';
                    ctx.textAlign = 'center';
                    ctx.fillText(algo, x + barWidth / 2, 370);

                    // 数值标签
                    ctx.fillText(data[algo] + 'ms', x + barWidth / 2, 340 - height);
                });

                // 标题
                ctx.font = 'bold 18px Arial';
                ctx.textAlign = 'center';
                ctx.fillText('查询时间对比（毫秒）', canvas.width / 2, 30);
            }

            window.compareAlgorithms = function() {
                // 模拟性能数据
                const performanceData = {
                    '暴力搜索': 85,
                    'KD树': 15,
                    'Ball树': 20,
                    'LSH': 5
                };

                drawPerformanceChart(performanceData);

                document.getElementById('performanceResult').innerHTML =
                    '<span style="color: var(--knn-orange);">LSH最快但是近似结果，KD树在低维度最优</span>';
            };

            window.showDimensionEffect = function() {
                // 显示维度对性能的影响
                ctx.clearRect(0, 0, canvas.width, canvas.height);

                // 绘制维度影响曲线
                ctx.strokeStyle = '#667eea';
                ctx.lineWidth = 3;
                ctx.beginPath();
                ctx.moveTo(50, 300);

                // KD树性能曲线
                for (let d = 0; d <= 100; d += 5) {
                    const x = 50 + d * 7;
                    const y = 300 - Math.max(0, 250 - d * d / 40);
                    ctx.lineTo(x, y);
                }
                ctx.stroke();

                // Ball树性能曲线
                ctx.strokeStyle = '#ec4899';
                ctx.beginPath();
                ctx.moveTo(50, 300);
                for (let d = 0; d <= 100; d += 5) {
                    const x = 50 + d * 7;
                    const y = 300 - Math.max(0, 250 - d * d / 80);
                    ctx.lineTo(x, y);
                }
                ctx.stroke();

                // 标签
                ctx.fillStyle = '#e2e8f0';
                ctx.font = '14px Arial';
                ctx.fillText('维度', 400, 340);
                ctx.save();
                ctx.translate(20, 200);
                ctx.rotate(-Math.PI / 2);
                ctx.fillText('查询时间', 0, 0);
                ctx.restore();

                // 图例
                ctx.fillStyle = '#667eea';
                ctx.fillRect(600, 50, 20, 3);
                ctx.fillStyle = '#e2e8f0';
                ctx.fillText('KD树', 630, 55);

                ctx.fillStyle = '#ec4899';
                ctx.fillRect(600, 70, 20, 3);
                ctx.fillStyle = '#e2e8f0';
                ctx.fillText('Ball树', 630, 75);

                document.getElementById('performanceResult').innerHTML =
                    '<span style="color: var(--knn-purple);">高维度下两种树结构性能都会退化</span>';
            };

            window.showScalability = function() {
                // 显示可扩展性
                ctx.clearRect(0, 0, canvas.width, canvas.height);

                const sampleSizes = [1000, 10000, 100000, 1000000];
                const times = {
                    '暴力搜索': [10, 100, 1000, 10000],
                    'KD树': [5, 15, 50, 200],
                    'Ball树': [6, 18, 60, 250],
                    'LSH': [2, 3, 5, 8]
                };

                const colors = {
                    '暴力搜索': '#667eea',
                    'KD树': '#ec4899',
                    'Ball树': '#14b8a6',
                    'LSH': '#f97316'
                };

                // 绘制坐标轴
                ctx.strokeStyle = 'rgba(124, 58, 237, 0.3)';
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.moveTo(50, 350);
                ctx.lineTo(750, 350);
                ctx.moveTo(50, 50);
                ctx.lineTo(50, 350);
                ctx.stroke();

                // 绘制曲线
                Object.entries(times).forEach(([algo, timeData]) => {
                    ctx.strokeStyle = colors[algo];
                    ctx.lineWidth = 3;
                    ctx.beginPath();

                    timeData.forEach((time, index) => {
                        const x = 100 + index * 200;
                        const y = 350 - (Math.log10(time) * 80);

                        if (index === 0) {
                            ctx.moveTo(x, y);
                        } else {
                            ctx.lineTo(x, y);
                        }

                        // 数据点
                        ctx.fillStyle = colors[algo];
                        ctx.beginPath();
                        ctx.arc(x, y, 4, 0, Math.PI * 2);
                        ctx.fill();
                    });
                    ctx.stroke();
                });

                // 标签
                ctx.fillStyle = 'var(--text-primary)';
                ctx.font = '12px Arial';
                sampleSizes.forEach((size, index) => {
                    const x = 100 + index * 200;
                    ctx.fillText(size >= 1000000 ? '1M' : size >= 1000 ? size/1000 + 'K' : size, x - 15, 370);
                });

                // 图例
                let legendY = 80;
                Object.entries(colors).forEach(([algo, color]) => {
                    ctx.fillStyle = color;
                    ctx.fillRect(600, legendY, 20, 3);
                    ctx.fillStyle = 'var(--text-primary)';
                    ctx.fillText(algo, 630, legendY + 5);
                    legendY += 20;
                });

                document.getElementById('performanceResult').innerHTML =
                    '<span style="color: var(--knn-purple);">LSH在大规模数据上优势明显</span>';
            };
        }

        // 下载笔记功能
        window.downloadNotes = function() {
            // 创建笔记内容
            const notes = `
# KNN算法学习笔记

## 核心概念
- K近邻算法是基于实例的懒惰学习算法
- 核心思想：相似的事物应该有相似的标签
- 主要参数：K值、距离度量、权重策略

## 算法步骤
1. 计算距离
2. 排序选择K个最近邻
3. 权重计算
4. 投票/平均得出预测

## 关键要点
- 数据预处理至关重要（归一化/标准化）
- K值选择影响模型复杂度
- 高维数据存在维数灾难
- 可以使用KD树、Ball树等优化查询速度

## 实践建议
- 低维数据（d<20）使用KD树
- 中高维数据使用Ball树
- 海量高维数据考虑LSH近似方法
- 始终进行交叉验证选择最优参数
        `;

            // 创建下载
            const blob = new Blob([notes], { type: 'text/markdown' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = 'KNN算法学习笔记.md';
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
        };

        // 开始测验功能
        window.startQuiz = function() {
            const questions = [
                {
                    question: "KNN算法属于什么类型的学习算法？",
                    options: ["监督学习", "无监督学习", "强化学习", "半监督学习"],
                    answer: 0
                },
                {
                    question: "为什么KNN被称为'懒惰学习'算法？",
                    options: [
                        "训练速度慢",
                        "没有显式的训练过程",
                        "预测速度慢",
                        "需要大量内存"
                    ],
                    answer: 1
                },
                {
                    question: "当K=1时，KNN算法容易出现什么问题？",
                    options: ["欠拟合", "过拟合", "梯度消失", "梯度爆炸"],
                    answer: 1
                },
                {
                    question: "对于高维数据，哪种距离度量通常更合适？",
                    options: ["欧式距离", "曼哈顿距离", "切比雪夫距离", "汉明距离"],
                    answer: 1
                },
                {
                    question: "KNN算法的时间复杂度主要取决于什么？",
                    options: ["训练过程", "预测过程", "参数调优", "数据预处理"],
                    answer: 1
                }
            ];

            let score = 0;
            let currentQuestion = 0;

            function showQuestion() {
                if (currentQuestion >= questions.length) {
                    alert(`测验完成！您的得分是：${score}/${questions.length}`);
                    return;
                }

                const q = questions[currentQuestion];
                const answer = prompt(
                    `问题 ${currentQuestion + 1}/${questions.length}:\n${q.question}\n\n` +
                    q.options.map((opt, i) => `${i + 1}. ${opt}`).join('\n') +
                    '\n\n请输入选项编号（1-4）：'
                );

                if (answer && parseInt(answer) - 1 === q.answer) {
                    score++;
                    alert('回答正确！');
                } else {
                    alert(`回答错误。正确答案是：${q.options[q.answer]}`);
                }

                currentQuestion++;
                showQuestion();
            }

            showQuestion();
        };

        // 分享进度功能
        window.shareProgress = function() {
            const progress = document.getElementById('progressText').textContent;
            const completedSections = document.querySelectorAll('.nav-item.completed').length;
            const totalSections = document.querySelectorAll('.nav-item').length;

            const shareText = `我正在学习KNN算法！
📚 学习进度：${progress}
✅ 完成章节：${completedSections}/${totalSections}
🎯 当前重点：${document.querySelector('.nav-item.active .nav-text').textContent}

#机器学习 #KNN算法 #AI学习`;

            // 复制到剪贴板
            if (navigator.clipboard) {
                navigator.clipboard.writeText(shareText).then(() => {
                    alert('学习进度已复制到剪贴板，可以分享到社交媒体！');
                });
            } else {
                alert(shareText);
            }
        };

        // 初始化所有功能
        function init() {
            // 恢复主题设置
            const savedTheme = localStorage.getItem('theme');
            if (savedTheme === 'light') {
                document.body.classList.add('light-theme');
            }
            updateThemeIcon();

            // 初始化背景
            initBackground();

            // 初始化所有演示
            initDistanceDemo();
            initKNNDemo();
            initPreprocessDemo();
            initKBoundaryDemo();

            // 初始化性能演示（如果元素存在）
            if (document.getElementById('performanceDemo')) {
                initPerformanceDemo();
            }

            // 监听滚动事件
            window.addEventListener('scroll', () => {
                updateProgress();
                highlightCurrentSection();
            });

            // 初始更新
            updateProgress();
            highlightCurrentSection();

            // 快捷键支持
            document.addEventListener('keydown', (e) => {
                if (e.altKey && e.key === 'n') {
                    toggleNav();
                }
                if (e.ctrlKey && e.key === 't') {
                    toggleTheme();
                }
            });

            // 平滑滚动
            document.querySelectorAll('a[href^="#"]').forEach(anchor => {
                anchor.addEventListener('click', function (e) {
                    e.preventDefault();
                    const target = document.querySelector(this.getAttribute('href'));
                    if (target) {
                        target.scrollIntoView({
                            behavior: 'smooth',
                            block: 'start'
                        });
                    }
                });
            });

            // 添加页面可见性变化监听
            document.addEventListener('visibilitychange', () => {
                if (!document.hidden) {
                    updateProgress();
                }
            });

            console.log('KNN算法教程初始化完成！');
        }

        // 导出全局函数
        window.toggleTheme = toggleTheme;
        window.toggleNav = toggleNav;
        window.scrollToTop = scrollToTop;

        // DOM加载完成后初始化
        if (document.readyState === 'loading') {
            document.addEventListener('DOMContentLoaded', init);
        } else {
            init();
        }
    })();
</script>

</body>
</html>