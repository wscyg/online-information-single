<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>第8章：聚类算法 - 发现数据的内在结构</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        /* CSS 变量统一管理主题颜色 */
        :root {
            /* 深色主题（默认） */
            --bg-primary: #0a0e27;
            --bg-secondary: #151a3a;
            --bg-card: rgba(21, 26, 58, 0.8);
            --bg-card-solid: rgba(21, 26, 58, 0.95);
            --bg-code: #0f1729;

            --text-primary: #e8eaed;
            --text-secondary: #c7d0dc;
            --text-muted: #8b98a8;
            --text-dim: #5f6e82;

            --border-primary: rgba(79, 172, 254, 0.3);
            --border-secondary: rgba(79, 172, 254, 0.2);
            --border-muted: rgba(139, 152, 168, 0.1);

            --shadow-sm: rgba(0,0,0,0.3);
            --shadow-md: rgba(0,0,0,0.4);
            --shadow-lg: rgba(0,0,0,0.5);

            --gradient-primary: linear-gradient(135deg, #4facfe, #00f2fe);
            --gradient-bg: linear-gradient(135deg, #0a0e27 0%, #151a3a 100%);

            /* 聚类主题色 */
            --cluster-blue: #4facfe;
            --cluster-cyan: #00f2fe;
            --cluster-purple: #a78bfa;
            --cluster-pink: #f472b6;
            --cluster-amber: #fbbf24;
            --cluster-emerald: #34d399;
        }

        /* 浅色主题 */
        body.light-theme {
            --bg-primary: #f9fafb;
            --bg-secondary: #e5e7eb;
            --bg-card: rgba(255, 255, 255, 0.9);
            --bg-card-solid: rgba(255, 255, 255, 0.95);
            --bg-code: #f3f4f6;

            --text-primary: #111827;
            --text-secondary: #374151;
            --text-muted: #4b5563;
            --text-dim: #6b7280;

            --border-primary: rgba(79, 172, 254, 0.4);
            --border-secondary: rgba(79, 172, 254, 0.3);
            --border-muted: rgba(209, 213, 219, 0.5);

            --shadow-sm: rgba(0,0,0,0.1);
            --shadow-md: rgba(0,0,0,0.15);
            --shadow-lg: rgba(0,0,0,0.2);

            --gradient-bg: linear-gradient(135deg, #f9fafb 0%, #e5e7eb 100%);
        }

        /* 全局过渡动画 */
        body, body * {
            transition: background-color 0.3s ease, color 0.3s ease, border-color 0.3s ease, box-shadow 0.3s ease;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', 'PingFang SC', 'Microsoft YaHei', sans-serif;
            background: var(--gradient-bg);
            color: var(--text-primary);
            line-height: 1.8;
            min-height: 100vh;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
            padding: 20px;
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
        }

        body.nav-open .container {
            margin-left: 360px;
        }

        /* 动态背景粒子系统 */
        .dynamic-bg {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            overflow: hidden;
            z-index: -1;
        }

        .particle-system {
            position: absolute;
            width: 100%;
            height: 100%;
        }

        /* 智能导航系统 */
        .smart-nav {
            position: fixed;
            left: -340px;
            top: 0;
            width: 340px;
            height: 100vh;
            background: linear-gradient(135deg, rgba(10, 14, 39, 0.98) 0%, rgba(21, 26, 58, 0.95) 100%);
            backdrop-filter: blur(20px);
            border-right: 1px solid var(--border-primary);
            box-shadow: 4px 0 30px var(--shadow-lg);
            z-index: 1000;
            transition: all 0.4s cubic-bezier(0.25, 0.46, 0.45, 0.94);
            overflow: hidden;
        }

        body.nav-open .smart-nav {
            left: 0;
        }

        .nav-bg-decoration {
            position: absolute;
            top: -100px;
            right: -100px;
            width: 300px;
            height: 300px;
            background: radial-gradient(circle, var(--cluster-blue) 0%, transparent 70%);
            opacity: 0.1;
            animation: pulse 4s ease-in-out infinite;
        }

        /* 导航触发按钮 */
        .nav-trigger {
            position: fixed;
            left: 20px;
            top: 20px;
            width: 56px;
            height: 56px;
            background: linear-gradient(135deg, rgba(79, 172, 254, 0.1), rgba(0, 242, 254, 0.1));
            backdrop-filter: blur(10px);
            border: 2px solid rgba(79, 172, 254, 0.3);
            border-radius: 16px;
            cursor: pointer;
            z-index: 1001;
            transition: all 0.3s cubic-bezier(0.25, 0.46, 0.45, 0.94);
            display: flex;
            align-items: center;
            justify-content: center;
        }

        body.nav-open .nav-trigger {
            left: 290px;
            background: linear-gradient(135deg, rgba(167, 139, 250, 0.1), rgba(244, 114, 182, 0.1));
            border-color: rgba(167, 139, 250, 0.5);
        }

        .nav-trigger:hover {
            transform: scale(1.1);
            box-shadow: 0 8px 25px rgba(79, 172, 254, 0.4);
        }

        /* 汉堡菜单图标动画 */
        .nav-trigger-icon {
            width: 24px;
            height: 20px;
            position: relative;
        }

        .nav-trigger-icon span {
            display: block;
            position: absolute;
            height: 3px;
            width: 100%;
            background: linear-gradient(90deg, var(--cluster-blue), var(--cluster-cyan));
            border-radius: 3px;
            opacity: 1;
            left: 0;
            transition: 0.25s ease-in-out;
        }

        .nav-trigger-icon span:nth-child(1) { top: 0px; }
        .nav-trigger-icon span:nth-child(2) { top: 8px; }
        .nav-trigger-icon span:nth-child(3) { top: 16px; }

        body.nav-open .nav-trigger-icon span:nth-child(1) { top: 8px; transform: rotate(135deg); }
        body.nav-open .nav-trigger-icon span:nth-child(2) { opacity: 0; left: -60px; }
        body.nav-open .nav-trigger-icon span:nth-child(3) { top: 8px; transform: rotate(-135deg); }

        /* 导航头部 */
        .nav-header {
            padding: 30px;
            background: linear-gradient(135deg, rgba(79, 172, 254, 0.1), rgba(0, 242, 254, 0.05));
            border-bottom: 1px solid rgba(79, 172, 254, 0.2);
            position: relative;
        }

        .nav-header h3 {
            font-size: 1.4rem;
            background: linear-gradient(135deg, var(--cluster-blue), var(--cluster-cyan));
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            display: flex;
            align-items: center;
            gap: 12px;
            font-weight: 700;
        }

        .nav-subtitle {
            font-size: 0.85rem;
            color: var(--text-muted);
            margin-top: 5px;
        }

        /* 导航列表 */
        .nav-list {
            list-style: none;
            padding: 20px 0;
            max-height: calc(100vh - 300px);
            overflow-y: auto;
        }

        .nav-list::-webkit-scrollbar {
            width: 6px;
        }

        .nav-list::-webkit-scrollbar-track {
            background: rgba(79, 172, 254, 0.05);
            border-radius: 3px;
        }

        .nav-list::-webkit-scrollbar-thumb {
            background: linear-gradient(135deg, var(--cluster-blue), var(--cluster-cyan));
            border-radius: 3px;
        }

        /* 导航项优化 */
        .nav-item {
            position: relative;
            margin: 8px 15px;
            border-radius: 12px;
            overflow: hidden;
            transition: all 0.3s ease;
        }

        .nav-item::before {
            content: '';
            position: absolute;
            left: 0;
            top: 0;
            bottom: 0;
            width: 0;
            background: linear-gradient(90deg, var(--cluster-blue), var(--cluster-cyan));
            transition: width 0.3s ease;
            opacity: 0.8;
        }

        .nav-item:hover::before,
        .nav-item.active::before {
            width: 4px;
        }

        .nav-item.active::before {
            opacity: 1;
            box-shadow: 0 0 12px var(--cluster-blue);
        }

        .nav-item a {
            display: flex;
            align-items: center;
            padding: 14px 20px;
            color: var(--text-muted);
            text-decoration: none;
            transition: all 0.3s ease;
            position: relative;
            background: rgba(0, 0, 0, 0);
        }

        .nav-item:hover a,
        .nav-item.active a {
            color: var(--text-primary);
            padding-left: 28px;
        }

        .nav-item.active a {
            background: linear-gradient(90deg, rgba(79, 172, 254, 0.1), rgba(0, 242, 254, 0.05));
            font-weight: 600;
        }

        .nav-icon {
            font-size: 1.4rem;
            margin-right: 14px;
            flex-shrink: 0;
            transition: all 0.3s ease;
            display: flex;
            align-items: center;
            justify-content: center;
            width: 32px;
            height: 32px;
            background: rgba(79, 172, 254, 0.1);
            border-radius: 8px;
        }

        .nav-item:hover .nav-icon {
            transform: scale(1.1) rotate(10deg);
            background: rgba(79, 172, 254, 0.2);
        }

        .nav-item.active .nav-icon {
            background: linear-gradient(135deg, rgba(79, 172, 254, 0.3), rgba(0, 242, 254, 0.2));
            animation: iconPulse 2s ease-in-out infinite;
        }

        @keyframes iconPulse {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.1); }
        }

        .nav-content {
            flex: 1;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .nav-text {
            font-size: 0.95rem;
            font-weight: 500;
        }

        .nav-meta {
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .nav-time {
            font-size: 0.75rem;
            color: var(--text-dim);
            background: rgba(79, 172, 254, 0.1);
            padding: 2px 8px;
            border-radius: 12px;
        }

        .nav-status {
            width: 8px;
            height: 8px;
            border-radius: 50%;
            background: #4a5568;
            transition: all 0.3s ease;
        }

        .nav-item.completed .nav-status {
            background: #34d399;
            box-shadow: 0 0 8px #34d399;
        }

        .nav-item.active .nav-status {
            background: var(--cluster-blue);
            box-shadow: 0 0 8px var(--cluster-blue);
            animation: statusPulse 2s ease-in-out infinite;
        }

        @keyframes statusPulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.5; }
        }

        /* 主标题样式 */
        .main-header {
            text-align: center;
            margin: 60px 0;
            position: relative;
        }

        .main-title {
            font-size: 4rem;
            font-weight: 900;
            background: linear-gradient(135deg, var(--cluster-blue) 0%, var(--cluster-cyan) 25%, var(--cluster-purple) 50%, var(--cluster-pink) 75%, var(--cluster-amber) 100%);
            background-size: 300% 300%;
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            animation: gradient-flow 8s ease infinite;
            text-shadow: 0 0 80px rgba(79, 172, 254, 0.5);
            margin-bottom: 20px;
        }

        @keyframes gradient-flow {
            0% { background-position: 0% 50%; }
            50% { background-position: 100% 50%; }
            100% { background-position: 0% 50%; }
        }

        .subtitle {
            font-size: 1.6rem;
            color: var(--text-muted);
            text-shadow: 0 2px 10px var(--shadow-sm);
        }

        /* 章节卡片基础样式 */
        .section-card {
            background: var(--bg-card);
            backdrop-filter: blur(10px);
            border-radius: 24px;
            padding: 40px;
            margin: 30px 0;
            border: 1px solid var(--border-secondary);
            box-shadow: 0 20px 40px var(--shadow-sm);
            transition: all 0.3s ease;
            position: relative;
            overflow: hidden;
        }

        .section-card::before {
            content: '';
            position: absolute;
            top: -2px;
            left: -2px;
            right: -2px;
            bottom: -2px;
            background: linear-gradient(45deg, var(--cluster-blue), var(--cluster-cyan), var(--cluster-purple), var(--cluster-pink));
            border-radius: 24px;
            opacity: 0;
            z-index: -1;
            transition: opacity 0.3s ease;
        }

        .section-card:hover::before {
            opacity: 0.5;
            animation: borderRotate 6s linear infinite;
        }

        @keyframes borderRotate {
            from { transform: rotate(0deg); }
            to { transform: rotate(360deg); }
        }

        .section-card:hover {
            transform: translateY(-5px);
            box-shadow: 0 30px 60px var(--shadow-md);
        }

        .section-title {
            font-size: 2.5rem;
            background: linear-gradient(135deg, var(--cluster-blue), var(--cluster-cyan));
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            margin-bottom: 30px;
            display: flex;
            align-items: center;
            gap: 15px;
        }

        /* 通用内容框样式 */
        .content-box {
            border-radius: 20px;
            padding: 30px;
            margin: 30px 0;
            position: relative;
            overflow: hidden;
        }

        .story-box {
            background: linear-gradient(135deg, rgba(79, 172, 254, 0.1), rgba(0, 242, 254, 0.05));
            border: 2px solid rgba(79, 172, 254, 0.3);
        }

        .story-box::after {
            content: '🌌';
            position: absolute;
            top: -20px;
            right: 20px;
            font-size: 4rem;
            opacity: 0.08;
            z-index: 0;
        }

        .thinking-box {
            background: linear-gradient(135deg, rgba(167, 139, 250, 0.1), rgba(129, 140, 248, 0.05));
            border: 2px solid rgba(167, 139, 250, 0.3);
        }

        .thinking-box::before {
            content: '💭';
            position: absolute;
            top: -15px;
            left: 20px;
            font-size: 2rem;
            background: var(--bg-card-solid);
            padding: 5px 15px;
            border-radius: 50%;
            opacity: 0.3;
            z-index: 1;
        }

        .formula-box {
            background: linear-gradient(135deg, rgba(244, 114, 182, 0.1), rgba(236, 72, 153, 0.05));
            border: 2px solid rgba(244, 114, 182, 0.3);
            text-align: center;
        }

        .formula-box::before {
            content: '∑';
            position: absolute;
            top: -30px;
            right: 30px;
            font-size: 6rem;
            opacity: 0.03;
            transform: rotate(15deg);
            z-index: 0;
        }

        .math-formula {
            font-family: 'Times New Roman', serif;
            font-size: 1.8rem;
            color: var(--text-primary);
            margin: 20px 0;
            display: flex;
            align-items: center;
            justify-content: center;
            flex-wrap: wrap;
            gap: 10px;
        }

        /* 高亮样式系统 */
        .highlight {
            font-weight: bold;
            padding: 2px 8px;
            border-radius: 6px;
            border: 1px solid;
        }

        .highlight-primary {
            color: var(--cluster-blue);
            background: rgba(79, 172, 254, 0.1);
            border-color: rgba(79, 172, 254, 0.3);
        }

        .highlight-secondary {
            color: var(--cluster-cyan);
            background: rgba(0, 242, 254, 0.1);
            border-color: rgba(0, 242, 254, 0.3);
        }

        .highlight-success {
            color: var(--cluster-emerald);
            background: rgba(52, 211, 153, 0.1);
            border-color: rgba(52, 211, 153, 0.3);
        }

        .highlight-warning {
            color: var(--cluster-amber);
            background: rgba(251, 191, 36, 0.1);
            border-color: rgba(251, 191, 36, 0.3);
        }

        .highlight-danger {
            color: var(--cluster-pink);
            background: rgba(244, 114, 182, 0.1);
            border-color: rgba(244, 114, 182, 0.3);
        }

        /* 表格样式 */
        .data-table {
            margin: 20px auto;
            border-collapse: collapse;
            background: var(--bg-card);
            border-radius: 10px;
            overflow: hidden;
            box-shadow: 0 10px 30px var(--shadow-sm);
            width: 100%;
        }

        .data-table th {
            background: linear-gradient(135deg, var(--cluster-blue), var(--cluster-cyan));
            color: white;
            padding: 12px 20px;
            font-weight: 600;
            text-align: left;
        }

        .data-table td {
            padding: 10px 20px;
            border-bottom: 1px solid var(--border-muted);
            color: var(--text-primary);
        }

        .data-table tr:hover td {
            background: rgba(79, 172, 254, 0.05);
        }

        .data-table tr:last-child td {
            border-bottom: none;
        }

        /* 交互式演示区域 */
        .demo-container {
            background: linear-gradient(135deg, rgba(10, 14, 39, 0.9), rgba(21, 26, 58, 0.8));
            border-radius: 20px;
            padding: 30px;
            margin: 30px 0;
            border: 2px solid rgba(79, 172, 254, 0.3);
            box-shadow: 0 20px 40px rgba(0, 0, 0, 0.4);
        }

        .demo-canvas {
            background: #0a0e27;
            border-radius: 10px;
            margin: 20px auto;
            display: block;
            box-shadow: 0 10px 30px rgba(0,0,0,0.5);
            cursor: crosshair;
        }

        .demo-controls {
            display: flex;
            justify-content: center;
            gap: 15px;
            flex-wrap: wrap;
            margin: 20px 0;
        }

        .demo-btn {
            background: linear-gradient(135deg, var(--cluster-blue), var(--cluster-cyan));
            color: white;
            border: none;
            padding: 12px 24px;
            border-radius: 25px;
            cursor: pointer;
            font-weight: 600;
            transition: all 0.3s ease;
            box-shadow: 0 5px 15px rgba(79, 172, 254, 0.3);
        }

        .demo-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 8px 25px rgba(79, 172, 254, 0.4);
        }

        .demo-btn:active {
            transform: translateY(0);
        }

        .demo-btn.secondary {
            background: linear-gradient(135deg, var(--cluster-purple), var(--cluster-pink));
            box-shadow: 0 5px 15px rgba(167, 139, 250, 0.3);
        }

        .demo-btn.secondary:hover {
            box-shadow: 0 8px 25px rgba(167, 139, 250, 0.4);
        }

        /* 参数控制面板 */
        .param-panel {
            background: rgba(79, 172, 254, 0.05);
            border: 1px solid rgba(79, 172, 254, 0.3);
            border-radius: 15px;
            padding: 20px;
            margin: 20px 0;
        }

        .param-group {
            margin-bottom: 20px;
        }

        .param-label {
            display: block;
            font-weight: 600;
            color: var(--cluster-blue);
            margin-bottom: 10px;
        }

        .param-slider {
            width: 100%;
            margin: 10px 0;
            -webkit-appearance: none;
            appearance: none;
            height: 8px;
            background: rgba(79, 172, 254, 0.2);
            border-radius: 4px;
            outline: none;
        }

        .param-slider::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 20px;
            height: 20px;
            background: linear-gradient(135deg, var(--cluster-blue), var(--cluster-cyan));
            border-radius: 50%;
            cursor: pointer;
            box-shadow: 0 2px 10px rgba(79, 172, 254, 0.5);
        }

        .param-value {
            display: inline-block;
            width: 60px;
            text-align: center;
            color: var(--cluster-cyan);
            font-weight: bold;
            background: rgba(0, 242, 254, 0.1);
            padding: 4px 8px;
            border-radius: 8px;
            margin-left: 10px;
        }

        /* 聚类结果卡片 */
        .cluster-results {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 20px;
            margin: 20px 0;
        }

        .cluster-card {
            background: linear-gradient(135deg, rgba(79, 172, 254, 0.1), rgba(0, 242, 254, 0.05));
            border: 2px solid rgba(79, 172, 254, 0.3);
            border-radius: 15px;
            padding: 20px;
            text-align: center;
            transition: all 0.3s ease;
        }

        .cluster-card:hover {
            transform: translateY(-5px);
            box-shadow: 0 10px 25px rgba(79, 172, 254, 0.3);
        }

        .cluster-icon {
            font-size: 3rem;
            margin-bottom: 10px;
        }

        .cluster-label {
            font-size: 1.2rem;
            font-weight: bold;
            color: var(--cluster-blue);
            margin-bottom: 5px;
        }

        .cluster-count {
            font-size: 0.9rem;
            color: var(--text-muted);
        }

        /* 代码区域样式 */
        .code-block {
            background: #0f1729;
            border-radius: 15px;
            padding: 25px;
            margin: 25px 0;
            overflow-x: auto;
            position: relative;
            box-shadow: 0 10px 30px rgba(0,0,0,0.5);
            border: 1px solid rgba(79, 172, 254, 0.2);
        }

        .code-block::before {
            content: 'Python';
            position: absolute;
            top: -12px;
            left: 20px;
            background: linear-gradient(135deg, var(--cluster-blue), var(--cluster-cyan));
            color: white;
            padding: 5px 15px;
            border-radius: 15px;
            font-size: 0.9rem;
            font-weight: 600;
        }

        .code-block pre {
            color: #f8f8f2;
            font-family: 'Fira Code', 'Consolas', monospace;
            line-height: 1.6;
            margin: 0;
        }

        /* 语法高亮 */
        .keyword { color: #ff79c6; }
        .string { color: #f1fa8c; }
        .comment { color: #6272a4; }
        .number { color: #bd93f9; }
        .function { color: #50fa7b; }
        .operator { color: #ff6347; }

        /* 迭代次数显示 */
        .iteration-display {
            position: absolute;
            top: 10px;
            right: 10px;
            background: rgba(0, 0, 0, 0.6);
            padding: 5px 15px;
            border-radius: 20px;
            color: var(--cluster-cyan);
            font-weight: bold;
            font-size: 0.9rem;
        }

        /* 进度指示器 */
        .progress-indicator {
            position: fixed;
            top: 20px;
            right: 20px;
            background: linear-gradient(135deg, rgba(79, 172, 254, 0.1), rgba(167, 139, 250, 0.1));
            padding: 15px 25px;
            border-radius: 50px;
            border: 2px solid rgba(79, 172, 254, 0.3);
            display: flex;
            align-items: center;
            gap: 10px;
            backdrop-filter: blur(10px);
            z-index: 1000;
            transition: all 0.3s ease;
            box-shadow: 0 4px 12px var(--shadow-sm);
        }

        .progress-bar {
            width: 150px;
            height: 6px;
            background: rgba(79, 172, 254, 0.2);
            border-radius: 3px;
            overflow: hidden;
        }

        .progress-fill {
            height: 100%;
            background: linear-gradient(90deg, var(--cluster-blue), var(--cluster-cyan));
            border-radius: 3px;
            transition: width 0.3s ease;
        }

        /* 浮动工具栏 */
        .floating-toolbar {
            position: fixed;
            bottom: 30px;
            right: 30px;
            display: flex;
            flex-direction: column;
            gap: 10px;
            z-index: 1000;
        }

        .toolbar-btn {
            width: 50px;
            height: 50px;
            border-radius: 50%;
            background: linear-gradient(135deg, var(--cluster-blue), var(--cluster-cyan));
            color: white;
            border: none;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 1.5rem;
            transition: all 0.3s ease;
            box-shadow: 0 5px 15px rgba(79, 172, 254, 0.3);
        }

        .toolbar-btn:hover {
            transform: scale(1.1);
            box-shadow: 0 8px 25px rgba(79, 172, 254, 0.4);
        }

        /* 响应式设计 */
        @media (max-width: 1400px) {
            body.nav-open .container {
                margin-left: 0;
                padding-left: 360px;
            }
        }

        @media (max-width: 768px) {
            .main-title {
                font-size: 2.5rem;
            }

            .section-title {
                font-size: 1.8rem;
            }

            .section-card {
                padding: 25px;
            }

            .demo-controls {
                flex-direction: column;
            }

            .smart-nav {
                width: 100%;
                left: -100%;
            }

            body.nav-open .smart-nav {
                left: 0;
            }

            body.nav-open .container {
                margin-left: 0;
                padding-left: 20px;
            }

            body.nav-open .nav-trigger {
                left: auto;
                right: 20px;
            }

            .data-table {
                font-size: 0.9rem;
            }

            .data-table th,
            .data-table td {
                padding: 10px;
            }
        }

        /* 动画效果 */
        .fade-in {
            opacity: 0;
            transform: translateY(30px);
            animation: fadeInUp 0.6s ease forwards;
        }

        @keyframes fadeInUp {
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        @keyframes pulse {
            0% { transform: scale(1); }
            50% { transform: scale(1.05); }
            100% { transform: scale(1); }
        }

        .pulse {
            animation: pulse 2s ease-in-out infinite;
        }

        .section-anchor {
            scroll-margin-top: 100px;
        }

        /* 聚类动画相关 */
        .cluster-point {
            position: absolute;
            width: 8px;
            height: 8px;
            border-radius: 50%;
            transition: all 0.5s ease;
        }

        @keyframes cluster-form {
            from {
                transform: scale(0);
                opacity: 0;
            }
            to {
                transform: scale(1);
                opacity: 1;
            }
        }

        .cluster-animation {
            animation: cluster-form 0.5s ease forwards;
        }

        /* 评估指标卡片 */
        .metric-cards {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 20px;
            margin: 30px 0;
        }

        .metric-card {
            background: linear-gradient(135deg, rgba(79, 172, 254, 0.1), rgba(0, 242, 254, 0.05));
            border: 2px solid rgba(79, 172, 254, 0.3);
            border-radius: 15px;
            padding: 25px;
            text-align: center;
            transition: all 0.3s ease;
            position: relative;
            overflow: hidden;
        }

        .metric-card::before {
            content: '';
            position: absolute;
            top: -50%;
            left: -50%;
            width: 200%;
            height: 200%;
            background: radial-gradient(circle, rgba(79, 172, 254, 0.1) 0%, transparent 70%);
            transform: rotate(45deg);
            transition: all 0.5s ease;
            opacity: 0;
        }

        .metric-card:hover::before {
            opacity: 1;
        }

        .metric-card:hover {
            transform: translateY(-5px);
            box-shadow: 0 10px 25px rgba(79, 172, 254, 0.3);
        }

        .metric-icon {
            font-size: 3rem;
            margin-bottom: 15px;
        }

        .metric-name {
            font-size: 1.1rem;
            color: var(--cluster-blue);
            font-weight: 600;
            margin-bottom: 10px;
        }

        .metric-value {
            font-size: 2rem;
            font-weight: bold;
            background: linear-gradient(135deg, var(--cluster-blue), var(--cluster-cyan));
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }

        .metric-description {
            font-size: 0.85rem;
            color: var(--text-muted);
            margin-top: 10px;
        }
    </style>
</head>
<body>
<!-- 动态背景 -->
<div class="dynamic-bg">
    <canvas id="particleSystem" class="particle-system"></canvas>
</div>

<!-- 导航触发按钮 -->
<button class="nav-trigger" onclick="toggleNav()">
    <div class="nav-trigger-icon">
        <span></span>
        <span></span>
        <span></span>
    </div>
</button>

<!-- 智能导航系统 -->
<nav class="smart-nav">
    <div class="nav-bg-decoration"></div>

    <div class="nav-header">
        <h3>🌌 聚类算法学习指南</h3>
        <p class="nav-subtitle">探索数据的内在结构</p>
    </div>

    <ul class="nav-list">
        <li class="nav-item active" data-section="intro">
            <a href="#intro">
                <span class="nav-icon">🚀</span>
                <div class="nav-content">
                    <span class="nav-text">引言：无监督的智慧</span>
                    <div class="nav-meta">
                        <span class="nav-time">3 min</span>
                        <span class="nav-status"></span>
                    </div>
                </div>
            </a>
        </li>
        <li class="nav-item" data-section="overview">
            <a href="#overview">
                <span class="nav-icon">🎯</span>
                <div class="nav-content">
                    <span class="nav-text">8.1 聚类概述</span>
                    <div class="nav-meta">
                        <span class="nav-time">5 min</span>
                        <span class="nav-status"></span>
                    </div>
                </div>
            </a>
        </li>
        <li class="nav-item" data-section="kmeans">
            <a href="#kmeans">
                <span class="nav-icon">⭐</span>
                <div class="nav-content">
                    <span class="nav-text">8.2 K-means聚类</span>
                    <div class="nav-meta">
                        <span class="nav-time">10 min</span>
                        <span class="nav-status"></span>
                    </div>
                </div>
            </a>
        </li>
        <li class="nav-item" data-section="hierarchical">
            <a href="#hierarchical">
                <span class="nav-icon">🌳</span>
                <div class="nav-content">
                    <span class="nav-text">8.3 层次聚类</span>
                    <div class="nav-meta">
                        <span class="nav-time">8 min</span>
                        <span class="nav-status"></span>
                    </div>
                </div>
            </a>
        </li>
        <li class="nav-item" data-section="dbscan">
            <a href="#dbscan">
                <span class="nav-icon">🔍</span>
                <div class="nav-content">
                    <span class="nav-text">8.4 DBSCAN密度聚类</span>
                    <div class="nav-meta">
                        <span class="nav-time">8 min</span>
                        <span class="nav-status"></span>
                    </div>
                </div>
            </a>
        </li>
        <li class="nav-item" data-section="svm-intro">
            <a href="#svm-intro">
                <span class="nav-icon">🎭</span>
                <div class="nav-content">
                    <span class="nav-text">8.5 对比：监督vs无监督</span>
                    <div class="nav-meta">
                        <span class="nav-time">6 min</span>
                        <span class="nav-status"></span>
                    </div>
                </div>
            </a>
        </li>
        <li class="nav-item" data-section="evaluation">
            <a href="#evaluation">
                <span class="nav-icon">📏</span>
                <div class="nav-content">
                    <span class="nav-text">8.6 聚类评估</span>
                    <div class="nav-meta">
                        <span class="nav-time">6 min</span>
                        <span class="nav-status"></span>
                    </div>
                </div>
            </a>
        </li>
        <li class="nav-item" data-section="practice">
            <a href="#practice">
                <span class="nav-icon">🛠️</span>
                <div class="nav-content">
                    <span class="nav-text">8.7 实战：客户分群</span>
                    <div class="nav-meta">
                        <span class="nav-time">12 min</span>
                        <span class="nav-status"></span>
                    </div>
                </div>
            </a>
        </li>
        <li class="nav-item" data-section="summary">
            <a href="#summary">
                <span class="nav-icon">🎓</span>
                <div class="nav-content">
                    <span class="nav-text">8.8 总结与展望</span>
                    <div class="nav-meta">
                        <span class="nav-time">3 min</span>
                        <span class="nav-status"></span>
                    </div>
                </div>
            </a>
        </li>
    </ul>
</nav>

<!-- 进度指示器 -->
<div class="progress-indicator">
    <span>学习进度</span>
    <div class="progress-bar">
        <div class="progress-fill" id="progressFill" style="width: 0%"></div>
    </div>
    <span id="progressText">0%</span>
</div>

<!-- 主容器 -->
<div class="container">
    <!-- 标题部分 -->
    <div class="main-header fade-in">
        <h1 class="main-title">第8章：聚类算法</h1>
        <p class="subtitle">🌌 发现数据的内在结构，探索无监督学习的奥秘</p>
    </div>

    <!-- 引言：无监督的智慧 -->
    <div id="intro" class="section-card fade-in section-anchor">
        <h2 class="section-title">🚀 引言：无监督的智慧</h2>

        <div class="story-box content-box">
            <h3 style="color: #4facfe; margin-bottom: 20px;">📖 星空中的秘密</h3>
            <p style="font-size: 1.1rem; line-height: 1.8;">
                公元前150年，古希腊的夜晚。天文学家<strong>喜帕恰斯</strong>独自仰望星空，眼前是数不清的星点...<br><br>

                "这些星星看似杂乱无章，但一定有某种内在的规律。"他默默思考着。<br>
                没有现代的望远镜，没有计算机，更没有人告诉他哪些星星应该归为一组。<br><br>

                但凭借<span class="highlight-primary">敏锐的观察力</span>和<span class="highlight-secondary">直觉</span>，他开始将位置相近、亮度相似的星星<br>
                连线成图案——<span class="highlight-warning">这就是最早的"聚类思想"</span>！<br><br>

                从此，人类历史上第一批星座诞生了：猎户座、仙女座、天鹅座...<br>
                每一个星座都是一个"簇"，承载着古人对宇宙的理解。
            </p>
            <div style="background: rgba(79, 172, 254, 0.1); padding: 20px; border-radius: 10px; margin-top: 20px; border: 1px solid rgba(79, 172, 254, 0.3);">
                <p style="text-align: center; font-size: 1.2rem; color: #4facfe;">
                    💡 今天，我们用算法重现这个古老的智慧——<br>
                    <strong>让机器学会自主发现数据中的"星座"</strong>
                </p>
            </div>
        </div>

        <div class="thinking-box content-box">
            <h3>🤔 一个有趣的思考实验</h3>
            <p style="margin-bottom: 15px;">想象你是一位外星人类学家，第一次观察地球上的人类社会...</p>

            <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 20px; margin-top: 20px;">
                <div style="background: rgba(79, 172, 254, 0.1); padding: 15px; border-radius: 10px;">
                    <h4 style="color: #4facfe;">👀 你观察到的现象</h4>
                    <ul style="list-style: none; padding: 0; margin-top: 10px;">
                        <li>• 有些人聚集在高楼里</li>
                        <li>• 有些人聚集在田野中</li>
                        <li>• 有些人穿着相似的服装</li>
                        <li>• 有些人说着相同的语言</li>
                    </ul>
                </div>
                <div style="background: rgba(167, 139, 250, 0.1); padding: 15px; border-radius: 10px;">
                    <h4 style="color: #a78bfa;">🧠 你的推理过程</h4>
                    <ul style="list-style: none; padding: 0; margin-top: 10px;">
                        <li>• 相似的个体倾向于聚集</li>
                        <li>• 不同的群体有不同的特征</li>
                        <li>• 可以按职业、地域、文化分类</li>
                        <li>• 每个群体都有自己的模式</li>
                    </ul>
                </div>
            </div>

            <p style="margin-top: 20px; padding: 15px; background: rgba(52, 211, 153, 0.1); border-radius: 10px; border: 1px solid rgba(52, 211, 153, 0.3);">
                🎯 <strong>这就是聚类的本质</strong>：在没有预先标签的情况下，发现数据中隐藏的群体结构和内在模式。
            </p>
        </div>

        <div style="background: linear-gradient(135deg, rgba(251, 191, 36, 0.1), rgba(245, 158, 11, 0.05)); padding: 25px; border-radius: 15px; margin: 20px 0; border: 2px solid rgba(251, 191, 36, 0.3);">
            <h4 style="color: #fbbf24; margin-bottom: 15px;">🌟 从古代智慧到现代算法</h4>

            <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 15px; margin-top: 20px;">
                <div style="text-align: center; padding: 15px;">
                    <div style="font-size: 2rem; margin-bottom: 10px;">🏛️</div>
                    <h5>古代：观星术</h5>
                    <p style="font-size: 0.9rem; color: var(--text-muted);">凭借肉眼观察<br>发现星座</p>
                </div>
                <div style="text-align: center; padding: 15px;">
                    <div style="font-size: 2rem; margin-bottom: 10px;">🔬</div>
                    <h5>近代：分类学</h5>
                    <p style="font-size: 0.9rem; color: var(--text-muted);">生物学家分类<br>动植物种属</p>
                </div>
                <div style="text-align: center; padding: 15px;">
                    <div style="font-size: 2rem; margin-bottom: 10px;">🤖</div>
                    <h5>现代：机器学习</h5>
                    <p style="font-size: 0.9rem; color: var(--text-muted);">算法自动发现<br>数据模式</p>
                </div>
                <div style="text-align: center; padding: 15px;">
                    <div style="font-size: 2rem; margin-bottom: 10px;">🚀</div>
                    <h5>未来：AI探索</h5>
                    <p style="font-size: 0.9rem; color: var(--text-muted);">深度学习挖掘<br>复杂结构</p>
                </div>
            </div>
        </div>
    </div>

    <!-- 8.1 聚类概述 -->
    <div id="overview" class="section-card fade-in section-anchor">
        <h2 class="section-title">🎯 8.1 聚类概述</h2>

        <div class="story-box content-box">
            <h3 style="color: #4facfe;">🎭 监督学习 vs 无监督学习：两种不同的"学习哲学"</h3>
            <p style="margin-bottom: 20px;">
                想象两种完全不同的学习方式：<br>
                一种是<span class="highlight-primary">有老师指导的课堂学习</span>，另一种是<span class="highlight-secondary">独自探索的发现之旅</span>...
            </p>

            <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 20px; margin-top: 20px;">
                <div style="background: rgba(79, 172, 254, 0.1); padding: 20px; border-radius: 10px; border: 1px solid rgba(79, 172, 254, 0.3);">
                    <h4 style="color: #4facfe; margin-bottom: 15px;">🏫 监督学习：课堂模式</h4>
                    <div style="margin-bottom: 15px;">
                        <strong>场景：</strong>老师给学生看了1000张照片<br>
                        每张都标注了"猫"或"狗"
                    </div>
                    <ul style="list-style: none; padding: 0;">
                        <li>✓ 有标签数据（老师的答案）</li>
                        <li>✓ 明确的学习目标</li>
                        <li>✓ 可以量化准确率</li>
                        <li>✓ 适合预测新样本</li>
                    </ul>
                    <p style="margin-top: 10px; font-style: italic; color: var(--text-muted);">
                        "告诉我答案，我学会模仿"
                    </p>
                </div>
                <div style="background: rgba(167, 139, 250, 0.1); padding: 20px; border-radius: 10px; border: 1px solid rgba(167, 139, 250, 0.3);">
                    <h4 style="color: #a78bfa; margin-bottom: 15px;">🔍 无监督学习：探索模式</h4>
                    <div style="margin-bottom: 15px;">
                        <strong>场景：</strong>给学生同样的1000张照片<br>
                        但没有任何标注
                    </div>
                    <ul style="list-style: none; padding: 0;">
                        <li>✓ 无标签数据（自主发现）</li>
                        <li>✓ 探索隐藏结构</li>
                        <li>✓ 发现未知模式</li>
                        <li>✓ 适合数据理解</li>
                    </ul>
                    <p style="margin-top: 10px; font-style: italic; color: var(--text-muted);">
                        "让我自己发现规律"
                    </p>
                </div>
            </div>
        </div>

        <div class="thinking-box content-box">
            <h3>什么是聚类？</h3>
            <p>聚类（Clustering）是一种<span class="highlight-primary">无监督学习</span>方法，目标是将数据集中的样本划分成若干个组（簇），使得：</p>
            <ul style="margin-top: 15px; padding-left: 20px;">
                <li><strong>组内相似性最大</strong>：同一簇中的样本彼此相似</li>
                <li><strong>组间差异性最大</strong>：不同簇中的样本彼此不同</li>
            </ul>
        </div>

        <!-- 聚类应用场景 -->
        <div style="margin: 30px 0;">
            <h3 style="color: #a78bfa; margin-bottom: 20px;">🌍 聚类算法的神奇应用</h3>
            <div class="cluster-results">
                <div class="cluster-card">
                    <div class="cluster-icon">👥</div>
                    <div class="cluster-label">客户细分</div>
                    <div class="cluster-count">市场营销、个性化推荐</div>
                </div>
                <div class="cluster-card">
                    <div class="cluster-icon">🧬</div>
                    <div class="cluster-label">基因分析</div>
                    <div class="cluster-count">疾病分型、药物研发</div>
                </div>
                <div class="cluster-card">
                    <div class="cluster-icon">📷</div>
                    <div class="cluster-label">图像分割</div>
                    <div class="cluster-count">目标检测、医学影像</div>
                </div>
                <div class="cluster-card">
                    <div class="cluster-icon">📄</div>
                    <div class="cluster-label">文档分类</div>
                    <div class="cluster-count">主题发现、信息检索</div>
                </div>
                <div class="cluster-card">
                    <div class="cluster-icon">🏢</div>
                    <div class="cluster-label">异常检测</div>
                    <div class="cluster-count">欺诈检测、故障诊断</div>
                </div>
                <div class="cluster-card">
                    <div class="cluster-icon">🌐</div>
                    <div class="cluster-label">社交网络</div>
                    <div class="cluster-count">社区发现、影响力分析</div>
                </div>
            </div>
        </div>

        <!-- 聚类算法分类 -->
        <div style="margin: 30px 0;">
            <h3 style="color: #a78bfa; margin-bottom: 20px;">🗂️ 聚类算法的大家族</h3>
            <table class="data-table">
                <thead>
                <tr>
                    <th>类型</th>
                    <th>代表算法</th>
                    <th>核心思想</th>
                    <th>优势</th>
                    <th>局限</th>
                </tr>
                </thead>
                <tbody>
                <tr>
                    <td><strong>划分聚类</strong></td>
                    <td>K-means, K-medoids</td>
                    <td>将数据划分为K个互斥的簇</td>
                    <td>简单高效，易于理解</td>
                    <td>需预设K值，对初值敏感</td>
                </tr>
                <tr>
                    <td><strong>层次聚类</strong></td>
                    <td>AGNES, DIANA</td>
                    <td>构建簇的层次结构</td>
                    <td>无需预设簇数，可视化好</td>
                    <td>计算复杂度高</td>
                </tr>
                <tr>
                    <td><strong>密度聚类</strong></td>
                    <td>DBSCAN, OPTICS</td>
                    <td>基于密度连通性</td>
                    <td>可发现任意形状，抗噪声</td>
                    <td>参数敏感，密度不均困难</td>
                </tr>
                <tr>
                    <td><strong>模型聚类</strong></td>
                    <td>GMM, LDA</td>
                    <td>假设数据符合特定分布</td>
                    <td>理论基础强，可解释性好</td>
                    <td>模型假设可能不符</td>
                </tr>
                <tr>
                    <td><strong>网格聚类</strong></td>
                    <td>STING, CLIQUE</td>
                    <td>将空间划分为网格</td>
                    <td>处理大数据快速</td>
                    <td>精度受网格大小影响</td>
                </tr>
                </tbody>
            </table>
        </div>

        <!-- 相似度度量 -->
        <div class="formula-box content-box">
            <h3 style="color: #f472b6; margin-bottom: 20px;">📐 相似度度量：算法的"眼睛"</h3>
            <p style="margin-bottom: 20px;">聚类的核心是度量样本间的相似性，这就像给算法装上"眼睛"，让它学会判断"像"与"不像"：</p>

            <div style="text-align: left; display: inline-block;">
                <p><strong>1. 欧氏距离</strong>（最直观）: d(x,y) = √(∑(xᵢ - yᵢ)²)</p>
                <p><strong>2. 曼哈顿距离</strong>（城市街区）: d(x,y) = ∑|xᵢ - yᵢ|</p>
                <p><strong>3. 余弦相似度</strong>（方向角度）: sim(x,y) = (x·y)/(||x||×||y||)</p>
                <p><strong>4. 马氏距离</strong>（考虑分布）: d(x,y) = √((x-y)ᵀS⁻¹(x-y))</p>
            </div>
        </div>
    </div>

    <!-- 8.2 K-means聚类 -->
    <div id="kmeans" class="section-card fade-in section-anchor">
        <h2 class="section-title">⭐ 8.2 K-means聚类</h2>

        <div class="story-box content-box">
            <h3 style="color: #4facfe;">🎯 一个关于"重心"的故事</h3>
            <p style="margin-bottom: 20px;">
                1967年，斯坦福大学的<strong>Stuart Lloyd</strong>正在研究一个看似简单的问题：<br>
                "如果要在城市中建造K个消防站，怎样选址才能最大化服务效率？"<br><br>

                他的思路很朴素：<br>
                1. 🏢 先随便选K个位置建消防站<br>
                2. 🚑 每个居民都去最近的消防站<br>
                3. 📍 根据居民分布，重新调整消防站位置到"重心"<br>
                4. 🔄 不断重复，直到位置稳定<br><br>

                没想到，这个<span class="highlight-primary">简单而优雅</span>的思想，成就了机器学习中<br>
                <span class="highlight-secondary">最经典的聚类算法</span>——K-means！
            </p>
        </div>

        <!-- K-means算法原理 -->
        <div style="margin: 30px 0;">
            <h3 style="color: #a78bfa; margin-bottom: 20px;">🔄 K-means算法的"四步舞蹈"</h3>
            <div style="background: rgba(79, 172, 254, 0.05); padding: 25px; border-radius: 15px; border: 1px solid rgba(79, 172, 254, 0.3);">
                <ol style="line-height: 2.5; padding-left: 20px;">
                    <li><strong>🎲 初始化</strong>：随机选择K个样本作为初始聚类中心（种子点）</li>
                    <li><strong>📍 分配步骤</strong>：将每个样本分配到距离最近的聚类中心</li>
                    <li><strong>⚖️ 更新步骤</strong>：重新计算每个簇的中心（所有点的均值）</li>
                    <li><strong>🔄 迭代</strong>：重复步骤2-3，直到中心不再变化或达到最大迭代次数</li>
                </ol>
            </div>
        </div>

        <!-- K-means交互式演示 -->
        <div class="demo-container">
            <h3 style="color: #4facfe; text-align: center; margin-bottom: 20px;">🎮 K-means算法可视化体验</h3>
            <canvas id="kmeansCanvas" class="demo-canvas" width="800" height="500"></canvas>
            <div class="iteration-display" id="kmeansIteration">迭代次数: 0</div>

            <div class="param-panel">
                <div class="param-group">
                    <label class="param-label">
                        簇的数量 K:
                        <span class="param-value" id="kValue">3</span>
                    </label>
                    <input type="range" class="param-slider" id="kSlider" min="2" max="8" value="3" onchange="updateK()">
                </div>
                <div class="param-group">
                    <label class="param-label">
                        数据点数量:
                        <span class="param-value" id="pointsValue">150</span>
                    </label>
                    <input type="range" class="param-slider" id="pointsSlider" min="50" max="300" value="150" onchange="updatePoints()">
                </div>
            </div>

            <div class="demo-controls">
                <button class="demo-btn" onclick="generateKMeansData()">🎲 生成数据</button>
                <button class="demo-btn" onclick="initKMeans()">🎯 初始化中心</button>
                <button class="demo-btn" onclick="stepKMeans()">👆 单步执行</button>
                <button class="demo-btn secondary" onclick="runKMeans()">⚡ 自动运行</button>
                <button class="demo-btn secondary" onclick="resetKMeans()">🔄 重置</button>
            </div>
        </div>

        <!-- K-means实现代码 -->
        <div class="code-block">
            <pre><code><span class="keyword">import</span> numpy <span class="keyword">as</span> np
<span class="keyword">from</span> sklearn.cluster <span class="keyword">import</span> KMeans
<span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt

<span class="keyword">class</span> <span class="function">KMeansClusterer</span>:
    <span class="string">"""K-means聚类算法实现 - 经典而优雅"""</span>

    <span class="keyword">def</span> <span class="function">__init__</span>(self, n_clusters=<span class="number">3</span>, max_iters=<span class="number">100</span>, random_state=<span class="number">42</span>):
        self.n_clusters = n_clusters
        self.max_iters = max_iters
        self.random_state = random_state
        self.centroids = <span class="keyword">None</span>
        self.labels = <span class="keyword">None</span>

    <span class="keyword">def</span> <span class="function">fit</span>(self, X):
        <span class="string">"""训练K-means模型 - 开始我们的聚类之旅"""</span>
        np.random.seed(self.random_state)
        n_samples, n_features = X.shape

        <span class="comment"># 🎲 Step 1: 随机初始化聚类中心</span>
        idx = np.random.choice(n_samples, self.n_clusters, replace=<span class="keyword">False</span>)
        self.centroids = X[idx]

        <span class="keyword">for</span> iteration <span class="keyword">in</span> range(self.max_iters):
            <span class="comment"># 📍 Step 2: 分配样本到最近的聚类中心</span>
            distances = self._calculate_distances(X)
            new_labels = np.argmin(distances, axis=<span class="number">1</span>)

            <span class="comment"># ⚖️ Step 3: 更新聚类中心</span>
            new_centroids = np.zeros_like(self.centroids)
            <span class="keyword">for</span> k <span class="keyword">in</span> range(self.n_clusters):
                cluster_points = X[new_labels == k]
                <span class="keyword">if</span> len(cluster_points) > <span class="number">0</span>:
                    new_centroids[k] = cluster_points.mean(axis=<span class="number">0</span>)
                <span class="keyword">else</span>:
                    <span class="comment"># 如果某个簇为空，重新随机初始化</span>
                    new_centroids[k] = X[np.random.choice(n_samples)]

            <span class="comment"># 🔄 Step 4: 检查收敛</span>
            <span class="keyword">if</span> np.allclose(self.centroids, new_centroids, atol=<span class="number">1e-4</span>):
                print(<span class="string">f"算法在第{iteration+1}次迭代后收敛!"</span>)
                <span class="keyword">break</span>

            self.centroids = new_centroids
            self.labels = new_labels

        <span class="keyword">return</span> self

    <span class="keyword">def</span> <span class="function">_calculate_distances</span>(self, X):
        <span class="string">"""计算样本到各聚类中心的欧氏距离"""</span>
        distances = np.zeros((X.shape[<span class="number">0</span>], self.n_clusters))
        <span class="keyword">for</span> k, centroid <span class="keyword">in</span> enumerate(self.centroids):
            distances[:, k] = np.linalg.norm(X - centroid, axis=<span class="number">1</span>)
        <span class="keyword">return</span> distances

    <span class="keyword">def</span> <span class="function">predict</span>(self, X):
        <span class="string">"""预测新样本的簇标签"""</span>
        distances = self._calculate_distances(X)
        <span class="keyword">return</span> np.argmin(distances, axis=<span class="number">1</span>)

    <span class="keyword">def</span> <span class="function">inertia_</span>(self, X):
        <span class="string">"""计算惯性（所有样本到其聚类中心的距离平方和）"""</span>
        inertia = <span class="number">0</span>
        <span class="keyword">for</span> k <span class="keyword">in</span> range(self.n_clusters):
            cluster_points = X[self.labels == k]
            <span class="keyword">if</span> len(cluster_points) > <span class="number">0</span>:
                inertia += np.sum((cluster_points - self.centroids[k]) ** <span class="number">2</span>)
        <span class="keyword">return</span> inertia

<span class="comment"># 🚀 使用示例：让我们开始聚类冒险</span>
<span class="keyword">from</span> sklearn.datasets <span class="keyword">import</span> make_blobs

<span class="comment"># 生成模拟数据</span>
X, y_true = make_blobs(n_samples=<span class="number">300</span>, centers=<span class="number">4</span>,
                      n_features=<span class="number">2</span>, random_state=<span class="number">42</span>)

<span class="comment"># 训练K-means</span>
kmeans = KMeansClusterer(n_clusters=<span class="number">4</span>)
kmeans.fit(X)

<span class="comment"># 可视化结果</span>
plt.figure(figsize=(<span class="number">10</span>, <span class="number">6</span>))
plt.scatter(X[:, <span class="number">0</span>], X[:, <span class="number">1</span>], c=kmeans.labels, cmap=<span class="string">'viridis'</span>, alpha=<span class="number">0.6</span>)
plt.scatter(kmeans.centroids[:, <span class="number">0</span>], kmeans.centroids[:, <span class="number">1</span>],
           c=<span class="string">'red'</span>, marker=<span class="string">'*'</span>, s=<span class="number">300</span>, edgecolors=<span class="string">'black'</span>)
plt.title(<span class="string">'K-means聚类结果：发现数据的内在结构'</span>)
plt.xlabel(<span class="string">'特征1'</span>)
plt.ylabel(<span class="string">'特征2'</span>)
plt.show()

print(<span class="string">f"💫 惯性值: {kmeans.inertia_(X):.2f}"</span>)</code></pre>
        </div>

        <!-- K-means的优缺点 -->
        <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 20px; margin-top: 30px;">
            <div style="background: rgba(52, 211, 153, 0.1); padding: 25px; border-radius: 15px; border: 2px solid rgba(52, 211, 153, 0.3);">
                <h4 style="color: #34d399; margin-bottom: 15px;">✅ K-means的超能力</h4>
                <ul style="list-style: none; padding: 0;">
                    <li>⚡ 算法简单，运行速度飞快</li>
                    <li>🎯 易于理解和实现</li>
                    <li>📈 计算效率高，适合大规模数据</li>
                    <li>⭕ 对球形簇效果出色</li>
                    <li>🔄 收敛速度快</li>
                </ul>
            </div>
            <div style="background: rgba(244, 114, 182, 0.1); padding: 25px; border-radius: 15px; border: 2px solid rgba(244, 114, 182, 0.3);">
                <h4 style="color: #f472b6; margin-bottom: 15px;">⚠️ K-means的"阿喀琉斯之踵"</h4>
                <ul style="list-style: none; padding: 0;">
                    <li>🤔 需要预先指定K值（最大痛点）</li>
                    <li>🎲 对初始中心敏感</li>
                    <li>⭕ 只能发现球形簇</li>
                    <li>📊 对噪声和异常值敏感</li>
                    <li>⚖️ 簇大小差异大时效果差</li>
                </ul>
            </div>
        </div>

        <!-- 选择最优K值 -->
        <div class="thinking-box content-box" style="margin-top: 30px;">
            <h3>🎯 选择最优K值的"三大法宝"</h3>
            <div style="margin-top: 20px;">
                <div style="margin-bottom: 20px; padding: 15px; background: rgba(79, 172, 254, 0.1); border-radius: 10px;">
                    <p><strong>1. 🦵 肘部法则（Elbow Method）</strong></p>
                    <p style="margin-left: 20px; color: var(--text-muted);">绘制不同K值对应的SSE，寻找曲线的"肘部"——就像手臂弯曲的地方</p>
                </div>

                <div style="margin-bottom: 20px; padding: 15px; background: rgba(167, 139, 250, 0.1); border-radius: 10px;">
                    <p><strong>2. 👤 轮廓系数（Silhouette Score）</strong></p>
                    <p style="margin-left: 20px; color: var(--text-muted);">衡量样本与自身簇的相似度和与其他簇的差异度</p>
                </div>

                <div style="padding: 15px; background: rgba(244, 114, 182, 0.1); border-radius: 10px;">
                    <p><strong>3. 📊 Gap统计量</strong></p>
                    <p style="margin-left: 20px; color: var(--text-muted);">比较观察数据和参考分布的离散程度</p>
                </div>
            </div>
        </div>
    </div>

    <!-- 8.3 层次聚类 -->
    <div id="hierarchical" class="section-card fade-in section-anchor">
        <h2 class="section-title">🌳 8.3 层次聚类</h2>

        <div class="story-box content-box">
            <h3 style="color: #4facfe;">🌲 构建数据的"族谱树"</h3>
            <p style="margin-bottom: 20px;">
                1847年，<strong>查尔斯·达尔文</strong>在构思《物种起源》时，绘制了第一张"生命之树"...<br><br>

                他发现所有生物都可以用树状结构来表示关系：<br>
                🌱 从个体开始 → 物种 → 属 → 科 → 目 → 纲 → 门 → 界<br><br>

                这种<span class="highlight-primary">"层次化"</span>的思想，启发了后世的计算机科学家：<br>
                如果数据点也像生物一样，有着天然的<span class="highlight-secondary">层次关系</span>呢？<br><br>

                于是，层次聚类诞生了——它能够构建出数据的"族谱图"！
            </p>
        </div>

        <!-- 层次聚类类型 -->
        <div style="margin: 30px 0;">
            <h3 style="color: #a78bfa; margin-bottom: 20px;">🔀 两种策略：自底向上 vs 自顶向下</h3>
            <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 20px;">
                <div style="background: rgba(79, 172, 254, 0.1); padding: 25px; border-radius: 15px; border: 2px solid rgba(79, 172, 254, 0.3);">
                    <h4 style="color: #4facfe; margin-bottom: 15px;">🔼 凝聚式（AGNES）</h4>
                    <p><strong>"合并的艺术"</strong> — 自底向上策略：</p>
                    <ol style="padding-left: 20px; margin-top: 15px; line-height: 1.8;">
                        <li>🌱 开始时每个样本是一个簇</li>
                        <li>📏 计算所有簇间距离</li>
                        <li>🤝 合并最近的两个簇</li>
                        <li>🔄 重复直到只剩一个大簇</li>
                    </ol>
                    <p style="margin-top: 15px; font-style: italic; color: var(--text-muted);">
                        "万物归一，从分散到统一"
                    </p>
                </div>
                <div style="background: rgba(167, 139, 250, 0.1); padding: 25px; border-radius: 15px; border: 2px solid rgba(167, 139, 250, 0.3);">
                    <h4 style="color: #a78bfa; margin-bottom: 15px;">🔽 分裂式（DIANA）</h4>
                    <p><strong>"分解的智慧"</strong> — 自顶向下策略：</p>
                    <ol style="padding-left: 20px; margin-top: 15px; line-height: 1.8;">
                        <li>🌍 开始时所有样本在一个簇中</li>
                        <li>🎯 选择一个簇进行分裂</li>
                        <li>✂️ 将该簇分成两个子簇</li>
                        <li>🔄 重复直到每个样本独立成簇</li>
                    </ol>
                    <p style="margin-top: 15px; font-style: italic; color: var(--text-muted);">
                        "一生二，从整体到细节"
                    </p>
                </div>
            </div>
        </div>

        <!-- 簇间距离度量 -->
        <div class="formula-box content-box">
            <h3 style="color: #f472b6; margin-bottom: 20px;">📏 簇间距离的四种"测量法"</h3>
            <div style="text-align: left; display: inline-block;">
                <div style="margin-bottom: 15px;">
                    <p><strong>1. 🔗 单链接（Single Linkage）</strong>：最近邻距离</p>
                    <p style="margin-left: 20px; color: var(--text-muted);">d(C₁, C₂) = min{d(x, y) | x∈C₁, y∈C₂}</p>
                </div>

                <div style="margin-bottom: 15px;">
                    <p><strong>2. 🔗 全链接（Complete Linkage）</strong>：最远邻距离</p>
                    <p style="margin-left: 20px; color: var(--text-muted);">d(C₁, C₂) = max{d(x, y) | x∈C₁, y∈C₂}</p>
                </div>

                <div style="margin-bottom: 15px;">
                    <p><strong>3. 🔗 平均链接（Average Linkage）</strong>：平均距离</p>
                    <p style="margin-left: 20px; color: var(--text-muted);">d(C₁, C₂) = avg{d(x, y) | x∈C₁, y∈C₂}</p>
                </div>

                <div>
                    <p><strong>4. 🔗 Ward链接</strong>：最小化簇内方差</p>
                    <p style="margin-left: 20px; color: var(--text-muted);">最小化合并后的簇内平方和增量</p>
                </div>
            </div>
        </div>

        <!-- 层次聚类演示 -->
        <div class="demo-container">
            <h3 style="color: #4facfe; text-align: center; margin-bottom: 20px;">🌳 层次聚类树状图生成器</h3>
            <canvas id="hierarchicalCanvas" class="demo-canvas" width="800" height="500"></canvas>

            <div class="param-panel">
                <div class="param-group">
                    <label class="param-label">链接方法:</label>
                    <select id="linkageMethod" onchange="updateHierarchical()" style="padding: 5px 10px; border-radius: 5px; background: var(--bg-secondary); color: var(--text-primary); border: 1px solid var(--border-primary);">
                        <option value="single">单链接</option>
                        <option value="complete">全链接</option>
                        <option value="average" selected>平均链接</option>
                        <option value="ward">Ward链接</option>
                    </select>
                </div>
                <div class="param-group">
                    <label class="param-label">
                        切割高度:
                        <span class="param-value" id="cutHeightValue">2.5</span>
                    </label>
                    <input type="range" class="param-slider" id="cutHeightSlider" min="0" max="5" step="0.1" value="2.5" onchange="updateCutHeight()">
                </div>
            </div>

            <div class="demo-controls">
                <button class="demo-btn" onclick="generateHierarchicalData()">🌱 生成数据</button>
                <button class="demo-btn" onclick="buildDendrogram()">🌳 构建树状图</button>
                <button class="demo-btn secondary" onclick="cutDendrogram()">✂️ 切割树</button>
                <button class="demo-btn secondary" onclick="animateMerging()">🎬 合并动画</button>
            </div>
        </div>

        <!-- 层次聚类的优缺点 -->
        <div style="background: rgba(167, 139, 250, 0.1); padding: 25px; border-radius: 15px; margin-top: 30px; border: 2px solid rgba(167, 139, 250, 0.3);">
            <h4 style="color: #a78bfa; margin-bottom: 15px;">💡 层次聚类的"双面性"</h4>
            <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 20px;">
                <div>
                    <h5 style="color: #34d399;">🌟 独特优势：</h5>
                    <ul style="padding-left: 20px; line-height: 1.8;">
                        <li>🎯 无需预先指定簇数</li>
                        <li>📊 提供不同粒度的聚类结果</li>
                        <li>🌳 树状图直观易懂</li>
                        <li>🔍 能够发现簇的层次关系</li>
                        <li>⚖️ 结果具有确定性</li>
                    </ul>
                </div>
                <div>
                    <h5 style="color: #f472b6;">⚠️ 现实挑战：</h5>
                    <ul style="padding-left: 20px; line-height: 1.8;">
                        <li>🐌 计算复杂度高 O(n²log n)</li>
                        <li>💾 内存需求大</li>
                        <li>❌ 一旦合并无法撤销</li>
                        <li>📉 对噪声和异常值敏感</li>
                        <li>⚖️ 不同链接方法结果差异大</li>
                    </ul>
                </div>
            </div>
        </div>
    </div>

    <!-- 8.4 DBSCAN密度聚类 -->
    <div id="dbscan" class="section-card fade-in section-anchor">
        <h2 class="section-title">🔍 8.4 DBSCAN密度聚类</h2>

        <div class="story-box content-box">
            <h3 style="color: #4facfe;">🌟 "密度"中隐藏的智慧</h3>
            <p style="margin-bottom: 20px;">
                1996年，德国慕尼黑，<strong>Martin Ester</strong>和他的团队正在研究一个棘手的问题：<br>
                "如何识别城市中的居民聚集区？"<br><br>

                传统方法遇到了困境：<br>
                🏠 有些区域人口密集，形状不规则<br>
                🌳 有些区域稀疏散布着独立住宅<br>
                🏭 工业区几乎没有居民...<br><br>

                突然，Ester灵机一动：<br>
                <span class="highlight-primary">"人群聚集的地方，密度一定很高！"</span><br><br>

                基于这个朴素而深刻的观察，DBSCAN诞生了：<br>
                <span class="highlight-secondary">簇 = 高密度区域</span>，被低密度区域分隔开来。
            </p>
        </div>

        <div class="thinking-box content-box">
            <h3>🧠 DBSCAN的"四个角色"</h3>
            <p style="margin-bottom: 20px;">想象一个繁华的城市，DBSCAN将每个数据点分为四种角色：</p>

            <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 15px; margin-top: 20px;">
                <div style="background: rgba(79, 172, 254, 0.1); padding: 15px; border-radius: 10px;">
                    <h4 style="color: #4facfe;">🏙️ 核心点（Core Point）</h4>
                    <p style="font-size: 0.9rem;">邻域内至少有MinPts个点<br>就像繁华的市中心</p>
                </div>
                <div style="background: rgba(251, 191, 36, 0.1); padding: 15px; border-radius: 10px;">
                    <h4 style="color: #fbbf24;">🏘️ 边界点（Border Point）</h4>
                    <p style="font-size: 0.9rem;">在核心点的邻域内，但自己不是核心点<br>就像市中心周边的住宅区</p>
                </div>
                <div style="background: rgba(244, 114, 182, 0.1); padding: 15px; border-radius: 10px;">
                    <h4 style="color: #f472b6;">🌾 噪声点（Noise Point）</h4>
                    <p style="font-size: 0.9rem;">既不是核心点也不是边界点<br>就像偏远的孤立农庄</p>
                </div>
                <div style="background: rgba(52, 211, 153, 0.1); padding: 15px; border-radius: 10px;">
                    <h4 style="color: #34d399;">📏 ε-邻域</h4>
                    <p style="font-size: 0.9rem;">距离不超过ε的所有点的集合<br>就像步行可达的范围</p>
                </div>
            </div>

            <div style="margin-top: 20px; padding: 15px; background: rgba(167, 139, 250, 0.1); border-radius: 10px;">
                <p style="text-align: center;"><strong>🔗 密度可达</strong>：从核心点出发，通过一系列核心点可以到达的点属于同一簇</p>
            </div>
        </div>

        <!-- DBSCAN交互式演示 -->
        <div class="demo-container">
            <h3 style="color: #4facfe; text-align: center; margin-bottom: 20px;">🔍 DBSCAN密度探测器</h3>
            <canvas id="dbscanCanvas" class="demo-canvas" width="800" height="500"></canvas>

            <div class="param-panel">
                <div class="param-group">
                    <label class="param-label">
                        邻域半径 ε:
                        <span class="param-value" id="epsValue">0.3</span>
                    </label>
                    <input type="range" class="param-slider" id="epsSlider" min="0.1" max="1.0" step="0.05" value="0.3" onchange="updateDBSCAN()">
                </div>
                <div class="param-group">
                    <label class="param-label">
                        最小点数 MinPts:
                        <span class="param-value" id="minPtsValue">5</span>
                    </label>
                    <input type="range" class="param-slider" id="minPtsSlider" min="2" max="20" value="5" onchange="updateDBSCAN()">
                </div>
                <div class="param-group">
                    <label class="param-label">数据分布:</label>
                    <select id="dataDistribution" onchange="generateDBSCANData()" style="padding: 5px 10px; border-radius: 5px; background: var(--bg-secondary); color: var(--text-primary); border: 1px solid var(--border-primary);">
                        <option value="moons">🌙 月牙形</option>
                        <option value="circles">⭕ 同心圆</option>
                        <option value="blobs">🔵 团状</option>
                        <option value="aniso">📐 各向异性</option>
                    </select>
                </div>
            </div>

            <div class="demo-controls">
                <button class="demo-btn" onclick="generateDBSCANData()">🎲 生成数据</button>
                <button class="demo-btn" onclick="runDBSCAN()">🔍 运行DBSCAN</button>
                <button class="demo-btn secondary" onclick="showPointTypes()">👁️ 显示点类型</button>
                <button class="demo-btn secondary" onclick="animateDBSCAN()">🎬 扫描动画</button>
            </div>

            <div class="cluster-results" style="margin-top: 20px;">
                <div class="cluster-card">
                    <div class="cluster-icon">🔵</div>
                    <div class="cluster-label">核心点</div>
                    <div class="cluster-count" id="coreCount">0</div>
                </div>
                <div class="cluster-card">
                    <div class="cluster-icon">🟡</div>
                    <div class="cluster-label">边界点</div>
                    <div class="cluster-count" id="borderCount">0</div>
                </div>
                <div class="cluster-card">
                    <div class="cluster-icon">⚫</div>
                    <div class="cluster-label">噪声点</div>
                    <div class="cluster-count" id="noiseCount">0</div>
                </div>
            </div>
        </div>

        <!-- DBSCAN vs K-means 对比故事 -->
        <div style="margin-top: 30px;">
            <h3 style="color: #a78bfa; margin-bottom: 20px;">⚔️ 算法大PK：DBSCAN vs K-means</h3>
            <table class="data-table">
                <thead>
                <tr>
                    <th>特性</th>
                    <th>🔍 DBSCAN</th>
                    <th>⭐ K-means</th>
                </tr>
                </thead>
                <tbody>
                <tr>
                    <td><strong>簇数</strong></td>
                    <td>🎯 自动确定</td>
                    <td>❓ 需要预先指定</td>
                </tr>
                <tr>
                    <td><strong>簇形状</strong></td>
                    <td>🌙 任意形状</td>
                    <td>⭕ 球形</td>
                </tr>
                <tr>
                    <td><strong>噪声处理</strong></td>
                    <td>✅ 可以识别噪声点</td>
                    <td>❌ 将噪声分配到最近簇</td>
                </tr>
                <tr>
                    <td><strong>簇大小</strong></td>
                    <td>📏 可以不同</td>
                    <td>⚖️ 倾向相似大小</td>
                </tr>
                <tr>
                    <td><strong>参数敏感性</strong></td>
                    <td>⚠️ 对ε和MinPts敏感</td>
                    <td>⚠️ 对初始中心敏感</td>
                </tr>
                <tr>
                    <td><strong>计算复杂度</strong></td>
                    <td>📊 O(n log n) ~ O(n²)</td>
                    <td>⚡ O(nkt)</td>
                </tr>
                </tbody>
            </table>
        </div>
    </div>

    <!-- 8.5 对比：监督vs无监督 -->
    <div id="svm-intro" class="section-card fade-in section-anchor">
        <h2 class="section-title">🎭 8.5 对比：监督学习的智慧</h2>

        <div class="story-box content-box">
            <h3 style="color: #4facfe;">🤖 AI学习的两条路径</h3>
            <p style="margin-bottom: 20px;">
                想象一下，AI学习就像人类的成长过程...<br><br>

                <span class="highlight-primary">监督学习</span>就像传统的学校教育：<br>
                👨‍🏫 老师告诉你："这是猫，这是狗"<br>
                📚 学生通过大量标注的例子学会分辨<br>
                📝 最后考试时，能够正确识别新的猫狗图片<br><br>

                而<span class="highlight-secondary">无监督学习</span>则像自主探索：<br>
                🔍 没有老师，只给你很多动物图片<br>
                🧠 你需要自己发现："哪些长得像？应该归为一类？"<br>
                💡 最终形成自己的分类体系
            </p>
        </div>

        <div class="thinking-box content-box">
            <h3>🎯 监督学习的代表：支持向量机（SVM）</h3>
            <p style="margin-bottom: 20px;">让我们快速了解一个经典的监督学习算法，来对比聚类的特点：</p>

            <div style="background: rgba(79, 172, 254, 0.1); padding: 20px; border-radius: 10px; margin-top: 20px;">
                <h4 style="color: #4facfe; margin-bottom: 15px;">🎯 SVM的核心思想</h4>
                <p>SVM寻找一个<strong>"间隔最大"</strong>的超平面来分隔不同类别的数据：</p>
                <ul style="margin-top: 10px; padding-left: 20px;">
                    <li>📏 最大化超平面到最近数据点的距离</li>
                    <li>🎯 支持向量决定了超平面的位置</li>
                    <li>🚀 通过核函数处理非线性问题</li>
                    <li>⚖️ 具有强大的泛化能力</li>
                </ul>
            </div>
        </div>

        <!-- 监督vs无监督对比表 -->
        <div style="margin: 30px 0;">
            <h3 style="color: #a78bfa; margin-bottom: 20px;">📊 两种学习模式的深度对比</h3>
            <table class="data-table">
                <thead>
                <tr>
                    <th>维度</th>
                    <th>🏫 监督学习（如SVM）</th>
                    <th>🔍 无监督学习（如聚类）</th>
                </tr>
                </thead>
                <tbody>
                <tr>
                    <td><strong>数据类型</strong></td>
                    <td>有标签数据（x, y）</td>
                    <td>无标签数据（x）</td>
                </tr>
                <tr>
                    <td><strong>学习目标</strong></td>
                    <td>学习输入到输出的映射</td>
                    <td>发现数据的内在结构</td>
                </tr>
                <tr>
                    <td><strong>典型任务</strong></td>
                    <td>分类、回归、预测</td>
                    <td>聚类、降维、异常检测</td>
                </tr>
                <tr>
                    <td><strong>评估方式</strong></td>
                    <td>准确率、F1分数等</td>
                    <td>轮廓系数、专家评价等</td>
                </tr>
                <tr>
                    <td><strong>应用场景</strong></td>
                    <td>已知问题类型，需要预测</td>
                    <td>探索性分析，发现模式</td>
                </tr>
                <tr>
                    <td><strong>挑战</strong></td>
                    <td>需要大量标注数据</td>
                    <td>结果解释和验证困难</td>
                </tr>
                </tbody>
            </table>
        </div>

        <!-- 应用场景对比 -->
        <div style="background: linear-gradient(135deg, rgba(167, 139, 250, 0.1), rgba(129, 140, 248, 0.05)); padding: 25px; border-radius: 15px; margin-top: 30px; border: 2px solid rgba(167, 139, 250, 0.3);">
            <h4 style="color: #a78bfa; margin-bottom: 20px;">🌟 实际应用场景对比</h4>

            <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 20px;">
                <div>
                    <h5 style="color: #4facfe;">🏫 监督学习的舞台</h5>
                    <ul style="padding-left: 20px; line-height: 1.8;">
                        <li>📧 垃圾邮件分类</li>
                        <li>🏥 疾病诊断系统</li>
                        <li>📈 股价预测模型</li>
                        <li>🗣️ 语音识别系统</li>
                        <li>🖼️ 图像识别分类</li>
                    </ul>
                </div>
                <div>
                    <h5 style="color: #a78bfa;">🔍 无监督学习的天地</h5>
                    <ul style="padding-left: 20px; line-height: 1.8;">
                        <li>👥 客户行为分析</li>
                        <li>🧬 基因序列分析</li>
                        <li>📊 市场细分研究</li>
                        <li>🌐 社交网络分析</li>
                        <li>🔒 异常行为检测</li>
                    </ul>
                </div>
            </div>

            <div style="margin-top: 20px; padding: 15px; background: rgba(52, 211, 153, 0.1); border-radius: 10px; text-align: center;">
                <p style="font-size: 1.1rem;"><strong>💡 关键洞察</strong>：监督学习回答"是什么"，无监督学习探索"有什么"</p>
            </div>
        </div>
    </div>

    <!-- 8.6 聚类评估 -->
    <div id="evaluation" class="section-card fade-in section-anchor">
        <h2 class="section-title">📏 8.6 聚类评估</h2>

        <div class="story-box content-box">
            <h3 style="color: #4facfe;">🤔 没有标准答案的"考试"</h3>
            <p style="margin-bottom: 20px;">
                想象你是一位艺术评论家，面对一幅抽象画...<br><br>

                🎨 画家没有告诉你这幅画的"正确"解释<br>
                👀 每个人看到的东西可能都不一样<br>
                🤷‍♂️ 那么，如何评价这幅画的"好坏"呢？<br><br>

                聚类评估面临着同样的挑战：<br>
                <span class="highlight-primary">没有"标准答案"</span>，我们如何知道聚类结果的质量？<br><br>

                这就需要我们从<span class="highlight-secondary">"内在美"</span>和<span class="highlight-warning">"外在比较"</span>两个角度来评判！
            </p>
        </div>

        <div class="thinking-box content-box">
            <h3>评估的"双重视角"</h3>
            <p style="margin-bottom: 20px;">
                聚类评估就像品味艺术作品，需要两种不同的视角：
            </p>

            <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 20px; margin-top: 20px;">
                <div style="background: rgba(79, 172, 254, 0.1); padding: 20px; border-radius: 10px;">
                    <h4 style="color: #4facfe;">📐 内部视角</h4>
                    <p style="margin-bottom: 10px;"><strong>"这幅画的构图如何？"</strong></p>
                    <ul style="list-style: none; padding: 0;">
                        <li>✓ 只看聚类结果本身</li>
                        <li>✓ 不需要真实标签</li>
                        <li>✓ 关注簇的紧密度和分离度</li>
                        <li>✓ 客观的几何度量</li>
                    </ul>
                </div>
                <div style="background: rgba(167, 139, 250, 0.1); padding: 20px; border-radius: 10px;">
                    <h4 style="color: #a78bfa;">🏷️ 外部视角</h4>
                    <p style="margin-bottom: 10px;"><strong>"这幅画符合预期吗？"</strong></p>
                    <ul style="list-style: none; padding: 0;">
                        <li>✓ 与已知的"标准答案"比较</li>
                        <li>✓ 需要真实标签</li>
                        <li>✓ 衡量与期望结果的一致性</li>
                        <li>✓ 主观的匹配度量</li>
                    </ul>
                </div>
            </div>
        </div>

        <!-- 评估指标体系 -->
        <div style="margin: 30px 0;">
            <h3 style="color: #a78bfa; margin-bottom: 20px;">📊 聚类评估指标体系</h3>

            <!-- 内部指标 -->
            <div style="background: rgba(79, 172, 254, 0.05); padding: 25px; border-radius: 15px; margin-bottom: 20px; border: 1px solid rgba(79, 172, 254, 0.3);">
                <h4 style="color: #4facfe; margin-bottom: 15px;">📐 内部指标：聚类的"内在美"</h4>

                <div class="metric-cards">
                    <div class="metric-card">
                        <div class="metric-icon">👤</div>
                        <div class="metric-name">轮廓系数</div>
                        <div class="metric-value">S(i)</div>
                        <div class="metric-description">
                            衡量样本与自身簇的紧密度和与其他簇的分离度<br>
                            取值范围：[-1, 1]，越大越好
                        </div>
                    </div>
                    <div class="metric-card">
                        <div class="metric-icon">🎯</div>
                        <div class="metric-name">Davies-Bouldin指数</div>
                        <div class="metric-value">DBI</div>
                        <div class="metric-description">
                            簇内距离与簇间距离的比值<br>
                            越小表示聚类效果越好
                        </div>
                    </div>
                    <div class="metric-card">
                        <div class="metric-icon">📍</div>
                        <div class="metric-name">Calinski-Harabasz指数</div>
                        <div class="metric-value">CHI</div>
                        <div class="metric-description">
                            簇间方差与簇内方差的比值<br>
                            越大表示簇越紧密、分离越好
                        </div>
                    </div>
                </div>
            </div>

            <!-- 外部指标 -->
            <div style="background: rgba(167, 139, 250, 0.05); padding: 25px; border-radius: 15px; border: 1px solid rgba(167, 139, 250, 0.3);">
                <h4 style="color: #a78bfa; margin-bottom: 15px;">🏷️ 外部指标：与"标准答案"的匹配度</h4>

                <div class="metric-cards">
                    <div class="metric-card">
                        <div class="metric-icon">🎲</div>
                        <div class="metric-name">兰德指数</div>
                        <div class="metric-value">RI/ARI</div>
                        <div class="metric-description">
                            衡量聚类结果与真实标签的一致性<br>
                            ARI调整了随机性，取值[-1, 1]
                        </div>
                    </div>
                    <div class="metric-card">
                        <div class="metric-icon">📊</div>
                        <div class="metric-name">互信息</div>
                        <div class="metric-value">MI/NMI</div>
                        <div class="metric-description">
                            基于信息论的相似度度量<br>
                            NMI归一化到[0, 1]范围
                        </div>
                    </div>
                    <div class="metric-card">
                        <div class="metric-icon">🎭</div>
                        <div class="metric-name">同质性与完整性</div>
                        <div class="metric-value">H & C</div>
                        <div class="metric-description">
                            同质性：每个簇只包含单一类别<br>
                            完整性：同类别样本被分到同一簇
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <!-- 轮廓系数详解 -->
        <div class="formula-box content-box">
            <h3 style="color: #f472b6; margin-bottom: 20px;">👤 轮廓系数：聚类质量的"体检报告"</h3>
            <div style="text-align: left; margin: 20px 0;">
                <p style="margin-bottom: 15px;">轮廓系数就像给每个数据点做"体检"，看它在当前簇中是否"健康"：</p>

                <div style="background: rgba(79, 172, 254, 0.1); padding: 15px; border-radius: 10px; margin: 15px 0;">
                    <p><strong>对于样本i：</strong></p>
                    <p>1. <strong>a(i)</strong> = i与同簇其他样本的平均距离（内聚度）</p>
                    <p>2. <strong>b(i)</strong> = i与最近的其他簇中所有样本的平均距离（分离度）</p>
                    <p>3. <strong>s(i)</strong> = (b(i) - a(i)) / max(a(i), b(i))</p>
                </div>

                <p style="text-align: center; margin-top: 20px; font-size: 1.2rem;">
                    <strong>总轮廓系数 = 所有样本s(i)的平均值</strong>
                </p>
            </div>
        </div>

        <!-- 评估演示 -->
        <div class="demo-container">
            <h3 style="color: #4facfe; text-align: center; margin-bottom: 20px;">📊 聚类评估实验室</h3>
            <canvas id="evaluationCanvas" class="demo-canvas" width="800" height="500"></canvas>

            <div class="param-panel">
                <div class="param-group">
                    <label class="param-label">评估指标:</label>
                    <select id="metricType" onchange="updateEvaluation()" style="padding: 5px 10px; border-radius: 5px; background: var(--bg-secondary); color: var(--text-primary); border: 1px solid var(--border-primary);">
                        <option value="silhouette">👤 轮廓系数</option>
                        <option value="elbow">🦵 肘部法则</option>
                        <option value="comparison">⚔️ 算法比较</option>
                    </select>
                </div>
            </div>

            <div class="demo-controls">
                <button class="demo-btn" onclick="generateEvalData()">🎲 生成数据</button>
                <button class="demo-btn" onclick="runEvaluation()">📊 计算指标</button>
                <button class="demo-btn secondary" onclick="compareAlgorithms()">⚔️ 比较算法</button>
                <button class="demo-btn secondary" onclick="showMetricDetails()">📋 指标详情</button>
            </div>
        </div>
    </div>

    <!-- 8.7 实战：客户分群 -->
    <div id="practice" class="section-card fade-in section-anchor">
        <h2 class="section-title">🛠️ 8.7 实战：客户分群系统</h2>

        <div class="story-box content-box">
            <h3 style="color: #4facfe;">🛍️ 电商巨头的"秘密武器"</h3>
            <p style="margin-bottom: 20px;">
                2019年，某知名电商平台面临一个关键挑战：<br>
                拥有1亿活跃用户，但营销效果越来越差...<br><br>

                💸 广告费用逐年攀升<br>
                📉 转化率持续下降<br>
                😤 用户抱怨推荐不精准<br><br>

                数据科学团队提出了一个大胆的想法：<br>
                <span class="highlight-primary">"如果我们能够理解每一类客户的特征和需求..."</span><br><br>

                于是，他们构建了一个<span class="highlight-secondary">智能客户分群系统</span>：<br>
                📊 RFM分析 + 机器学习聚类<br>
                🎯 个性化营销策略<br>
                💰 营销ROI提升了300%！
            </p>
        </div>

        <!-- 项目流程 -->
        <div style="margin: 30px 0;">
            <h3 style="color: #a78bfa; margin-bottom: 20px;">🔄 客户分群项目的"七步法"</h3>
            <div style="background: linear-gradient(135deg, rgba(79, 172, 254, 0.05), rgba(167, 139, 250, 0.05)); padding: 30px; border-radius: 15px; border: 1px solid rgba(79, 172, 254, 0.3);">
                <ol style="line-height: 2.5; padding-left: 20px;">
                    <li><strong>🏗️ 业务理解</strong>：明确分群目标和业务价值</li>
                    <li><strong>📊 数据收集</strong>：获取客户交易数据（RFM分析）</li>
                    <li><strong>🔧 特征工程</strong>：计算Recency、Frequency、Monetary特征</li>
                    <li><strong>🧹 数据预处理</strong>：标准化、异常值处理、缺失值填补</li>
                    <li><strong>🔍 探索性分析</strong>：了解数据分布和相关性</li>
                    <li><strong>🤖 聚类分析</strong>：尝试多种算法，选择最优方案</li>
                    <li><strong>💡 策略制定</strong>：为每个客群定义特征和营销策略</li>
                </ol>
            </div>
        </div>

        <!-- RFM模型详解 -->
        <div class="thinking-box content-box">
            <h3>📈 RFM模型：客户价值的"三维透视"</h3>
            <p style="margin-bottom: 20px;">RFM是客户分析的经典框架，就像用三把"尺子"丈量客户价值：</p>

            <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 15px; margin-top: 20px;">
                <div style="background: rgba(79, 172, 254, 0.1); padding: 15px; border-radius: 10px; text-align: center;">
                    <h4 style="color: #4facfe;">📅 Recency</h4>
                    <p style="font-size: 0.9rem;">最近购买时间</p>
                    <p style="font-size: 0.8rem; color: var(--text-muted);">客户活跃度指标</p>
                </div>
                <div style="background: rgba(167, 139, 250, 0.1); padding: 15px; border-radius: 10px; text-align: center;">
                    <h4 style="color: #a78bfa;">🔄 Frequency</h4>
                    <p style="font-size: 0.9rem;">购买频率</p>
                    <p style="font-size: 0.8rem; color: var(--text-muted);">客户忠诚度指标</p>
                </div>
                <div style="background: rgba(244, 114, 182, 0.1); padding: 15px; border-radius: 10px; text-align: center;">
                    <h4 style="color: #f472b6;">💰 Monetary</h4>
                    <p style="font-size: 0.9rem;">消费金额</p>
                    <p style="font-size: 0.8rem; color: var(--text-muted);">客户价值指标</p>
                </div>
            </div>
        </div>

        <!-- 实战代码示例 -->
        <div class="code-block">
            <pre><code><span class="keyword">import</span> pandas <span class="keyword">as</span> pd
<span class="keyword">import</span> numpy <span class="keyword">as</span> np
<span class="keyword">from</span> sklearn.preprocessing <span class="keyword">import</span> StandardScaler
<span class="keyword">from</span> sklearn.cluster <span class="keyword">import</span> KMeans, DBSCAN, AgglomerativeClustering
<span class="keyword">from</span> sklearn.metrics <span class="keyword">import</span> silhouette_score
<span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt
<span class="keyword">import</span> seaborn <span class="keyword">as</span> sns

<span class="keyword">class</span> <span class="function">CustomerSegmentation</span>:
    <span class="string">"""客户分群系统 - 从数据洞察到业务价值"""</span>

    <span class="keyword">def</span> <span class="function">__init__</span>(self):
        self.scaler = StandardScaler()
        self.rfm_df = <span class="keyword">None</span>
        self.clusters = <span class="keyword">None</span>

    <span class="keyword">def</span> <span class="function">calculate_rfm</span>(self, df, customer_id, order_date, amount):
        <span class="string">"""计算RFM特征 - 客户价值的三维度量"""</span>
        <span class="comment"># 设置分析基准日期</span>
        analysis_date = df[order_date].max() + pd.Timedelta(days=<span class="number">1</span>)

        <span class="comment"># RFM计算</span>
        rfm = df.groupby(customer_id).agg({
            order_date: <span class="keyword">lambda</span> x: (analysis_date - x.max()).days,  <span class="comment"># Recency</span>
            amount: [<span class="string">'count'</span>, <span class="string">'sum'</span>]  <span class="comment"># Frequency & Monetary</span>
        })

        <span class="comment"># 重命名列</span>
        rfm.columns = [<span class="string">'Recency'</span>, <span class="string">'Frequency'</span>, <span class="string">'Monetary'</span>]
        rfm = rfm.reset_index()

        <span class="comment"># 处理异常值：使用IQR方法</span>
        <span class="keyword">for</span> col <span class="keyword">in</span> [<span class="string">'Recency'</span>, <span class="string">'Frequency'</span>, <span class="string">'Monetary'</span>]:
            Q1 = rfm[col].quantile(<span class="number">0.25</span>)
            Q3 = rfm[col].quantile(<span class="number">0.75</span>)
            IQR = Q3 - Q1
            lower = Q1 - <span class="number">1.5</span> * IQR
            upper = Q3 + <span class="number">1.5</span> * IQR
            rfm[col] = np.clip(rfm[col], lower, upper)

        self.rfm_df = rfm
        print(<span class="string">f"✅ RFM特征计算完成！共{len(rfm)}个客户"</span>)
        <span class="keyword">return</span> rfm

    <span class="keyword">def</span> <span class="function">visualize_rfm_distribution</span>(self):
        <span class="string">"""可视化RFM分布 - 理解客户画像"""</span>
        fig, axes = plt.subplots(<span class="number">1</span>, <span class="number">3</span>, figsize=(<span class="number">15</span>, <span class="number">5</span>))

        <span class="comment"># Recency分布（注意：值越小越好）</span>
        axes[<span class="number">0</span>].hist(self.rfm_df[<span class="string">'Recency'</span>], bins=<span class="number">30</span>, color=<span class="string">'#4facfe'</span>, alpha=<span class="number">0.7</span>)
        axes[<span class="number">0</span>].set_title(<span class="string">'最近购买时间分布'</span>, fontsize=<span class="number">14</span>)
        axes[<span class="number">0</span>].set_xlabel(<span class="string">'天数'</span>)
        axes[<span class="number">0</span>].set_ylabel(<span class="string">'客户数'</span>)

        <span class="comment"># Frequency分布</span>
        axes[<span class="number">1</span>].hist(self.rfm_df[<span class="string">'Frequency'</span>], bins=<span class="number">30</span>, color=<span class="string">'#a78bfa'</span>, alpha=<span class="number">0.7</span>)
        axes[<span class="number">1</span>].set_title(<span class="string">'购买频率分布'</span>, fontsize=<span class="number">14</span>)
        axes[<span class="number">1</span>].set_xlabel(<span class="string">'订单数'</span>)
        axes[<span class="number">1</span>].set_ylabel(<span class="string">'客户数'</span>)

        <span class="comment"># Monetary分布</span>
        axes[<span class="number">2</span>].hist(self.rfm_df[<span class="string">'Monetary'</span>], bins=<span class="number">30</span>, color=<span class="string">'#f472b6'</span>, alpha=<span class="number">0.7</span>)
        axes[<span class="number">2</span>].set_title(<span class="string">'消费金额分布'</span>, fontsize=<span class="number">14</span>)
        axes[<span class="number">2</span>].set_xlabel(<span class="string">'总金额'</span>)
        axes[<span class="number">2</span>].set_ylabel(<span class="string">'客户数'</span>)

        plt.tight_layout()
        plt.show()

    <span class="keyword">def</span> <span class="function">find_optimal_clusters</span>(self, method=<span class="string">'kmeans'</span>, max_k=<span class="number">10</span>):
        <span class="string">"""寻找最优聚类数 - 数据驱动的决策"""</span>
        <span class="comment"># 标准化RFM数据</span>
        rfm_scaled = self.scaler.fit_transform(
            self.rfm_df[[<span class="string">'Recency'</span>, <span class="string">'Frequency'</span>, <span class="string">'Monetary'</span>]]
        )

        <span class="comment"># 使用肘部法则和轮廓系数</span>
        inertias = []
        silhouettes = []

        <span class="keyword">for</span> k <span class="keyword">in</span> range(<span class="number">2</span>, max_k + <span class="number">1</span>):
            kmeans = KMeans(n_clusters=k, random_state=<span class="number">42</span>)
            kmeans.fit(rfm_scaled)
            inertias.append(kmeans.inertia_)
            silhouettes.append(silhouette_score(rfm_scaled, kmeans.labels_))

        <span class="comment"># 可视化结果</span>
        fig, (ax1, ax2) = plt.subplots(<span class="number">1</span>, <span class="number">2</span>, figsize=(<span class="number">14</span>, <span class="number">5</span>))

        <span class="comment"># 肘部图</span>
        ax1.plot(range(<span class="number">2</span>, max_k + <span class="number">1</span>), inertias, <span class="string">'bo-'</span>, linewidth=<span class="number">2</span>)
        ax1.set_xlabel(<span class="string">'聚类数K'</span>, fontsize=<span class="number">12</span>)
        ax1.set_ylabel(<span class="string">'惯性值'</span>, fontsize=<span class="number">12</span>)
        ax1.set_title(<span class="string">'肘部法则：寻找最优K值'</span>, fontsize=<span class="number">14</span>)
        ax1.grid(True, alpha=<span class="number">0.3</span>)

        <span class="comment"># 轮廓系数图</span>
        ax2.plot(range(<span class="number">2</span>, max_k + <span class="number">1</span>), silhouettes, <span class="string">'ro-'</span>, linewidth=<span class="number">2</span>)
        ax2.set_xlabel(<span class="string">'聚类数K'</span>, fontsize=<span class="number">12</span>)
        ax2.set_ylabel(<span class="string">'轮廓系数'</span>, fontsize=<span class="number">12</span>)
        ax2.set_title(<span class="string">'轮廓系数：评估聚类质量'</span>, fontsize=<span class="number">14</span>)
        ax2.grid(True, alpha=<span class="number">0.3</span>)

        plt.tight_layout()
        plt.show()

        <span class="comment"># 推荐最优K值</span>
        optimal_k = np.argmax(silhouettes) + <span class="number">2</span>
        print(<span class="string">f"🎯 推荐聚类数: K={optimal_k}"</span>)
        <span class="keyword">return</span> optimal_k

    <span class="keyword">def</span> <span class="function">perform_clustering</span>(self, n_clusters=<span class="number">4</span>):
        <span class="string">"""执行聚类分析 - 发现客户群体"""</span>
        <span class="comment"># 标准化数据</span>
        rfm_scaled = self.scaler.fit_transform(
            self.rfm_df[[<span class="string">'Recency'</span>, <span class="string">'Frequency'</span>, <span class="string">'Monetary'</span>]]
        )

        <span class="comment"># K-means聚类</span>
        kmeans = KMeans(n_clusters=n_clusters, random_state=<span class="number">42</span>)
        self.clusters = kmeans.fit_predict(rfm_scaled)
        self.rfm_df[<span class="string">'Cluster'</span>] = self.clusters

        <span class="comment"># 计算每个簇的特征</span>
        cluster_stats = self.rfm_df.groupby(<span class="string">'Cluster'</span>).agg({
            <span class="string">'Recency'</span>: [<span class="string">'mean'</span>, <span class="string">'count'</span>],
            <span class="string">'Frequency'</span>: <span class="string">'mean'</span>,
            <span class="string">'Monetary'</span>: <span class="string">'mean'</span>
        }).round(<span class="number">2</span>)

        print(<span class="string">"\n📊 客户群体特征分析："</span>)
        print(cluster_stats)

        <span class="keyword">return</span> cluster_stats

    <span class="keyword">def</span> <span class="function">visualize_clusters</span>(self):
        <span class="string">"""可视化聚类结果 - 洞察客户分布"""</span>
        fig = plt.figure(figsize=(<span class="number">15</span>, <span class="number">10</span>))

        <span class="comment"># 3D散点图</span>
        ax = fig.add_subplot(<span class="number">221</span>, projection=<span class="string">'3d'</span>)
        colors = [<span class="string">'#4facfe'</span>, <span class="string">'#a78bfa'</span>, <span class="string">'#f472b6'</span>, <span class="string">'#34d399'</span>, <span class="string">'#fbbf24'</span>]

        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(set(self.clusters))):
            cluster_data = self.rfm_df[self.rfm_df[<span class="string">'Cluster'</span>] == i]
            ax.scatter(cluster_data[<span class="string">'Recency'</span>],
                      cluster_data[<span class="string">'Frequency'</span>],
                      cluster_data[<span class="string">'Monetary'</span>],
                      c=colors[i % len(colors)],
                      label=<span class="string">f'群体{i}'</span>,
                      alpha=<span class="number">0.6</span>,
                      s=<span class="number">50</span>)

        ax.set_xlabel(<span class="string">'Recency'</span>)
        ax.set_ylabel(<span class="string">'Frequency'</span>)
        ax.set_zlabel(<span class="string">'Monetary'</span>)
        ax.set_title(<span class="string">'客户群体3D分布'</span>, fontsize=<span class="number">14</span>)
        ax.legend()

        <span class="comment"># 添加其他可视化...</span>
        plt.tight_layout()
        plt.show()

    <span class="keyword">def</span> <span class="function">define_customer_strategies</span>(self):
        <span class="string">"""定义客户策略 - 从洞察到行动"""</span>
        strategies = {
            <span class="string">'champions'</span>: {
                <span class="string">'特征'</span>: <span class="string">'高价值、高频率、最近购买'</span>,
                <span class="string">'策略'</span>: <span class="string">'VIP服务、专属优惠、新品试用'</span>
            },
            <span class="string">'loyal_customers'</span>: {
                <span class="string">'特征'</span>: <span class="string">'中高价值、稳定购买'</span>,
                <span class="string">'策略'</span>: <span class="string">'忠诚度计划、升级激励'</span>
            },
            <span class="string">'at_risk'</span>: {
                <span class="string">'特征'</span>: <span class="string">'曾经高价值、最近不活跃'</span>,
                <span class="string">'策略'</span>: <span class="string">'挽回活动、个性化推荐'</span>
            },
            <span class="string">'new_customers'</span>: {
                <span class="string">'特征'</span>: <span class="string">'最近首次购买'</span>,
                <span class="string">'策略'</span>: <span class="string">'欢迎礼包、引导教育'</span>
            }
        }

        print(<span class="string">"\n💡 客户群体营销策略："</span>)
        <span class="keyword">for</span> segment, info <span class="keyword">in</span> strategies.items():
            print(<span class="string">f"\n📍 {segment}:"</span>)
            print(<span class="string">f"   特征: {info['特征']}"</span>)
            print(<span class="string">f"   策略: {info['策略']}"</span>)

<span class="comment"># 🚀 实战演示</span>
<span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:
    <span class="comment"># 生成模拟电商数据</span>
    np.random.seed(<span class="number">42</span>)
    n_customers = <span class="number">5000</span>
    n_orders = <span class="number">50000</span>

    <span class="comment"># 创建订单数据</span>
    orders = pd.DataFrame({
        <span class="string">'customer_id'</span>: np.random.choice(range(<span class="number">1</span>, n_customers+<span class="number">1</span>), n_orders),
        <span class="string">'order_date'</span>: pd.date_range(<span class="string">'2023-01-01'</span>, periods=<span class="number">365</span>).to_series().sample(n_orders, replace=<span class="keyword">True</span>),
        <span class="string">'amount'</span>: np.random.exponential(<span class="number">100</span>, n_orders)
    })

    <span class="comment"># 初始化客户分群系统</span>
    segmentation = CustomerSegmentation()

    <span class="comment"># 计算RFM</span>
    rfm_data = segmentation.calculate_rfm(orders, <span class="string">'customer_id'</span>, <span class="string">'order_date'</span>, <span class="string">'amount'</span>)

    <span class="comment"># 可视化RFM分布</span>
    segmentation.visualize_rfm_distribution()

    <span class="comment"># 寻找最优聚类数</span>
    optimal_k = segmentation.find_optimal_clusters()

    <span class="comment"># 执行聚类</span>
    cluster_stats = segmentation.perform_clustering(n_clusters=optimal_k)

    <span class="comment"># 可视化结果</span>
    segmentation.visualize_clusters()

    <span class="comment"># 制定营销策略</span>
    segmentation.define_customer_strategies()

    print(<span class="string">"\n🎉 客户分群分析完成！"</span>)</code></pre>
        </div>

        <!-- 业务价值展示 -->
        <div style="background: linear-gradient(135deg, rgba(52, 211, 153, 0.1), rgba(34, 197, 94, 0.05)); padding: 25px; border-radius: 15px; margin-top: 30px; border: 2px solid rgba(52, 211, 153, 0.3);">
            <h4 style="color: #34d399; margin-bottom: 20px;">💰 客户分群的业务价值</h4>

            <div class="metric-cards">
                <div class="metric-card">
                    <div class="metric-icon">📈</div>
                    <div class="metric-name">营销ROI提升</div>
                    <div class="metric-value">300%</div>
                    <div class="metric-description">精准营销带来的回报率提升</div>
                </div>
                <div class="metric-card">
                    <div class="metric-icon">💳</div>
                    <div class="metric-name">客户生命周期价值</div>
                    <div class="metric-value">+45%</div>
                    <div class="metric-description">个性化服务提升客户价值</div>
                </div>
                <div class="metric-card">
                    <div class="metric-icon">😊</div>
                    <div class="metric-name">客户满意度</div>
                    <div class="metric-value">92%</div>
                    <div class="metric-description">精准推荐提升用户体验</div>
                </div>
            </div>

            <div style="margin-top: 20px; padding: 15px; background: rgba(255, 255, 255, 0.1); border-radius: 10px;">
                <p style="text-align: center; font-size: 1.1rem;">
                    <strong>🎯 关键洞察</strong>：数据驱动的客户分群不仅是技术实践，更是业务增长的强大引擎
                </p>
            </div>
        </div>
    </div>

    <!-- 8.8 总结与展望 -->
    <div id="summary" class="section-card fade-in section-anchor">
        <h2 class="section-title">🎓 8.8 总结与展望</h2>

        <div class="story-box content-box">
            <h3 style="color: #4facfe;">🌟 回顾我们的聚类之旅</h3>
            <p style="margin-bottom: 20px;">
                从古希腊的星空观察者到现代的数据科学家，<br>
                <span class="highlight-primary">发现模式</span>始终是人类理解世界的基本方式。<br><br>

                在这一章中，我们一起经历了：<br>
                🚀 <strong>理解本质</strong>：聚类是无监督学习的艺术<br>
                ⭐ <strong>掌握经典</strong>：K-means的简洁与优雅<br>
                🌳 <strong>探索层次</strong>：构建数据的族谱树<br>
                🔍 <strong>发现密度</strong>：DBSCAN的独特视角<br>
                📏 <strong>科学评估</strong>：没有标准答案的评判艺术<br>
                🛠️ <strong>实战应用</strong>：从算法到业务价值<br><br>

                最重要的是，我们学会了<span class="highlight-secondary">用算法的眼睛看世界</span>，<br>
                在看似杂乱的数据中<span class="highlight-warning">发现隐藏的秩序与美</span>。
            </p>
        </div>

        <!-- 核心知识总结 -->
        <div style="margin: 30px 0;">
            <h3 style="color: #a78bfa; margin-bottom: 20px;">📚 核心知识点回顾</h3>

            <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(300px, 1fr)); gap: 20px;">
                <div style="background: rgba(79, 172, 254, 0.1); padding: 20px; border-radius: 15px; border: 2px solid rgba(79, 172, 254, 0.3);">
                    <h4 style="color: #4facfe; margin-bottom: 15px;">🎯 聚类本质</h4>
                    <ul style="list-style: none; padding: 0;">
                        <li>✓ 无监督学习的核心方法</li>
                        <li>✓ 发现数据的内在结构</li>
                        <li>✓ 组内相似、组间差异最大化</li>
                        <li>✓ 广泛应用于各行各业</li>
                    </ul>
                </div>

                <div style="background: rgba(167, 139, 250, 0.1); padding: 20px; border-radius: 15px; border: 2px solid rgba(167, 139, 250, 0.3);">
                    <h4 style="color: #a78bfa; margin-bottom: 15px;">🔧 算法选择</h4>
                    <ul style="list-style: none; padding: 0;">
                        <li>✓ K-means：快速简单，球形簇</li>
                        <li>✓ 层次聚类：无需预设K，可视化好</li>
                        <li>✓ DBSCAN：任意形状，自动发现簇数</li>
                        <li>✓ 根据数据特点选择算法</li>
                    </ul>
                </div>

                <div style="background: rgba(244, 114, 182, 0.1); padding: 20px; border-radius: 15px; border: 2px solid rgba(244, 114, 182, 0.3);">
                    <h4 style="color: #f472b6; margin-bottom: 15px;">📊 评估方法</h4>
                    <ul style="list-style: none; padding: 0;">
                        <li>✓ 内部指标：轮廓系数等</li>
                        <li>✓ 外部指标：需要真实标签</li>
                        <li>✓ 可视化：直观判断</li>
                        <li>✓ 业务指标：最终价值</li>
                    </ul>
                </div>
            </div>
        </div>

        <!-- 实践建议 -->
        <div class="thinking-box content-box">
            <h3>💡 聚类实践的"黄金法则"</h3>

            <div style="margin-top: 20px;">
                <div style="margin-bottom: 15px; padding: 15px; background: rgba(79, 172, 254, 0.1); border-radius: 10px;">
                    <p><strong>1. 🎯 明确目标</strong></p>
                    <p style="margin-left: 20px; color: var(--text-muted);">聚类是手段不是目的，要清楚为什么要分群</p>
                </div>

                <div style="margin-bottom: 15px; padding: 15px; background: rgba(167, 139, 250, 0.1); border-radius: 10px;">
                    <p><strong>2. 🔍 理解数据</strong></p>
                    <p style="margin-left: 20px; color: var(--text-muted);">深入探索数据特点，选择合适的算法和参数</p>
                </div>

                <div style="margin-bottom: 15px; padding: 15px; background: rgba(244, 114, 182, 0.1); border-radius: 10px;">
                    <p><strong>3. 🧪 多次尝试</strong></p>
                    <p style="margin-left: 20px; color: var(--text-muted);">尝试不同算法、参数，比较结果</p>
                </div>

                <div style="margin-bottom: 15px; padding: 15px; background: rgba(52, 211, 153, 0.1); border-radius: 10px;">
                    <p><strong>4. 📊 合理评估</strong></p>
                    <p style="margin-left: 20px; color: var(--text-muted);">结合多种评估方法，不要过度依赖单一指标</p>
                </div>

                <div style="padding: 15px; background: rgba(251, 191, 36, 0.1); border-radius: 10px;">
                    <p><strong>5. 💰 业务价值</strong></p>
                    <p style="margin-left: 20px; color: var(--text-muted);">最终要能转化为可执行的业务策略</p>
                </div>
            </div>
        </div>

        <!-- 未来展望 -->
        <div style="background: linear-gradient(135deg, rgba(251, 191, 36, 0.1), rgba(245, 158, 11, 0.05)); padding: 25px; border-radius: 15px; margin-top: 30px; border: 2px solid rgba(251, 191, 36, 0.3);">
            <h4 style="color: #fbbf24; margin-bottom: 20px;">🚀 聚类的未来：AI时代的新机遇</h4>

            <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(250px, 1fr)); gap: 20px; margin-top: 20px;">
                <div style="text-align: center; padding: 20px;">
                    <div style="font-size: 3rem; margin-bottom: 10px;">🧠</div>
                    <h5>深度聚类</h5>
                    <p style="font-size: 0.9rem; color: var(--text-muted);">
                        深度学习+聚类<br>
                        自动学习特征表示
                    </p>
                </div>
                <div style="text-align: center; padding: 20px;">
                    <div style="font-size: 3rem; margin-bottom: 10px;">🌊</div>
                    <h5>在线聚类</h5>
                    <p style="font-size: 0.9rem; color: var(--text-muted);">
                        处理流式数据<br>
                        实时更新聚类结果
                    </p>
                </div>
                <div style="text-align: center; padding: 20px;">
                    <div style="font-size: 3rem; margin-bottom: 10px;">🎯</div>
                    <h5>半监督聚类</h5>
                    <p style="font-size: 0.9rem; color: var(--text-muted);">
                        结合少量标签<br>
                        提升聚类质量
                    </p>
                </div>
                <div style="text-align: center; padding: 20px;">
                    <div style="font-size: 3rem; margin-bottom: 10px;">🌐</div>
                    <h5>多视图聚类</h5>
                    <p style="font-size: 0.9rem; color: var(--text-muted);">
                        整合多源数据<br>
                        发现更丰富的模式
                    </p>
                </div>
            </div>
        </div>

        <!-- 结语 -->
        <div style="margin-top: 40px; text-align: center; padding: 30px; background: linear-gradient(135deg, rgba(79, 172, 254, 0.1), rgba(167, 139, 250, 0.1)); border-radius: 20px;">
            <h3 style="font-size: 2rem; margin-bottom: 20px; background: linear-gradient(135deg, var(--cluster-blue), var(--cluster-purple)); -webkit-background-clip: text; -webkit-text-fill-color: transparent; background-clip: text;">
                🌌 发现数据中的星座，照亮决策的道路
            </h3>
            <p style="font-size: 1.2rem; color: var(--text-secondary); line-height: 1.8;">
                聚类不仅是一种算法，更是一种<strong>看待世界的方式</strong>。<br>
                它教会我们在混沌中<strong>寻找秩序</strong>，在差异中<strong>发现共性</strong>。<br><br>

                愿你在数据的海洋中，<br>
                用聚类的智慧，<strong>发现属于你的"星座"</strong>！
            </p>

            <div style="margin-top: 30px;">
                <button class="demo-btn" style="font-size: 1.1rem; padding: 15px 40px;">
                    🎯 开始你的聚类之旅
                </button>
            </div>
        </div>
    </div>
</div>

<!-- 浮动工具栏 -->
<div class="floating-toolbar">
    <button class="toolbar-btn" onclick="toggleTheme()" title="切换主题">
        🌓
    </button>
    <button class="toolbar-btn" onclick="scrollToTop()" title="回到顶部">
        ⬆️
    </button>
</div>

<!-- JavaScript代码 -->
<script>
    // 导航系统
    function toggleNav() {
        document.body.classList.toggle('nav-open');
    }

    // 导航项激活状态
    document.querySelectorAll('.nav-item a').forEach(link => {
        link.addEventListener('click', function(e) {
            e.preventDefault();
            const targetId = this.getAttribute('href').substring(1);
            const targetElement = document.getElementById(targetId);

            // 更新激活状态
            document.querySelectorAll('.nav-item').forEach(item => {
                item.classList.remove('active');
            });
            this.parentElement.classList.add('active');

            // 平滑滚动
            targetElement.scrollIntoView({ behavior: 'smooth' });

            // 移动端自动关闭导航
            if (window.innerWidth <= 768) {
                document.body.classList.remove('nav-open');
            }
        });
    });

    // 进度追踪
    function updateProgress() {
        const sections = document.querySelectorAll('.section-anchor');
        const scrollPosition = window.scrollY + 200;
        let currentSection = 0;

        sections.forEach((section, index) => {
            if (scrollPosition >= section.offsetTop) {
                currentSection = index;

                // 更新导航激活状态
                document.querySelectorAll('.nav-item').forEach(item => {
                    item.classList.remove('active');
                });
                const navItem = document.querySelector(`[data-section="${section.id}"]`);
                if (navItem) {
                    navItem.classList.add('active');
                }
            }
        });

        // 更新进度条
        const progress = ((currentSection + 1) / sections.length) * 100;
        document.getElementById('progressFill').style.width = progress + '%';
        document.getElementById('progressText').textContent = Math.round(progress) + '%';

        // 更新已完成的章节
        document.querySelectorAll('.nav-item').forEach((item, index) => {
            if (index < currentSection) {
                item.classList.add('completed');
            }
        });
    }

    window.addEventListener('scroll', updateProgress);

    // 主题切换
    function toggleTheme() {
        document.body.classList.toggle('light-theme');
        localStorage.setItem('theme', document.body.classList.contains('light-theme') ? 'light' : 'dark');
    }

    // 加载保存的主题
    if (localStorage.getItem('theme') === 'light') {
        document.body.classList.add('light-theme');
    }

    // 回到顶部
    function scrollToTop() {
        window.scrollTo({ top: 0, behavior: 'smooth' });
    }

    // 粒子背景系统
    class ParticleSystem {
        constructor(canvasId) {
            this.canvas = document.getElementById(canvasId);
            this.ctx = this.canvas.getContext('2d');
            this.particles = [];
            this.connections = [];
            this.mouse = { x: 0, y: 0 };

            this.init();
            this.animate();

            window.addEventListener('resize', () => this.init());
            window.addEventListener('mousemove', (e) => {
                this.mouse.x = e.clientX;
                this.mouse.y = e.clientY;
            });
        }

        init() {
            this.canvas.width = window.innerWidth;
            this.canvas.height = window.innerHeight;

            // 创建粒子
            this.particles = [];
            const particleCount = Math.floor((this.canvas.width * this.canvas.height) / 15000);

            for (let i = 0; i < particleCount; i++) {
                this.particles.push({
                    x: Math.random() * this.canvas.width,
                    y: Math.random() * this.canvas.height,
                    vx: (Math.random() - 0.5) * 0.5,
                    vy: (Math.random() - 0.5) * 0.5,
                    radius: Math.random() * 2 + 1,
                    color: `hsla(${200 + Math.random() * 60}, 70%, 60%, 0.3)`
                });
            }
        }

        animate() {
            this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);

            // 更新和绘制粒子
            this.particles.forEach((particle, i) => {
                particle.x += particle.vx;
                particle.y += particle.vy;

                // 边界反弹
                if (particle.x < 0 || particle.x > this.canvas.width) particle.vx *= -1;
                if (particle.y < 0 || particle.y > this.canvas.height) particle.vy *= -1;

                // 绘制粒子
                this.ctx.beginPath();
                this.ctx.arc(particle.x, particle.y, particle.radius, 0, Math.PI * 2);
                this.ctx.fillStyle = particle.color;
                this.ctx.fill();

                // 连接临近粒子
                for (let j = i + 1; j < this.particles.length; j++) {
                    const dx = this.particles[j].x - particle.x;
                    const dy = this.particles[j].y - particle.y;
                    const distance = Math.sqrt(dx * dx + dy * dy);

                    if (distance < 150) {
                        this.ctx.beginPath();
                        this.ctx.moveTo(particle.x, particle.y);
                        this.ctx.lineTo(this.particles[j].x, this.particles[j].y);
                        this.ctx.strokeStyle = `rgba(79, 172, 254, ${0.2 * (1 - distance / 150)})`;
                        this.ctx.stroke();
                    }
                }

                // 鼠标交互
                const mouseDistance = Math.sqrt(
                    Math.pow(this.mouse.x - particle.x, 2) +
                    Math.pow(this.mouse.y - particle.y, 2)
                );

                if (mouseDistance < 100) {
                    const force = (100 - mouseDistance) / 100;
                    particle.vx += (this.mouse.x - particle.x) * force * 0.01;
                    particle.vy += (this.mouse.y - particle.y) * force * 0.01;
                }
            });

            requestAnimationFrame(() => this.animate());
        }
    }

    // K-means演示
    let kmeansData = [];
    let kmeansCentroids = [];
    let kmeansLabels = [];
    let kmeansIteration = 0;
    let kmeansRunning = false;

    function updateK() {
        const k = document.getElementById('kSlider').value;
        document.getElementById('kValue').textContent = k;
    }

    function updatePoints() {
        const points = document.getElementById('pointsSlider').value;
        document.getElementById('pointsValue').textContent = points;
    }

    function generateKMeansData() {
        const canvas = document.getElementById('kmeansCanvas');
        const points = parseInt(document.getElementById('pointsSlider').value);

        kmeansData = [];
        // 生成几个聚集的数据群
        const clusters = 3 + Math.floor(Math.random() * 3);
        for (let c = 0; c < clusters; c++) {
            const cx = Math.random() * (canvas.width - 100) + 50;
            const cy = Math.random() * (canvas.height - 100) + 50;
            const spread = 30 + Math.random() * 50;

            const clusterPoints = Math.floor(points / clusters);
            for (let i = 0; i < clusterPoints; i++) {
                kmeansData.push({
                    x: cx + (Math.random() - 0.5) * spread * 2,
                    y: cy + (Math.random() - 0.5) * spread * 2
                });
            }
        }

        drawKMeans();
    }

    function initKMeans() {
        if (kmeansData.length === 0) {
            generateKMeansData();
        }

        const k = parseInt(document.getElementById('kSlider').value);
        kmeansCentroids = [];

        // 随机选择K个点作为初始中心
        const indices = [];
        while (indices.length < k) {
            const idx = Math.floor(Math.random() * kmeansData.length);
            if (!indices.includes(idx)) {
                indices.push(idx);
                kmeansCentroids.push({
                    x: kmeansData[idx].x,
                    y: kmeansData[idx].y
                });
            }
        }

        kmeansIteration = 0;
        document.getElementById('kmeansIteration').textContent = '迭代次数: 0';

        drawKMeans();
    }

    function stepKMeans() {
        if (kmeansCentroids.length === 0) {
            initKMeans();
            return;
        }

        // 分配步骤
        kmeansLabels = [];
        kmeansData.forEach(point => {
            let minDist = Infinity;
            let label = 0;

            kmeansCentroids.forEach((centroid, i) => {
                const dist = Math.sqrt(
                    Math.pow(point.x - centroid.x, 2) +
                    Math.pow(point.y - centroid.y, 2)
                );
                if (dist < minDist) {
                    minDist = dist;
                    label = i;
                }
            });

            kmeansLabels.push(label);
        });

        // 更新步骤
        const newCentroids = [];
        for (let i = 0; i < kmeansCentroids.length; i++) {
            const clusterPoints = kmeansData.filter((_, idx) => kmeansLabels[idx] === i);
            if (clusterPoints.length > 0) {
                const sumX = clusterPoints.reduce((sum, p) => sum + p.x, 0);
                const sumY = clusterPoints.reduce((sum, p) => sum + p.y, 0);
                newCentroids.push({
                    x: sumX / clusterPoints.length,
                    y: sumY / clusterPoints.length
                });
            } else {
                newCentroids.push(kmeansCentroids[i]);
            }
        }

        kmeansCentroids = newCentroids;
        kmeansIteration++;
        document.getElementById('kmeansIteration').textContent = `迭代次数: ${kmeansIteration}`;

        drawKMeans();
    }

    function runKMeans() {
        if (kmeansRunning) {
            kmeansRunning = false;
            return;
        }

        kmeansRunning = true;

        function iterate() {
            if (!kmeansRunning) return;

            stepKMeans();

            // 检查收敛
            let converged = true;
            // 简化的收敛检查

            if (!converged && kmeansIteration < 50) {
                setTimeout(iterate, 500);
            } else {
                kmeansRunning = false;
            }
        }

        if (kmeansCentroids.length === 0) {
            initKMeans();
        }
        iterate();
    }

    function resetKMeans() {
        kmeansRunning = false;
        kmeansData = [];
        kmeansCentroids = [];
        kmeansLabels = [];
        kmeansIteration = 0;
        document.getElementById('kmeansIteration').textContent = '迭代次数: 0';

        const canvas = document.getElementById('kmeansCanvas');
        const ctx = canvas.getContext('2d');
        ctx.clearRect(0, 0, canvas.width, canvas.height);
    }

    function drawKMeans() {
        const canvas = document.getElementById('kmeansCanvas');
        const ctx = canvas.getContext('2d');
        const colors = ['#4facfe', '#a78bfa', '#f472b6', '#34d399', '#fbbf24', '#ef4444', '#8b5cf6', '#10b981'];

        ctx.clearRect(0, 0, canvas.width, canvas.height);

        // 绘制数据点
        kmeansData.forEach((point, i) => {
            ctx.beginPath();
            ctx.arc(point.x, point.y, 5, 0, Math.PI * 2);
            if (kmeansLabels.length > 0) {
                ctx.fillStyle = colors[kmeansLabels[i] % colors.length];
            } else {
                ctx.fillStyle = '#888';
            }
            ctx.fill();
        });

        // 绘制聚类中心
        kmeansCentroids.forEach((centroid, i) => {
            // 绘制大圆
            ctx.beginPath();
            ctx.arc(centroid.x, centroid.y, 15, 0, Math.PI * 2);
            ctx.fillStyle = colors[i % colors.length];
            ctx.fill();
            ctx.strokeStyle = '#fff';
            ctx.lineWidth = 2;
            ctx.stroke();

            // 绘制星形
            ctx.fillStyle = '#fff';
            ctx.font = '20px Arial';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText('★', centroid.x, centroid.y);
        });
    }

    // 层次聚类演示
    function generateHierarchicalData() {
        // 生成层次聚类演示数据
        alert('层次聚类演示 - 待实现');
    }

    function buildDendrogram() {
        alert('构建树状图 - 待实现');
    }

    function cutDendrogram() {
        alert('切割树状图 - 待实现');
    }

    function animateMerging() {
        alert('合并动画 - 待实现');
    }

    function updateHierarchical() {
        // 更新层次聚类参数
    }

    function updateCutHeight() {
        const height = document.getElementById('cutHeightSlider').value;
        document.getElementById('cutHeightValue').textContent = height;
    }

    // DBSCAN演示
    let dbscanData = [];
    let dbscanClusters = [];

    function generateDBSCANData() {
        const canvas = document.getElementById('dbscanCanvas');
        const ctx = canvas.getContext('2d');
        const distribution = document.getElementById('dataDistribution').value;

        dbscanData = [];

        switch(distribution) {
            case 'moons':
                // 生成月牙形数据
                for (let i = 0; i < 150; i++) {
                    const angle = Math.random() * Math.PI;
                    const r = 100 + (Math.random() - 0.5) * 20;
                    dbscanData.push({
                        x: 200 + r * Math.cos(angle),
                        y: 250 + r * Math.sin(angle)
                    });
                }
                for (let i = 0; i < 150; i++) {
                    const angle = Math.random() * Math.PI + Math.PI;
                    const r = 100 + (Math.random() - 0.5) * 20;
                    dbscanData.push({
                        x: 400 + r * Math.cos(angle),
                        y: 150 + r * Math.sin(angle)
                    });
                }
                break;
            case 'circles':
                // 生成同心圆数据
                for (let i = 0; i < 150; i++) {
                    const angle = Math.random() * Math.PI * 2;
                    const r = 50 + (Math.random() - 0.5) * 10;
                    dbscanData.push({
                        x: 400 + r * Math.cos(angle),
                        y: 250 + r * Math.sin(angle)
                    });
                }
                for (let i = 0; i < 150; i++) {
                    const angle = Math.random() * Math.PI * 2;
                    const r = 150 + (Math.random() - 0.5) * 10;
                    dbscanData.push({
                        x: 400 + r * Math.cos(angle),
                        y: 250 + r * Math.sin(angle)
                    });
                }
                break;
            default:
                // 生成团状数据
                generateKMeansData();
                dbscanData = [...kmeansData];
        }

        // 添加一些噪声点
        for (let i = 0; i < 20; i++) {
            dbscanData.push({
                x: Math.random() * canvas.width,
                y: Math.random() * canvas.height
            });
        }

        drawDBSCAN();
    }

    function runDBSCAN() {
        if (dbscanData.length === 0) {
            generateDBSCANData();
        }

        const eps = parseFloat(document.getElementById('epsSlider').value) * 100;
        const minPts = parseInt(document.getElementById('minPtsSlider').value);

        // 简化的DBSCAN实现
        const labels = new Array(dbscanData.length).fill(-1); // -1表示噪声
        const visited = new Array(dbscanData.length).fill(false);
        let clusterId = 0;

        for (let i = 0; i < dbscanData.length; i++) {
            if (visited[i]) continue;
            visited[i] = true;

            const neighbors = getNeighbors(i, eps);
            if (neighbors.length < minPts) {
                labels[i] = -1; // 噪声点
            } else {
                expandCluster(i, neighbors, clusterId, eps, minPts, visited, labels);
                clusterId++;
            }
        }

        dbscanClusters = labels;

        // 统计结果
        let coreCount = 0, borderCount = 0, noiseCount = 0;
        labels.forEach(label => {
            if (label === -1) noiseCount++;
            else coreCount++; // 简化统计
        });

        document.getElementById('coreCount').textContent = coreCount;
        document.getElementById('borderCount').textContent = borderCount;
        document.getElementById('noiseCount').textContent = noiseCount;

        drawDBSCAN();
    }

    function getNeighbors(pointIdx, eps) {
        const neighbors = [];
        const point = dbscanData[pointIdx];

        dbscanData.forEach((other, i) => {
            if (i !== pointIdx) {
                const dist = Math.sqrt(
                    Math.pow(point.x - other.x, 2) +
                    Math.pow(point.y - other.y, 2)
                );
                if (dist <= eps) {
                    neighbors.push(i);
                }
            }
        });

        return neighbors;
    }

    function expandCluster(pointIdx, neighbors, clusterId, eps, minPts, visited, labels) {
        labels[pointIdx] = clusterId;

        let i = 0;
        while (i < neighbors.length) {
            const neighborIdx = neighbors[i];

            if (!visited[neighborIdx]) {
                visited[neighborIdx] = true;
                const neighborNeighbors = getNeighbors(neighborIdx, eps);

                if (neighborNeighbors.length >= minPts) {
                    neighbors.push(...neighborNeighbors.filter(n => !neighbors.includes(n)));
                }
            }

            if (labels[neighborIdx] === -1) {
                labels[neighborIdx] = clusterId;
            }

            i++;
        }
    }

    function drawDBSCAN() {
        const canvas = document.getElementById('dbscanCanvas');
        const ctx = canvas.getContext('2d');
        const colors = ['#4facfe', '#a78bfa', '#f472b6', '#34d399', '#fbbf24', '#ef4444', '#8b5cf6', '#10b981'];

        ctx.clearRect(0, 0, canvas.width, canvas.height);

        // 绘制数据点
        dbscanData.forEach((point, i) => {
            ctx.beginPath();
            ctx.arc(point.x, point.y, 5, 0, Math.PI * 2);

            if (dbscanClusters.length > 0) {
                if (dbscanClusters[i] === -1) {
                    ctx.fillStyle = '#666'; // 噪声点
                } else {
                    ctx.fillStyle = colors[dbscanClusters[i] % colors.length];
                }
            } else {
                ctx.fillStyle = '#888';
            }

            ctx.fill();
        });
    }

    function updateDBSCAN() {
        const eps = document.getElementById('epsSlider').value;
        const minPts = document.getElementById('minPtsSlider').value;
        document.getElementById('epsValue').textContent = eps;
        document.getElementById('minPtsValue').textContent = minPts;
    }

    function showPointTypes() {
        alert('显示点类型 - 待实现');
    }

    function animateDBSCAN() {
        alert('DBSCAN扫描动画 - 待实现');
    }

    // 评估演示
    function generateEvalData() {
        alert('生成评估数据 - 待实现');
    }

    function runEvaluation() {
        alert('运行评估 - 待实现');
    }

    function compareAlgorithms() {
        alert('比较算法 - 待实现');
    }

    function showMetricDetails() {
        alert('显示指标详情 - 待实现');
    }

    function updateEvaluation() {
        // 更新评估类型
    }

    // 初始化
    document.addEventListener('DOMContentLoaded', function() {
        // 创建粒子背景
        new ParticleSystem('particleSystem');

        // 初始化进度
        updateProgress();

        // 生成初始K-means数据
        generateKMeansData();
    });
</script>

</body>
</html>