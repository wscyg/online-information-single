<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>第1章：机器感知的第一块砖 - 感知机（增强版）| 深度学习之旅</title>
    <meta name="description" content="从零开始理解感知机：一个深夜的探索之旅，从困惑到顿悟，揭开深度学习的第一层面纱">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/github-dark.min.css">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.9/katex.min.css">
    <style>
        /* ===== CSS变量定义 ===== */
        :root {
            --primary-gradient: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            --bg-dark: #0f172a;
            --bg-section: #1e293b;
            --text-primary: #f1f5f9;
            --text-secondary: #e2e8f0; /* 提升亮度以满足WCAG AA标准 */
            --text-muted: #cbd5e1; /* 提升亮度 */
            --accent-red: #ef4444;
            --accent-green: #22c55e;
            --accent-blue: #06b6d4;
            --accent-yellow: #fbbf24;
            --accent-purple: #8b5cf6;
            --accent-pink: #ec4899;
            --border-color: rgba(255, 255, 255, 0.1);
            --shadow-lg: 0 10px 40px rgba(0, 0, 0, 0.3);
            --animation-duration: 0.3s;
            --content-max-width: 1200px;
            --focus-ring: 0 0 0 3px rgba(139, 92, 246, 0.5);
        }

        /* 亮色主题 */
        [data-theme="light"] {
            --bg-dark: #ffffff;
            --bg-section: #f8fafc;
            --text-primary: #0f172a;
            --text-secondary: #475569;
            --text-muted: #64748b;
            --border-color: rgba(0, 0, 0, 0.1);
            --shadow-lg: 0 10px 40px rgba(0, 0, 0, 0.1);
        }

        /* ===== 全局样式 ===== */
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        html {
            scroll-behavior: smooth;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
            background: var(--bg-dark);
            color: var(--text-primary);
            line-height: 1.6;
            overflow-x: hidden;
            transition: background-color var(--animation-duration) ease;
        }

        /* ===== 焦点样式 ===== */
        :focus-visible {
            outline: none;
            box-shadow: var(--focus-ring);
            border-radius: 0.25rem;
        }

        button:focus-visible,
        a:focus-visible {
            outline: none;
            box-shadow: var(--focus-ring);
        }

        /* ===== 布局组件 ===== */
        .container {
            max-width: var(--content-max-width);
            margin: 0 auto;
            padding: 0 1rem;
        }

        /* ===== 导航栏 ===== */
        .nav-header {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            background: rgba(15, 23, 42, 0.95);
            backdrop-filter: blur(10px);
            z-index: 1000;
            border-bottom: 1px solid var(--border-color);
            transition: transform 0.3s ease;
        }

        .nav-header.hidden {
            transform: translateY(-100%);
        }

        .nav-content {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 1rem 0;
        }

        .nav-title {
            display: flex;
            align-items: center;
            gap: 1rem;
        }

        .nav-title h1 {
            font-size: 1.25rem;
            font-weight: 600;
            background: var(--primary-gradient);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
        }

        .nav-controls {
            display: flex;
            gap: 1rem;
            align-items: center;
        }

        .btn-control {
            background: transparent;
            border: 1px solid var(--border-color);
            color: var(--text-primary);
            padding: 0.5rem;
            border-radius: 0.5rem;
            cursor: pointer;
            transition: all var(--animation-duration) ease;
            display: flex;
            align-items: center;
            justify-content: center;
            width: 40px;
            height: 40px;
            position: relative;
        }

        .btn-control:hover {
            background: rgba(255, 255, 255, 0.1);
            transform: translateY(-2px);
        }

        .nav-progress {
            position: absolute;
            bottom: 0;
            left: 0;
            right: 0;
            height: 3px;
            background: rgba(255, 255, 255, 0.1);
        }

        .progress-bar {
            height: 100%;
            background: var(--primary-gradient);
            width: 0%;
            transition: width 0.3s ease;
        }

        /* ===== 难度选择器 ===== */
        .difficulty-selector {
            position: fixed;
            right: 20px;
            top: 80px;
            background: var(--bg-section);
            border: 1px solid var(--border-color);
            border-radius: 0.5rem;
            padding: 1rem;
            z-index: 999;
            box-shadow: var(--shadow-lg);
        }

        .difficulty-selector h4 {
            color: var(--accent-purple);
            margin-bottom: 0.5rem;
            font-size: 0.875rem;
        }

        .difficulty-option {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            padding: 0.5rem;
            cursor: pointer;
            border-radius: 0.25rem;
            transition: all 0.2s ease;
        }

        .difficulty-option:hover {
            background: rgba(255, 255, 255, 0.05);
        }

        .difficulty-option.active {
            background: rgba(139, 92, 246, 0.2);
            color: var(--accent-purple);
        }

        .difficulty-option input[type="radio"] {
            display: none;
        }

        /* ===== 侧边导航 ===== */
        .sidebar {
            position: fixed;
            left: -300px;
            top: 60px;
            bottom: 0;
            width: 300px;
            background: var(--bg-section);
            border-right: 1px solid var(--border-color);
            padding: 2rem;
            overflow-y: auto;
            transition: transform 0.3s ease;
            z-index: 999;
        }

        .sidebar.open {
            transform: translateX(300px);
        }

        .sidebar-overlay {
            position: fixed;
            inset: 0;
            background: rgba(0, 0, 0, 0.5);
            display: none;
            z-index: 998;
        }

        .sidebar-overlay.active {
            display: block;
        }

        .toc-item {
            display: block;
            padding: 0.75rem 1rem;
            color: var(--text-secondary);
            text-decoration: none;
            border-radius: 0.5rem;
            transition: all var(--animation-duration) ease;
            margin-bottom: 0.25rem;
        }

        .toc-item:hover {
            background: rgba(255, 255, 255, 0.05);
            color: var(--text-primary);
            transform: translateX(4px);
        }

        .toc-item.active {
            background: var(--primary-gradient);
            color: white;
        }

        /* ===== 学习伙伴系统 ===== */
        .learning-buddy {
            position: fixed;
            bottom: 20px;
            right: 20px;
            width: 300px;
            background: var(--bg-section);
            border: 2px solid var(--accent-purple);
            border-radius: 1rem;
            padding: 1.5rem;
            box-shadow: var(--shadow-lg);
            z-index: 900;
            transform: translateY(400px);
            transition: transform 0.5s ease;
        }

        .learning-buddy.active {
            transform: translateY(0);
        }

        .learning-buddy.minimized {
            width: auto;
            padding: 0;
            border-radius: 50%;
            overflow: hidden;
        }

        .learning-buddy.minimized .buddy-content {
            display: none;
        }

        .learning-buddy.minimized .buddy-avatar {
            margin: 0;
            cursor: pointer;
        }

        .buddy-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            margin-bottom: 1rem;
        }

        .buddy-avatar {
            width: 60px;
            height: 60px;
            background: linear-gradient(135deg, #667eea, #764ba2);
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 2rem;
            flex-shrink: 0;
        }

        .buddy-controls {
            display: flex;
            gap: 0.5rem;
        }

        .buddy-control-btn {
            width: 30px;
            height: 30px;
            border-radius: 50%;
            border: 1px solid var(--border-color);
            background: transparent;
            color: var(--text-primary);
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.2s ease;
        }

        .buddy-control-btn:hover {
            background: rgba(255, 255, 255, 0.1);
        }

        .buddy-message {
            background: rgba(139, 92, 246, 0.1);
            padding: 1rem;
            border-radius: 0.5rem;
            margin-bottom: 1rem;
            position: relative;
        }

        .buddy-message::before {
            content: '';
            position: absolute;
            top: -8px;
            left: 20px;
            width: 0;
            height: 0;
            border-left: 8px solid transparent;
            border-right: 8px solid transparent;
            border-bottom: 8px solid rgba(139, 92, 246, 0.1);
        }

        /* ===== 主内容区 ===== */
        main {
            margin-top: 80px;
            padding-bottom: 4rem;
        }

        /* ===== 章节卡片 ===== */
        .chapter-hero {
            background: var(--primary-gradient);
            padding: 4rem 0;
            margin-bottom: 3rem;
            position: relative;
            overflow: hidden;
        }

        .chapter-hero::before {
            content: '';
            position: absolute;
            top: -50%;
            left: -50%;
            width: 200%;
            height: 200%;
            background: radial-gradient(circle, rgba(255, 255, 255, 0.1) 0%, transparent 70%);
            animation: pulse 10s ease-in-out infinite;
        }

        @keyframes pulse {
            0%, 100% { transform: scale(1) rotate(0deg); }
            50% { transform: scale(1.1) rotate(180deg); }
        }

        .chapter-hero-content {
            position: relative;
            z-index: 2;
            text-align: center;
            color: white;
        }

        .chapter-hero h1 {
            font-size: 3rem;
            margin-bottom: 1rem;
            animation: fadeInUp 0.8s ease;
        }

        .chapter-hero p {
            font-size: 1.25rem;
            opacity: 0.9;
            max-width: 600px;
            margin: 0 auto;
            animation: fadeInUp 0.8s ease 0.2s both;
        }

        @keyframes fadeInUp {
            from {
                opacity: 0;
                transform: translateY(20px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        /* ===== 内容区块 ===== */
        .section-card {
            background: var(--bg-section);
            border-radius: 1rem;
            padding: 2.5rem;
            margin-bottom: 2rem;
            border: 1px solid var(--border-color);
            box-shadow: var(--shadow-lg);
            transition: transform var(--animation-duration) ease;
        }

        .section-card:hover {
            transform: translateY(-2px);
        }

        /* ===== 学习循环指示器 ===== */
        .learning-loop {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 2rem;
            margin-bottom: 3rem;
            padding: 1.5rem;
            background: rgba(139, 92, 246, 0.1);
            border-radius: 1rem;
            border: 1px solid rgba(139, 92, 246, 0.3);
        }

        .loop-step {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 0.5rem;
            padding: 1rem;
            border-radius: 0.5rem;
            transition: all var(--animation-duration) ease;
            position: relative;
        }

        .loop-step.active {
            background: rgba(139, 92, 246, 0.2);
            transform: scale(1.1);
        }

        .loop-step .icon {
            font-size: 2rem;
        }

        .loop-step .label {
            font-size: 0.875rem;
            color: var(--text-secondary);
        }

        .loop-connector {
            position: absolute;
            top: 50%;
            right: -2rem;
            width: 2rem;
            height: 2px;
            background: rgba(139, 92, 246, 0.3);
        }

        /* ===== 故事卡片 ===== */
        .story-card {
            background: linear-gradient(135deg, rgba(251, 191, 36, 0.15), rgba(245, 158, 11, 0.1));
            border-radius: 1rem;
            padding: 2rem;
            margin-bottom: 2rem;
            border: 2px solid rgba(251, 191, 36, 0.2);
            position: relative;
            overflow: hidden;
        }

        .story-card::before {
            content: '🌙';
            position: absolute;
            top: -20px;
            right: -20px;
            font-size: 5rem;
            opacity: 0.1;
            transform: rotate(15deg);
        }

        /* ===== 人物对话 ===== */
        .dialogue-container {
            margin: 2rem 0;
            padding: 1.5rem;
            background: rgba(0, 0, 0, 0.2);
            border-radius: 0.75rem;
        }

        .dialogue-item {
            display: flex;
            gap: 1rem;
            margin-bottom: 1.5rem;
            animation: slideIn 0.5s ease;
        }

        .dialogue-avatar {
            width: 50px;
            height: 50px;
            border-radius: 50%;
            flex-shrink: 0;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 1.5rem;
        }

        .dialogue-avatar.student {
            background: linear-gradient(135deg, #fbbf24, #f59e0b);
        }

        .dialogue-avatar.teacher {
            background: linear-gradient(135deg, #06b6d4, #0891b2);
        }

        .dialogue-avatar.friend {
            background: linear-gradient(135deg, #22c55e, #16a34a);
        }

        .dialogue-content {
            flex: 1;
            background: rgba(255, 255, 255, 0.05);
            padding: 1rem;
            border-radius: 0.5rem;
            position: relative;
        }

        .dialogue-content::before {
            content: '';
            position: absolute;
            left: -8px;
            top: 15px;
            width: 0;
            height: 0;
            border-top: 8px solid transparent;
            border-bottom: 8px solid transparent;
            border-right: 8px solid rgba(255, 255, 255, 0.05);
        }

        .dialogue-name {
            font-weight: bold;
            color: var(--accent-purple);
            margin-bottom: 0.25rem;
        }

        /* ===== 概念卡片网格 ===== */
        .concept-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 1.5rem;
            margin: 2rem 0;
        }

        .concept-card {
            padding: 1.5rem;
            border-radius: 0.75rem;
            transition: all var(--animation-duration) ease;
            cursor: pointer;
            position: relative;
            overflow: hidden;
        }

        .concept-card::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            height: 4px;
            background: var(--primary-gradient);
            transform: scaleX(0);
            transition: transform var(--animation-duration) ease;
        }

        .concept-card:hover::before {
            transform: scaleX(1);
        }

        .concept-card.why {
            background: rgba(239, 68, 68, 0.1);
            border: 1px solid rgba(239, 68, 68, 0.3);
        }

        .concept-card.what {
            background: rgba(34, 197, 94, 0.1);
            border: 1px solid rgba(34, 197, 94, 0.3);
        }

        .concept-card.how {
            background: rgba(6, 182, 212, 0.1);
            border: 1px solid rgba(6, 182, 212, 0.3);
        }

        .concept-card.pitfall {
            background: rgba(251, 191, 36, 0.1);
            border: 1px solid rgba(251, 191, 36, 0.3);
        }

        /* ===== 数学推导容器 ===== */
        .math-derivation {
            background: rgba(79, 70, 229, 0.05);
            border: 1px solid rgba(79, 70, 229, 0.3);
            border-radius: 1rem;
            padding: 2rem;
            margin: 2rem 0;
        }

        .math-step {
            margin: 1.5rem 0;
            padding-left: 2rem;
            position: relative;
        }

        .math-step::before {
            content: attr(data-step);
            position: absolute;
            left: 0;
            top: 0;
            width: 24px;
            height: 24px;
            background: var(--accent-purple);
            color: white;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 0.875rem;
            font-weight: bold;
        }

        .math-explanation {
            background: rgba(255, 255, 255, 0.05);
            border-radius: 0.5rem;
            padding: 1rem;
            margin-top: 0.5rem;
            font-size: 0.95rem;
            color: var(--text-secondary);
        }

        /* ===== 交互式可视化 ===== */
        .interactive-demo {
            background: rgba(15, 23, 42, 0.8);
            border: 1px solid var(--border-color);
            border-radius: 1rem;
            padding: 2rem;
            margin: 2rem 0;
            position: relative;
        }

        .demo-controls {
            display: flex;
            gap: 2rem;
            align-items: center;
            margin-bottom: 1.5rem;
            flex-wrap: wrap;
        }

        .control-group {
            display: flex;
            flex-direction: column;
            gap: 0.5rem;
        }

        .control-group label {
            font-size: 0.875rem;
            color: var(--text-secondary);
        }

        .slider-container {
            display: flex;
            align-items: center;
            gap: 1rem;
        }

        input[type="range"] {
            width: 150px;
            height: 6px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 3px;
            outline: none;
            -webkit-appearance: none;
            cursor: pointer;
        }

        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 18px;
            height: 18px;
            background: var(--primary-gradient);
            border-radius: 50%;
            cursor: pointer;
            transition: transform 0.2s ease;
        }

        input[type="range"]::-webkit-slider-thumb:hover {
            transform: scale(1.2);
        }

        .slider-value {
            background: rgba(255, 255, 255, 0.1);
            padding: 0.25rem 0.75rem;
            border-radius: 0.5rem;
            font-family: monospace;
            min-width: 50px;
            text-align: center;
        }

        #perceptron-canvas,
        #xor-canvas,
        #training-canvas,
        #iris-canvas,
        #hyperplane-canvas {
            display: block;
            margin: 0 auto;
            border-radius: 0.5rem;
            background: rgba(0, 0, 0, 0.2);
            cursor: crosshair;
        }

        /* ===== 即时练习 ===== */
        .instant-practice {
            background: rgba(34, 197, 94, 0.1);
            border: 1px solid rgba(34, 197, 94, 0.3);
            border-radius: 1rem;
            padding: 2rem;
            margin: 2rem 0;
        }

        .practice-question {
            font-size: 1.1rem;
            margin-bottom: 1.5rem;
            font-weight: 500;
        }

        .practice-options {
            display: grid;
            gap: 1rem;
        }

        .practice-option {
            background: rgba(255, 255, 255, 0.05);
            border: 2px solid transparent;
            border-radius: 0.5rem;
            padding: 1rem 1.5rem;
            cursor: pointer;
            transition: all var(--animation-duration) ease;
            position: relative;
            overflow: hidden;
            text-align: left;
            width: 100%;
        }

        .practice-option:hover {
            background: rgba(255, 255, 255, 0.1);
            transform: translateX(4px);
        }

        .practice-option.selected {
            border-color: var(--accent-blue);
        }

        .practice-option.correct {
            background: rgba(34, 197, 94, 0.2);
            border-color: var(--accent-green);
        }

        .practice-option.incorrect {
            background: rgba(239, 68, 68, 0.2);
            border-color: var(--accent-red);
        }

        .practice-feedback {
            margin-top: 1.5rem;
            padding: 1rem;
            border-radius: 0.5rem;
            display: none;
            animation: fadeIn 0.3s ease;
        }

        .practice-feedback.show {
            display: block;
        }

        .practice-feedback.correct {
            background: rgba(34, 197, 94, 0.2);
            border: 1px solid rgba(34, 197, 94, 0.3);
            color: var(--accent-green);
        }

        .practice-feedback.incorrect {
            background: rgba(239, 68, 68, 0.2);
            border: 1px solid rgba(239, 68, 68, 0.3);
            color: var(--accent-red);
        }

        /* ===== 常见错误专栏 ===== */
        .common-mistakes {
            background: rgba(239, 68, 68, 0.1);
            border: 2px solid rgba(239, 68, 68, 0.3);
            border-radius: 1rem;
            padding: 2rem;
            margin: 2rem 0;
        }

        .mistake-item {
            display: flex;
            gap: 1rem;
            margin-bottom: 1.5rem;
            padding: 1rem;
            background: rgba(0, 0, 0, 0.2);
            border-radius: 0.5rem;
        }

        .mistake-icon {
            font-size: 2rem;
            flex-shrink: 0;
        }

        .mistake-content h4 {
            color: var(--accent-red);
            margin-bottom: 0.5rem;
        }

        /* ===== 代码容器 ===== */
        .code-container {
            margin: 2rem 0;
            border-radius: 0.75rem;
            overflow: hidden;
            box-shadow: var(--shadow-lg);
        }

        .code-header {
            background: #1a1a2e;
            padding: 1rem 1.5rem;
            display: flex;
            justify-content: space-between;
            align-items: center;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
        }

        .code-header-left {
            display: flex;
            align-items: center;
            gap: 1rem;
        }

        .code-header-right {
            display: flex;
            gap: 0.5rem;
        }

        .code-tab {
            padding: 0.5rem 1rem;
            background: transparent;
            border: none;
            color: var(--text-secondary);
            cursor: pointer;
            border-radius: 0.5rem;
            transition: all var(--animation-duration) ease;
        }

        .code-tab.active {
            background: rgba(255, 255, 255, 0.1);
            color: var(--text-primary);
        }

        .code-action {
            padding: 0.5rem 1rem;
            background: transparent;
            border: 1px solid var(--border-color);
            color: var(--text-primary);
            cursor: pointer;
            border-radius: 0.5rem;
            transition: all var(--animation-duration) ease;
            font-size: 0.875rem;
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        .code-action:hover {
            background: rgba(255, 255, 255, 0.1);
            transform: translateY(-1px);
        }

        .code-content {
            background: #0d1117;
            overflow-x: auto;
        }

        .code-content pre {
            margin: 0;
            padding: 1.5rem;
        }

        .code-content code {
            font-family: 'SF Mono', 'Monaco', 'Inconsolata', 'Fira Code', monospace;
            font-size: 0.9rem;
            line-height: 1.6;
        }

        .code-output {
            background: rgba(34, 197, 94, 0.1);
            border: 1px solid rgba(34, 197, 94, 0.3);
            border-radius: 0.5rem;
            padding: 1rem;
            margin-top: 1rem;
            font-family: monospace;
            font-size: 0.875rem;
            display: none;
        }

        .code-output.show {
            display: block;
            animation: slideIn 0.3s ease;
        }

        @keyframes slideIn {
            from {
                opacity: 0;
                transform: translateY(-10px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        /* ===== 学习路径推荐 ===== */
        .learning-path {
            background: linear-gradient(135deg, rgba(139, 92, 246, 0.1), rgba(236, 72, 153, 0.1));
            border: 2px solid rgba(139, 92, 246, 0.3);
            border-radius: 1rem;
            padding: 2rem;
            margin: 2rem 0;
        }

        .path-item {
            display: flex;
            align-items: center;
            gap: 1rem;
            padding: 1rem;
            margin: 0.5rem 0;
            background: rgba(255, 255, 255, 0.05);
            border-radius: 0.5rem;
            transition: all var(--animation-duration) ease;
            cursor: pointer;
        }

        .path-item:hover {
            background: rgba(255, 255, 255, 0.08);
            transform: translateX(4px);
        }

        .path-item.completed {
            opacity: 0.6;
        }

        .path-item.current {
            border: 2px solid var(--accent-purple);
            background: rgba(139, 92, 246, 0.1);
        }

        .path-icon {
            width: 40px;
            height: 40px;
            border-radius: 50%;
            background: var(--primary-gradient);
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 1.2rem;
            color: white;
        }

        .path-content h4 {
            color: var(--accent-purple);
            margin-bottom: 0.25rem;
        }

        .path-content p {
            font-size: 0.875rem;
            color: var(--text-secondary);
        }

        /* ===== 提示框 ===== */
        .tip {
            display: flex;
            gap: 1rem;
            padding: 1.5rem;
            border-radius: 0.75rem;
            margin: 1.5rem 0;
        }

        .tip-icon {
            font-size: 1.5rem;
            flex-shrink: 0;
        }

        .tip-content {
            flex: 1;
        }

        .tip.info {
            background: rgba(6, 182, 212, 0.1);
            border: 1px solid rgba(6, 182, 212, 0.3);
        }

        .tip.warning {
            background: rgba(251, 191, 36, 0.1);
            border: 1px solid rgba(251, 191, 36, 0.3);
        }

        .tip.error {
            background: rgba(239, 68, 68, 0.1);
            border: 1px solid rgba(239, 68, 68, 0.3);
        }

        .tip.success {
            background: rgba(34, 197, 94, 0.1);
            border: 1px solid rgba(34, 197, 94, 0.3);
        }

        /* ===== 深度指示器 ===== */
        .depth-indicator {
            display: inline-flex;
            align-items: center;
            gap: 0.5rem;
            padding: 0.25rem 0.75rem;
            background: rgba(139, 92, 246, 0.1);
            border: 1px solid rgba(139, 92, 246, 0.3);
            border-radius: 20px;
            font-size: 0.875rem;
            margin-left: 1rem;
        }

        .depth-indicator.beginner {
            background: rgba(34, 197, 94, 0.1);
            border-color: rgba(34, 197, 94, 0.3);
            color: var(--accent-green);
        }

        .depth-indicator.intermediate {
            background: rgba(251, 191, 36, 0.1);
            border-color: rgba(251, 191, 36, 0.3);
            color: var(--accent-yellow);
        }

        .depth-indicator.advanced {
            background: rgba(239, 68, 68, 0.1);
            border-color: rgba(239, 68, 68, 0.3);
            color: var(--accent-red);
        }

        /* ===== 可折叠内容 ===== */
        .collapsible {
            margin: 1.5rem 0;
            border: 1px solid var(--border-color);
            border-radius: 0.75rem;
            overflow: hidden;
        }

        .collapsible-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 1.25rem 1.5rem;
            background: rgba(255, 255, 255, 0.05);
            cursor: pointer;
            transition: background var(--animation-duration) ease;
            user-select: none;
        }

        .collapsible-header:hover {
            background: rgba(255, 255, 255, 0.08);
        }

        .collapsible-title {
            display: flex;
            align-items: center;
            gap: 0.75rem;
            font-weight: 500;
        }

        .collapsible-icon {
            transition: transform var(--animation-duration) ease;
        }

        .collapsible.expanded .collapsible-icon {
            transform: rotate(180deg);
        }

        .collapsible-content {
            max-height: 0;
            overflow: hidden;
            transition: max-height var(--animation-duration) ease;
        }

        .collapsible.expanded .collapsible-content {
            max-height: 2000px;
        }

        .collapsible-inner {
            padding: 1.5rem;
        }

        /* ===== 按钮样式 ===== */
        .btn {
            padding: 0.75rem 1.5rem;
            border-radius: 0.5rem;
            border: none;
            font-weight: 500;
            cursor: pointer;
            transition: all var(--animation-duration) ease;
            display: inline-flex;
            align-items: center;
            gap: 0.5rem;
            text-decoration: none;
        }

        .btn-primary {
            background: var(--primary-gradient);
            color: white;
        }

        .btn-primary:hover {
            transform: translateY(-2px);
            box-shadow: 0 10px 20px rgba(102, 126, 234, 0.3);
        }

        .btn-secondary {
            background: transparent;
            color: var(--text-primary);
            border: 1px solid var(--border-color);
        }

        .btn-secondary:hover {
            background: rgba(255, 255, 255, 0.1);
        }

        /* ===== 学习成就系统 ===== */
        .achievement-popup {
            position: fixed;
            top: 100px;
            right: -400px;
            width: 350px;
            background: var(--bg-section);
            border: 2px solid var(--accent-yellow);
            border-radius: 1rem;
            padding: 1.5rem;
            box-shadow: var(--shadow-lg);
            z-index: 1000;
            transition: right 0.5s ease;
        }

        .achievement-popup.show {
            right: 20px;
        }

        .achievement-header {
            display: flex;
            align-items: center;
            gap: 1rem;
            margin-bottom: 1rem;
        }

        .achievement-icon {
            width: 60px;
            height: 60px;
            background: var(--accent-yellow);
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 2rem;
        }

        .achievement-content h3 {
            color: var(--accent-yellow);
            margin-bottom: 0.25rem;
        }

        /* ===== 通知样式 ===== */
        .notification {
            position: fixed;
            top: 80px;
            right: 20px;
            background: var(--accent-green);
            color: white;
            padding: 1rem 1.5rem;
            border-radius: 0.5rem;
            z-index: 1000;
            animation: slideInRight 0.3s ease;
            box-shadow: var(--shadow-lg);
        }

        @keyframes slideInRight {
            from {
                transform: translateX(100%);
                opacity: 0;
            }
            to {
                transform: translateX(0);
                opacity: 1;
            }
        }

        /* ===== 响应式设计 ===== */
        @media (max-width: 1024px) {
            .chapter-hero h1 {
                font-size: 2.5rem;
            }

            .concept-grid {
                grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            }

            .difficulty-selector {
                top: auto;
                bottom: 80px;
            }
        }

        @media (max-width: 768px) {
            .nav-title h1 {
                font-size: 1rem;
            }

            .section-card {
                padding: 1.5rem;
            }

            .chapter-hero {
                padding: 3rem 0;
            }

            .chapter-hero h1 {
                font-size: 2rem;
            }

            .chapter-hero p {
                font-size: 1rem;
            }

            .learning-loop {
                flex-direction: column;
                gap: 1rem;
            }

            .loop-connector {
                display: none;
            }

            .demo-controls {
                flex-direction: column;
                align-items: stretch;
            }

            input[type="range"] {
                width: 100%;
            }

            .learning-buddy {
                width: 90%;
                left: 5%;
                right: 5%;
            }
        }

        /* ===== 打印样式 ===== */
        @media print {
            .nav-header,
            .sidebar,
            .btn,
            .demo-controls,
            .code-action,
            .difficulty-selector,
            .learning-buddy {
                display: none;
            }

            .section-card {
                page-break-inside: avoid;
                box-shadow: none;
                border: 1px solid #ddd;
            }

            body {
                background: white;
                color: black;
            }
        }

        /* ===== 动画优化 ===== */
        @media (prefers-reduced-motion: reduce) {
            *,
            *::before,
            *::after {
                animation-duration: 0.01ms !important;
                animation-iteration-count: 1 !important;
                transition-duration: 0.01ms !important;
            }
        }

        /* ===== 工具类 ===== */
        .visually-hidden {
            position: absolute;
            width: 1px;
            height: 1px;
            padding: 0;
            margin: -1px;
            overflow: hidden;
            clip: rect(0, 0, 0, 0);
            white-space: nowrap;
            border: 0;
        }

        .text-center {
            text-align: center;
        }

        .mt-1 { margin-top: 0.5rem; }
        .mt-2 { margin-top: 1rem; }
        .mt-3 { margin-top: 1.5rem; }
        .mt-4 { margin-top: 2rem; }

        .mb-1 { margin-bottom: 0.5rem; }
        .mb-2 { margin-bottom: 1rem; }
        .mb-3 { margin-bottom: 1.5rem; }
        .mb-4 { margin-bottom: 2rem; }

        /* ===== 加载动画 ===== */
        .loading {
            display: inline-block;
            width: 20px;
            height: 20px;
            border: 3px solid rgba(255, 255, 255, 0.3);
            border-radius: 50%;
            border-top-color: var(--accent-purple);
            animation: spin 1s ease-in-out infinite;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        @keyframes fadeIn {
            from { opacity: 0; }
            to { opacity: 1; }
        }
    </style>
</head>
<body>
<!-- 导航栏 -->
<nav class="nav-header" role="navigation" aria-label="主导航">
    <div class="container">
        <div class="nav-content">
            <div class="nav-title">
                <button id="toggle-sidebar" class="btn-control" aria-label="切换侧边栏" tabindex="0">
                    <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                        <line x1="3" y1="12" x2="21" y2="12"></line>
                        <line x1="3" y1="6" x2="21" y2="6"></line>
                        <line x1="3" y1="18" x2="21" y2="18"></line>
                    </svg>
                </button>
                <h1>第1章：机器感知的第一块砖</h1>
            </div>
            <div class="nav-controls">
                <button id="toggle-buddy" class="btn-control" aria-label="学习伙伴" tabindex="0">
                    <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                        <path d="M20 21v-2a4 4 0 0 0-4-4H8a4 4 0 0 0-4 4v2"></path>
                        <circle cx="12" cy="7" r="4"></circle>
                    </svg>
                </button>
                <button id="toggle-theme" class="btn-control" aria-label="切换主题" tabindex="0">
                    <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                    </svg>
                </button>
            </div>
        </div>
        <div class="nav-progress">
            <div class="progress-bar" id="progress-bar"></div>
        </div>
    </div>
</nav>

<!-- 难度选择器 -->
<div class="difficulty-selector">
    <h4>选择学习深度</h4>
    <label class="difficulty-option active" tabindex="0">
        <input type="radio" name="difficulty" value="beginner" checked>
        <span>🌱 初学者</span>
    </label>
    <label class="difficulty-option" tabindex="0">
        <input type="radio" name="difficulty" value="intermediate">
        <span>🌿 进阶</span>
    </label>
    <label class="difficulty-option" tabindex="0">
        <input type="radio" name="difficulty" value="advanced">
        <span>🌳 深入</span>
    </label>
</div>

<!-- 侧边栏 -->
<aside class="sidebar" id="sidebar" role="navigation" aria-label="章节导航">
    <h3 style="margin-bottom: 1.5rem; color: var(--accent-purple);">目录导航</h3>
    <nav>
        <a href="#intro" class="toc-item active" tabindex="0">引言：深夜的困惑</a>
        <a href="#problem" class="toc-item" tabindex="0">发现问题：线性分类的挑战</a>
        <a href="#biology" class="toc-item" tabindex="0">生物启发：神经元的工作原理</a>
        <a href="#math-model" class="toc-item" tabindex="0">数学建模：感知机的诞生</a>
        <a href="#learning" class="toc-item" tabindex="0">学习算法：让机器自己学习</a>
        <a href="#implementation" class="toc-item" tabindex="0">代码实现：从理论到实践</a>
        <a href="#experiment" class="toc-item" tabindex="0">实战演练：鸢尾花分类</a>
        <a href="#limitation" class="toc-item" tabindex="0">致命缺陷：XOR问题</a>
        <a href="#history" class="toc-item" tabindex="0">历史回顾：AI的第一个冬天</a>
        <a href="#breakthrough" class="toc-item" tabindex="0">突破思考：深度的必要性</a>
        <a href="#summary" class="toc-item" tabindex="0">总结：承前启后</a>
    </nav>
</aside>

<!-- 侧边栏遮罩 -->
<div class="sidebar-overlay" id="sidebar-overlay"></div>

<!-- 学习伙伴系统 -->
<div class="learning-buddy" id="learning-buddy">
    <div class="buddy-header">
        <div class="buddy-avatar" id="buddy-avatar">🤖</div>
        <div class="buddy-controls">
            <button class="buddy-control-btn" id="minimize-buddy" aria-label="最小化" tabindex="0">
                <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                    <line x1="5" y1="12" x2="19" y2="12"></line>
                </svg>
            </button>
            <button class="buddy-control-btn" id="close-buddy" aria-label="关闭" tabindex="0">
                <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                    <line x1="18" y1="6" x2="6" y2="18"></line>
                    <line x1="6" y1="6" x2="18" y2="18"></line>
                </svg>
            </button>
        </div>
    </div>
    <div class="buddy-content">
        <div class="buddy-message">
            <p>嗨！我是你的AI学习助手小智。我注意到你在学习感知机，有什么需要帮助的吗？</p>
        </div>
        <div style="display: flex; gap: 0.5rem; margin-top: 1rem;">
            <button class="btn btn-secondary" onclick="getBuddyHint()" tabindex="0">给我提示</button>
            <button class="btn btn-secondary" onclick="getBuddySummary()" tabindex="0">总结要点</button>
        </div>
    </div>
</div>

<!-- 成就弹窗 -->
<div class="achievement-popup" id="achievement-popup">
    <div class="achievement-header">
        <div class="achievement-icon">🏆</div>
        <div class="achievement-content">
            <h3>解锁成就！</h3>
            <p id="achievement-text">完成第一个概念学习</p>
        </div>
    </div>
    <div class="progress" style="margin-top: 1rem;">
        <div style="height: 8px; background: rgba(255, 255, 255, 0.1); border-radius: 4px;">
            <div id="achievement-progress" style="height: 100%; width: 20%; background: var(--accent-yellow); border-radius: 4px;"></div>
        </div>
        <p style="font-size: 0.875rem; color: var(--text-secondary); margin-top: 0.5rem;">
            <span id="achievement-count">1</span>/5 完成本章学习
        </p>
    </div>
</div>

<!-- 主内容 -->
<main>
    <!-- 章节标题 -->
    <section class="chapter-hero">
        <div class="container">
            <div class="chapter-hero-content">
                <h1>机器感知的第一块砖：感知机</h1>
                <p>从生物神经元到人工智能的第一步 —— 让机器学会"看见"世界</p>
                <div class="mt-4">
                    <span style="background: rgba(255, 255, 255, 0.2); padding: 0.5rem 1rem; border-radius: 20px; margin: 0 0.5rem;">
                        🧠 仿生学习
                    </span>
                    <span style="background: rgba(255, 255, 255, 0.2); padding: 0.5rem 1rem; border-radius: 20px; margin: 0 0.5rem;">
                        ⏱️ 60分钟
                    </span>
                    <span style="background: rgba(255, 255, 255, 0.2); padding: 0.5rem 1rem; border-radius: 20px; margin: 0 0.5rem;">
                        🎯 奠基之作
                    </span>
                </div>
            </div>
        </div>
    </section>

    <div class="container">
        <!-- 学习目标 -->
        <section class="section-card">
            <h2 style="color: var(--accent-purple); margin-bottom: 1.5rem;">📚 本章学习目标</h2>
            <div class="concept-grid">
                <div class="concept-card what" tabindex="0">
                    <h3 style="color: var(--accent-green); margin-bottom: 0.5rem;">✓ 理解核心概念</h3>
                    <p>掌握感知机的数学模型和几何意义，理解线性分类的本质</p>
                </div>
                <div class="concept-card how" tabindex="0">
                    <h3 style="color: var(--accent-blue); margin-bottom: 0.5rem;">✓ 掌握学习算法</h3>
                    <p>深入理解感知机学习规则，体会机器学习的基本思想</p>
                </div>
                <div class="concept-card why" tabindex="0">
                    <h3 style="color: var(--accent-red); margin-bottom: 0.5rem;">✓ 发现根本局限</h3>
                    <p>通过XOR问题认识线性模型的天花板，理解深度的必要性</p>
                </div>
                <div class="concept-card pitfall" tabindex="0">
                    <h3 style="color: var(--accent-yellow); margin-bottom: 0.5rem;">✓ 汲取历史教训</h3>
                    <p>了解AI第一个冬天的来龙去脉，培养批判性思维</p>
                </div>
            </div>
        </section>

        <!-- 学习路径推荐 -->
        <section class="learning-path">
            <h3 style="color: var(--accent-purple); margin-bottom: 1.5rem;">🗺️ 推荐学习路径</h3>
            <div class="path-item completed" tabindex="0">
                <div class="path-icon">✓</div>
                <div class="path-content">
                    <h4>前置知识检查</h4>
                    <p>线性代数基础、Python编程</p>
                </div>
            </div>
            <div class="path-item current" tabindex="0">
                <div class="path-icon">📍</div>
                <div class="path-content">
                    <h4>当前章节：感知机</h4>
                    <p>深度学习的第一块基石</p>
                </div>
            </div>
            <div class="path-item" tabindex="0">
                <div class="path-icon">🔜</div>
                <div class="path-content">
                    <h4>下一站：反向传播</h4>
                    <p>深度网络的训练核心</p>
                </div>
            </div>
        </section>

        <!-- 学习循环1：引言故事 -->
        <section id="intro" class="section-card">
            <div class="learning-loop">
                <div class="loop-step active">
                    <span class="icon">🤔</span>
                    <span class="label">引发好奇</span>
                    <span class="loop-connector"></span>
                </div>
                <div class="loop-step">
                    <span class="icon">📖</span>
                    <span class="label">核心概念</span>
                    <span class="loop-connector"></span>
                </div>
                <div class="loop-step">
                    <span class="icon">🎯</span>
                    <span class="label">即时练习</span>
                    <span class="loop-connector"></span>
                </div>
                <div class="loop-step">
                    <span class="icon">💡</span>
                    <span class="label">总结提升</span>
                </div>
            </div>

            <div class="story-card">
                <h2 style="color: var(--accent-yellow); margin-bottom: 1.5rem;">🌙 凌晨2点37分，北航新主楼的不眠之夜</h2>

                <!-- 增强的人物背景 -->
                <div style="background: rgba(0, 0, 0, 0.2); padding: 1rem; border-radius: 0.5rem; margin-bottom: 2rem;">
                    <p style="font-style: italic; color: var(--text-secondary);">
                        陈明，计算机系大三学生，绰号"小陈"。平时成绩中等，但对AI充满热情。
                        这是他第三次尝试完成机器学习作业，前两次都以失败告终...
                    </p>
                </div>

                <!-- 场景设定 -->
                <div style="display: grid; grid-template-columns: 1fr auto 1fr; gap: 2rem; align-items: center; margin-bottom: 2rem;">
                    <div style="text-align: center;">
                        <div style="width: 80px; height: 80px; border-radius: 50%; background: linear-gradient(135deg, #fbbf24, #f59e0b); display: flex; align-items: center; justify-content: center; font-size: 2rem; margin: 0 auto 1rem; box-shadow: 0 8px 25px rgba(251, 191, 36, 0.3);">
                            😵
                        </div>
                        <div style="color: var(--text-secondary); font-size: 1.1rem;">
                            <strong style="color: var(--accent-yellow);">疲惫的小陈</strong><br>
                            "为什么看起来这么简单的问题，就是解决不了..."
                        </div>
                    </div>

                    <div style="color: var(--accent-purple); font-size: 2rem;">💭</div>

                    <div style="text-align: center;">
                        <div style="width: 80px; height: 80px; border-radius: 50%; background: linear-gradient(135deg, #06b6d4, #0891b2); display: flex; align-items: center; justify-content: center; font-size: 2rem; margin: 0 auto 1rem; box-shadow: 0 8px 25px rgba(6, 182, 212, 0.3);">
                            📊
                        </div>
                        <div style="color: var(--text-secondary); font-size: 1.1rem;">
                            <strong style="color: var(--accent-blue);">作业要求</strong><br>
                            "根据平时成绩，预测学生是否能通过考试"
                        </div>
                    </div>
                </div>

                <!-- 内心独白 -->
                <div style="background: rgba(139, 92, 246, 0.1); padding: 1.5rem; border-radius: 0.5rem; margin-bottom: 2rem;">
                    <p style="font-style: italic;">
                        💭 "我已经试了各种if-else组合，甚至用了十几个条件判断，但准确率就是上不去。
                        难道真的要一个个调整阈值吗？一定有更聪明的方法..."
                    </p>
                </div>

                <!-- 对话场景 -->
                <div class="dialogue-container">
                    <div class="dialogue-item">
                        <div class="dialogue-avatar student">😓</div>
                        <div class="dialogue-content">
                            <div class="dialogue-name">小陈</div>
                            <p>我的第一次尝试是这样的...</p>
                        </div>
                    </div>
                </div>

                <div class="tip info">
                    <span class="tip-icon">💻</span>
                    <div class="tip-content">
                        <strong>第一次尝试：暴力if-else</strong><br>
                        <code style="background: rgba(0,0,0,0.2); padding: 0.2rem 0.5rem; border-radius: 4px;">
                            if (作业分数 > 60 and 期中成绩 > 60): return "通过"
                        </code><br><br>
                        结果：准确率只有65%！<br>
                        "不对啊，有些学生作业80分、期中50分也通过了..."
                    </div>
                </div>

                <div class="dialogue-container mt-3">
                    <div class="dialogue-item">
                        <div class="dialogue-avatar friend">🤓</div>
                        <div class="dialogue-content">
                            <div class="dialogue-name">室友小李（凌晨被吵醒）</div>
                            <p>你为啥不试试加权平均？就像GPA计算那样。</p>
                        </div>
                    </div>
                    <div class="dialogue-item">
                        <div class="dialogue-avatar student">🤔</div>
                        <div class="dialogue-content">
                            <div class="dialogue-name">小陈</div>
                            <p>对啊！可是权重该怎么定呢？</p>
                        </div>
                    </div>
                </div>

                <div class="tip error mt-3">
                    <span class="tip-icon">😱</span>
                    <div class="tip-content">
                        <strong>第二次尝试：复杂规则</strong><br>
                        <code style="background: rgba(0,0,0,0.2); padding: 0.2rem 0.5rem; border-radius: 4px;">
                            if (0.6*作业 + 0.4*期中 > 65): return "通过"
                        </code><br><br>
                        结果：准确率提升到72%，但是...<br>
                        "权重0.6和0.4是我瞎猜的，怎么才能找到最佳权重？"
                    </div>
                </div>

                <!-- 转折点 -->
                <div class="dialogue-container mt-3">
                    <div class="dialogue-item">
                        <div class="dialogue-avatar teacher">👨‍🏫</div>
                        <div class="dialogue-content">
                            <div class="dialogue-name">王教授（突然出现在实验室）</div>
                            <p>小陈，还在熬夜啊？你遇到的问题，其实60年前就有人解决了。
                                听说过感知机吗？</p>
                        </div>
                    </div>
                </div>

                <div class="tip warning mt-3">
                    <span class="tip-icon">💡</span>
                    <div class="tip-content">
                        <strong>关键问题浮现</strong><br>
                        1. 如何找到最佳的分界线？<br>
                        2. 能否让机器自己学习这条线？<br>
                        3. 这个问题的本质是什么？
                    </div>
                </div>
            </div>

            <!-- 即时练习 -->
            <div class="instant-practice">
                <h3 style="color: var(--accent-green); margin-bottom: 1rem;">🎯 思考练习</h3>
                <div class="practice-question">
                    在小陈的问题中，什么是最关键的挑战？
                </div>
                <div class="practice-options">
                    <button class="practice-option" data-answer="a" tabindex="0">
                        A. 数据量太少
                    </button>
                    <button class="practice-option" data-answer="b" tabindex="0">
                        B. 不知道如何确定最佳的权重参数
                    </button>
                    <button class="practice-option" data-answer="c" tabindex="0">
                        C. Python代码写得不好
                    </button>
                    <button class="practice-option" data-answer="d" tabindex="0">
                        D. 计算机性能不够
                    </button>
                </div>
                <div class="practice-feedback" id="practice-feedback-1"></div>
            </div>
        </section>

        <!-- 学习循环2：发现问题 -->
        <section id="problem" class="section-card">
            <div class="learning-loop">
                <div class="loop-step">
                    <span class="icon">🤔</span>
                    <span class="label">引发好奇</span>
                    <span class="loop-connector"></span>
                </div>
                <div class="loop-step active">
                    <span class="icon">📖</span>
                    <span class="label">核心概念</span>
                    <span class="loop-connector"></span>
                </div>
                <div class="loop-step">
                    <span class="icon">🎯</span>
                    <span class="label">即时练习</span>
                    <span class="loop-connector"></span>
                </div>
                <div class="loop-step">
                    <span class="icon">💡</span>
                    <span class="label">总结提升</span>
                </div>
            </div>

            <h2 style="color: var(--accent-red); margin-bottom: 1.5rem;">
                🎯 可视化问题：到底在寻找什么？
                <span class="depth-indicator beginner">初学者</span>
            </h2>

            <!-- 交互式可视化 -->
            <div class="interactive-demo">
                <h3 style="color: var(--accent-blue); margin-bottom: 1.5rem;">📊 学生成绩分布（交互式）</h3>

                <div class="demo-controls">
                    <div class="control-group">
                        <label>权重 w₁（作业分数）</label>
                        <div class="slider-container">
                            <input type="range" id="w1-slider" min="-2" max="2" step="0.1" value="1">
                            <span class="slider-value" id="w1-value">1.0</span>
                        </div>
                    </div>
                    <div class="control-group">
                        <label>权重 w₂（期中成绩）</label>
                        <div class="slider-container">
                            <input type="range" id="w2-slider" min="-2" max="2" step="0.1" value="1">
                            <span class="slider-value" id="w2-value">1.0</span>
                        </div>
                    </div>
                    <div class="control-group">
                        <label>偏置 b</label>
                        <div class="slider-container">
                            <input type="range" id="b-slider" min="-200" max="0" step="10" value="-120">
                            <span class="slider-value" id="b-value">-120</span>
                        </div>
                    </div>
                    <button class="btn btn-primary" onclick="autoTrain()" tabindex="0">🎯 自动训练</button>
                    <button class="btn btn-secondary" onclick="resetParams()" tabindex="0">🔄 重置</button>
                </div>

                <canvas id="perceptron-canvas" width="800" height="400"></canvas>

                <div style="margin-top: 1rem; text-align: center;">
                    <span style="color: var(--accent-green);">正确分类：<span id="correct-count">0</span></span>
                    <span style="margin: 0 2rem;">|</span>
                    <span style="color: var(--accent-red);">错误分类：<span id="error-count">0</span></span>
                    <span style="margin: 0 2rem;">|</span>
                    <span style="color: var(--accent-yellow);">准确率：<span id="accuracy">0%</span></span>
                </div>

                <div class="tip info mt-3">
                    <span class="tip-icon">💡</span>
                    <div class="tip-content">
                        <strong>交互提示：</strong><br>
                        • 拖动滑块调整参数，观察决策边界的变化<br>
                        • 点击画布添加新的数据点<br>
                        • 点击"自动训练"让感知机自己学习最佳参数
                    </div>
                </div>
            </div>

            <!-- 深入理解 -->
            <div class="collapsible mt-4 beginner-content">
                <div class="collapsible-header" tabindex="0">
                    <div class="collapsible-title">
                        <span>🤔</span>
                        <span>深入理解：什么是线性可分？</span>
                        <span class="depth-indicator beginner">初学者</span>
                    </div>
                    <svg class="collapsible-icon" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                        <polyline points="6 9 12 15 18 9"></polyline>
                    </svg>
                </div>
                <div class="collapsible-content">
                    <div class="collapsible-inner">
                        <p>想象你是一个农场主，要把苹果和橙子分开：</p>
                        <ul style="line-height: 2; margin-top: 1rem;">
                            <li>🍎 如果能用一条直线完全分开 → 线性可分</li>
                            <li>🍊 如果怎么画直线都不能完全分开 → 线性不可分</li>
                        </ul>
                        <div style="background: rgba(139, 92, 246, 0.1); padding: 1rem; border-radius: 0.5rem; margin-top: 1rem;">
                            <strong>数学表达：</strong><br>
                            存在w和b，使得对所有样本：<br>
                            • 正类：w·x + b > 0<br>
                            • 负类：w·x + b < 0
                        </div>
                    </div>
                </div>
            </div>

            <!-- 进阶内容 -->
            <div class="collapsible mt-2 intermediate-content" style="display: none;">
                <div class="collapsible-header" tabindex="0">
                    <div class="collapsible-title">
                        <span>🔬</span>
                        <span>进阶：决策边界的几何意义</span>
                        <span class="depth-indicator intermediate">进阶</span>
                    </div>
                    <svg class="collapsible-icon" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                        <polyline points="6 9 12 15 18 9"></polyline>
                    </svg>
                </div>
                <div class="collapsible-content">
                    <div class="collapsible-inner">
                        <div class="math-derivation">
                            <h4>为什么 w·x + b = 0 表示一条直线？</h4>

                            <div class="math-step" data-step="1">
                                <strong>展开内积：</strong><br>
                                w·x + b = w₁x₁ + w₂x₂ + b = 0
                            </div>

                            <div class="math-step" data-step="2">
                                <strong>变形为斜截式：</strong><br>
                                x₂ = -(w₁/w₂)x₁ - (b/w₂)
                                <div class="math-explanation">
                                    这就是直线方程 y = mx + c 的形式！<br>
                                    斜率 m = -w₁/w₂，截距 c = -b/w₂
                                </div>
                            </div>

                            <div class="math-step" data-step="3">
                                <strong>法向量解释：</strong><br>
                                向量 w = (w₁, w₂) 垂直于决策边界
                                <div class="math-explanation">
                                    w 指向正类方向，决定了分类的方向性
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
            </div>

            <!-- 即时练习 -->
            <div class="instant-practice">
                <h3 style="color: var(--accent-green); margin-bottom: 1rem;">🎯 快速检验</h3>
                <div class="practice-question">
                    在二维平面上，方程 w₁x₁ + w₂x₂ + b = 0 表示的是什么？
                </div>
                <div class="practice-options">
                    <button class="practice-option" data-answer="a" tabindex="0">
                        A. 一个点
                    </button>
                    <button class="practice-option" data-answer="b" tabindex="0">
                        B. 一条直线
                    </button>
                    <button class="practice-option" data-answer="c" tabindex="0">
                        C. 一个圆
                    </button>
                    <button class="practice-option" data-answer="d" tabindex="0">
                        D. 一个抛物线
                    </button>
                </div>
                <div class="practice-feedback" id="practice-feedback-2"></div>
            </div>
        </section>

        <!-- 生物启发部分 -->
        <section id="biology" class="section-card">
            <h2 style="color: var(--accent-green); margin-bottom: 1.5rem;">
                🧠 生物启发：向大自然学习
                <span class="depth-indicator beginner">初学者</span>
            </h2>

            <!-- 故事化的引入 -->
            <div class="dialogue-container">
                <div class="dialogue-item">
                    <div class="dialogue-avatar teacher">👨‍🏫</div>
                    <div class="dialogue-content">
                        <div class="dialogue-name">王教授</div>
                        <p>小陈，你知道吗？我们的大脑有大约860亿个神经元，每个神经元都在做一件简单的事：
                            收集信号，判断是否要"激活"。</p>
                    </div>
                </div>
                <div class="dialogue-item">
                    <div class="dialogue-avatar student">😮</div>
                    <div class="dialogue-content">
                        <div class="dialogue-name">小陈</div>
                        <p>就像我在判断学生是否通过考试？收集分数，然后决定？</p>
                    </div>
                </div>
                <div class="dialogue-item">
                    <div class="dialogue-avatar teacher">👨‍🏫</div>
                    <div class="dialogue-content">
                        <div class="dialogue-name">王教授</div>
                        <p>没错！1943年，McCulloch和Pitts就是这么想的。让我画给你看...</p>
                    </div>
                </div>
            </div>

            <!-- 神经元对比可视化 -->
            <div class="interactive-demo">
                <h3 style="color: var(--accent-purple); margin-bottom: 1.5rem;">🔬 生物神经元 vs 人工神经元</h3>

                <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 2rem;">
                    <!-- 生物神经元 -->
                    <div style="text-align: center;">
                        <h4 style="color: var(--accent-green);">生物神经元</h4>
                        <canvas id="bio-neuron-canvas" width="400" height="300"></canvas>
                        <div style="text-align: left; margin-top: 1rem; padding: 1rem; background: rgba(34, 197, 94, 0.1); border-radius: 0.5rem;">
                            <p><strong>工作原理：</strong></p>
                            <ol style="line-height: 1.8;">
                                <li>树突接收其他神经元的信号</li>
                                <li>细胞体整合所有输入信号</li>
                                <li>当总和超过阈值时，产生动作电位</li>
                                <li>通过轴突传递信号给其他神经元</li>
                            </ol>
                        </div>
                    </div>

                    <!-- 人工神经元 -->
                    <div style="text-align: center;">
                        <h4 style="color: var(--accent-purple);">人工神经元（感知机）</h4>
                        <canvas id="artificial-neuron-canvas" width="400" height="300"></canvas>
                        <div style="text-align: left; margin-top: 1rem; padding: 1rem; background: rgba(139, 92, 246, 0.1); border-radius: 0.5rem;">
                            <p><strong>数学模型：</strong></p>
                            <ol style="line-height: 1.8;">
                                <li>输入：x₁, x₂, ..., xₙ</li>
                                <li>权重：w₁, w₂, ..., wₙ</li>
                                <li>加权和：Σ(wᵢxᵢ) + b</li>
                                <li>激活函数：sign(加权和)</li>
                            </ol>
                        </div>
                    </div>
                </div>

                <div class="tip info mt-3">
                    <span class="tip-icon">🔗</span>
                    <div class="tip-content">
                        <strong>关键对应关系：</strong><br>
                        • 树突 ↔ 输入<br>
                        • 突触强度 ↔ 权重<br>
                        • 细胞体 ↔ 求和单元<br>
                        • 激活阈值 ↔ 偏置<br>
                        • 轴突 ↔ 输出
                    </div>
                </div>
            </div>

            <!-- 历史背景 -->
            <div class="collapsible mt-4">
                <div class="collapsible-header" tabindex="0">
                    <div class="collapsible-title">
                        <span>📚</span>
                        <span>历史背景：神经网络研究的开端</span>
                    </div>
                    <svg class="collapsible-icon" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                        <polyline points="6 9 12 15 18 9"></polyline>
                    </svg>
                </div>
                <div class="collapsible-content">
                    <div class="collapsible-inner">
                        <div style="background: rgba(251, 191, 36, 0.1); padding: 1.5rem; border-radius: 0.5rem;">
                            <h4 style="color: var(--accent-yellow);">1943年：开创性论文</h4>
                            <p><strong>《A Logical Calculus of Ideas Immanent in Nervous Activity》</strong></p>
                            <p style="margin-top: 0.5rem;">McCulloch（神经科学家）和 Pitts（数学家）首次提出用数学模型描述神经元。
                                当时Pitts只有20岁！</p>
                        </div>

                        <div style="margin-top: 1rem;">
                            <h4>主要贡献：</h4>
                            <ul style="line-height: 2;">
                                <li>证明了神经网络可以计算任何逻辑函数</li>
                                <li>奠定了计算神经科学的基础</li>
                                <li>启发了后续的感知机研究</li>
                            </ul>
                        </div>
                    </div>
                </div>
            </div>
        </section>

        <!-- 数学建模部分 -->
        <section id="math-model" class="section-card">
            <h2 style="color: var(--accent-purple); margin-bottom: 1.5rem;">
                📐 数学建模：感知机的诞生
                <span class="depth-indicator intermediate">进阶</span>
            </h2>

            <!-- 渐进式数学推导 -->
            <div class="math-derivation">
                <h3>从直觉到公式：一步步构建感知机</h3>

                <div class="math-step" data-step="1">
                    <strong>直觉：加权投票</strong>
                    <p>就像评委打分，每个特征都有不同的重要性（权重）</p>
                    <div style="text-align: center; margin: 1rem 0;">
                        总分 = 特征1×权重1 + 特征2×权重2 + ... + 特征n×权重n
                    </div>
                </div>

                <div class="math-step" data-step="2">
                    <strong>数学化：内积形式</strong>
                    <p>用向量简洁表示：</p>
                    <div style="text-align: center; margin: 1rem 0; font-size: 1.2rem;">
                        z = w·x + b = Σ(wᵢxᵢ) + b
                    </div>
                    <div class="math-explanation">
                        其中：w是权重向量，x是输入向量，b是偏置（阈值的相反数）
                    </div>
                </div>

                <div class="math-step" data-step="3">
                    <strong>决策：符号函数</strong>
                    <p>将连续的得分转换为离散的类别：</p>
                    <div style="text-align: center; margin: 1rem 0; font-size: 1.2rem;">
                        y = sign(z) = { +1, if z ≥ 0; -1, if z < 0 }
                    </div>
                    <div class="math-explanation">
                        正分 → 正类（+1），负分 → 负类（-1）
                    </div>
                </div>

                <div class="math-step" data-step="4">
                    <strong>完整模型：感知机</strong>
                    <div style="text-align: center; margin: 1rem 0; font-size: 1.3rem; color: var(--accent-purple);">
                        f(x) = sign(w·x + b)
                    </div>
                </div>
            </div>

            <!-- 几何解释的交互式演示 -->
            <div class="interactive-demo mt-4">
                <h3 style="color: var(--accent-blue); margin-bottom: 1.5rem;">🎨 几何直观：超平面的魔力</h3>

                <div class="demo-controls">
                    <div class="control-group">
                        <label>视角旋转</label>
                        <div class="slider-container">
                            <input type="range" id="rotation-slider" min="0" max="360" value="45">
                            <span class="slider-value" id="rotation-value">45°</span>
                        </div>
                    </div>
                    <div class="control-group">
                        <label>俯仰角度</label>
                        <div class="slider-container">
                            <input type="range" id="elevation-slider" min="0" max="90" value="30">
                            <span class="slider-value" id="elevation-value">30°</span>
                        </div>
                    </div>
                    <button class="btn btn-secondary" onclick="toggleAnimation()" tabindex="0">
                        <span id="animation-toggle">▶️ 播放动画</span>
                    </button>
                </div>

                <canvas id="hyperplane-canvas" width="800" height="500"></canvas>

                <div class="tip info mt-3">
                    <span class="tip-icon">💡</span>
                    <div class="tip-content">
                        <strong>关键洞察：</strong><br>
                        • 在n维空间中，w·x + b = 0 定义了一个(n-1)维的超平面<br>
                        • 这个超平面将整个空间分成两半：正类区域和负类区域<br>
                        • 感知机的本质就是寻找这样一个最优的分割超平面
                    </div>
                </div>
            </div>

            <!-- 常见错误提醒 -->
            <div class="common-mistakes">
                <h3 style="color: var(--accent-red); margin-bottom: 1rem;">⚠️ 常见误区</h3>

                <div class="mistake-item">
                    <div class="mistake-icon">❌</div>
                    <div class="mistake-content">
                        <h4>误区1：忘记偏置项</h4>
                        <p>很多初学者实现感知机时忘记加偏置b，导致决策边界必须过原点，
                            大大限制了模型的表达能力。</p>
                        <p style="color: var(--accent-green); margin-top: 0.5rem;">
                            ✓ 正确做法：始终包含偏置项，或将其作为额外的权重处理
                        </p>
                    </div>
                </div>

                <div class="mistake-item">
                    <div class="mistake-icon">❌</div>
                    <div class="mistake-content">
                        <h4>误区2：混淆输出值</h4>
                        <p>感知机输出的是离散的类别标签（+1或-1），不是概率值！</p>
                        <p style="color: var(--accent-green); margin-top: 0.5rem;">
                            ✓ 正确理解：sign函数产生的是"硬"分类，不像逻辑回归那样输出概率
                        </p>
                    </div>
                </div>
            </div>
        </section>

        <!-- 学习算法部分 -->
        <section id="learning" class="section-card">
            <h2 style="color: var(--accent-green); margin-bottom: 1.5rem;">
                🎯 感知机学习算法：让机器自己学习
                <span class="depth-indicator intermediate">进阶</span>
            </h2>

            <!-- 算法发现的故事 -->
            <div class="dialogue-container">
                <div class="dialogue-item">
                    <div class="dialogue-avatar student">💡</div>
                    <div class="dialogue-content">
                        <div class="dialogue-name">小陈（恍然大悟）</div>
                        <p>教授，我明白了！就像我们从错误中学习一样，
                            机器也可以从分类错误中调整自己的参数！</p>
                    </div>
                </div>
                <div class="dialogue-item">
                    <div class="dialogue-avatar teacher">👨‍🏫</div>
                    <div class="dialogue-content">
                        <div class="dialogue-name">王教授</div>
                        <p>正是如此！Rosenblatt在1957年提出的感知机学习规则，
                            本质上就是"错误驱动"的学习。让我们一起推导...</p>
                    </div>
                </div>
            </div>

            <!-- 学习算法的直观解释 -->
            <div class="math-derivation">
                <h3>感知机学习规则：从错误中学习</h3>

                <div class="math-step" data-step="1">
                    <strong>核心思想</strong>
                    <p>只在预测错误时更新参数，正确时保持不变</p>
                    <div class="math-explanation">
                        "If it ain't broke, don't fix it" —— 如果没坏，就别修它
                    </div>
                </div>

                <div class="math-step" data-step="2">
                    <strong>错误情况分析</strong>
                    <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 1rem; margin-top: 1rem;">
                        <div style="background: rgba(239, 68, 68, 0.1); padding: 1rem; border-radius: 0.5rem;">
                            <h5>情况1：假阴性</h5>
                            <p>真实：+1，预测：-1</p>
                            <p>说明：w·x + b 太小了</p>
                            <p>解决：增大 w·x</p>
                        </div>
                        <div style="background: rgba(239, 68, 68, 0.1); padding: 1rem; border-radius: 0.5rem;">
                            <h5>情况2：假阳性</h5>
                            <p>真实：-1，预测：+1</p>
                            <p>说明：w·x + b 太大了</p>
                            <p>解决：减小 w·x</p>
                        </div>
                    </div>
                </div>

                <div class="math-step" data-step="3">
                    <strong>更新规则推导</strong>
                    <p>统一的更新公式（当预测错误时）：</p>
                    <div style="text-align: center; margin: 1rem 0; font-size: 1.2rem;">
                        w ← w + η·y·x<br>
                        b ← b + η·y
                    </div>
                    <div class="math-explanation">
                        • η 是学习率（步长），控制每次调整的幅度<br>
                        • y 是真实标签（+1或-1），决定调整的方向<br>
                        • x 是当前样本，决定调整的具体内容
                    </div>
                </div>
            </div>

            <!-- 算法可视化演示 -->
            <div class="interactive-demo mt-4">
                <h3 style="color: var(--accent-yellow); margin-bottom: 1.5rem;">🎬 学习过程可视化</h3>

                <div class="demo-controls">
                    <div class="control-group">
                        <label>学习率 η</label>
                        <div class="slider-container">
                            <input type="range" id="lr-slider" min="0.01" max="1" step="0.01" value="0.1">
                            <span class="slider-value" id="lr-value">0.1</span>
                        </div>
                    </div>
                    <div class="control-group">
                        <label>训练速度</label>
                        <div class="slider-container">
                            <input type="range" id="speed-slider" min="100" max="2000" step="100" value="500">
                            <span class="slider-value" id="speed-value">500ms</span>
                        </div>
                    </div>
                    <button class="btn btn-primary" onclick="startTraining()" tabindex="0">
                        <span id="train-button">▶️ 开始训练</span>
                    </button>
                    <button class="btn btn-secondary" onclick="stepTraining()" tabindex="0">
                        ⏭️ 单步执行
                    </button>
                </div>

                <canvas id="training-canvas" width="800" height="400"></canvas>

                <div style="margin-top: 1rem;">
                    <div style="background: rgba(0, 0, 0, 0.2); padding: 1rem; border-radius: 0.5rem; font-family: monospace;">
                        <div>轮次：<span id="epoch-count">0</span></div>
                        <div>当前样本：<span id="current-sample">-</span></div>
                        <div>预测结果：<span id="prediction">-</span></div>
                        <div>更新信息：<span id="update-info">等待开始...</span></div>
                    </div>
                </div>
            </div>

            <!-- 收敛性证明 -->
            <div class="collapsible mt-4 advanced-content" style="display: none;">
                <div class="collapsible-header" tabindex="0">
                    <div class="collapsible-title">
                        <span>🔬</span>
                        <span>感知机收敛定理（Novikoff, 1962）</span>
                        <span class="depth-indicator advanced">深入</span>
                    </div>
                    <svg class="collapsible-icon" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                        <polyline points="6 9 12 15 18 9"></polyline>
                    </svg>
                </div>
                <div class="collapsible-content">
                    <div class="collapsible-inner">
                        <div class="math-derivation">
                            <h4>定理陈述</h4>
                            <p>如果训练数据集是<strong>线性可分</strong>的，那么感知机学习算法一定会在<strong>有限步内收敛</strong>。</p>

                            <div class="math-step" data-step="1">
                                <strong>前提条件</strong>
                                <p>存在最优解 (w*, b*) 和间隔 γ > 0，使得：</p>
                                <div style="text-align: center; margin: 0.5rem 0;">
                                    y(w*·x + b*) ≥ γ, ∀(x, y) ∈ D
                                </div>
                            </div>

                            <div class="math-step" data-step="2">
                                <strong>证明要点</strong>
                                <p>1. 每次更新使 w 向 w* 靠近：</p>
                                <div style="text-align: center; margin: 0.5rem 0;">
                                    w_{k+1}·w* ≥ w_k·w* + ηγ
                                </div>
                                <p>2. 权重的模长增长有界：</p>
                                <div style="text-align: center; margin: 0.5rem 0;">
                                    ||w_{k+1}||² ≤ ||w_k||² + η²R²
                                </div>
                            </div>

                            <div class="math-step" data-step="3">
                                <strong>收敛上界</strong>
                                <p>迭代次数的上界：</p>
                                <div style="text-align: center; margin: 0.5rem 0; font-size: 1.2rem;">
                                    k ≤ (R/γ)²
                                </div>
                                <div class="math-explanation">
                                    其中 R = max||x||，表示数据的最大范数
                                </div>
                            </div>
                        </div>

                        <div class="tip warning mt-3">
                            <span class="tip-icon">⚠️</span>
                            <div class="tip-content">
                                <strong>关键前提：</strong>数据必须是线性可分的！<br>
                                如果不可分，算法将永远震荡，无法收敛。
                            </div>
                        </div>
                    </div>
                </div>
            </div>

            <!-- 深入理解：具体计算过程 -->
            <div class="collapsible mt-4 expanded">
                <div class="collapsible-header" tabindex="0">
                    <div class="collapsible-title">
                        <span>🔬</span>
                        <span>深入理解：手把手计算感知机如何找到最优解</span>
                        <span class="depth-indicator intermediate">进阶</span>
                    </div>
                    <svg class="collapsible-icon" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                        <polyline points="6 9 12 15 18 9"></polyline>
                    </svg>
                </div>
                <div class="collapsible-content">
                    <div class="collapsible-inner">
                        <!-- 具体例子介绍 -->
                        <div class="example-box" style="background: rgba(139, 92, 246, 0.05); border: 2px solid rgba(139, 92, 246, 0.3); padding: 2rem; border-radius: 1rem;">
                            <h4 style="color: var(--accent-purple); margin-bottom: 1rem;">📐 让我们用一个简单的例子，手算感知机的学习过程</h4>

                            <p><strong>问题设定：</strong>在2D平面上有4个点，我们要找到一条直线将它们正确分类。</p>

                            <div style="display: grid; grid-template-columns: 1fr 2fr; gap: 2rem; align-items: center; margin-top: 1.5rem;">
                                <div>
                                    <table style="width: 100%; text-align: center; border-collapse: collapse;">
                                        <thead>
                                        <tr style="background: rgba(139, 92, 246, 0.1);">
                                            <th style="padding: 0.75rem; border: 1px solid var(--border-color);">点</th>
                                            <th style="padding: 0.75rem; border: 1px solid var(--border-color);">坐标(x₁,x₂)</th>
                                            <th style="padding: 0.75rem; border: 1px solid var(--border-color);">标签y</th>
                                        </tr>
                                        </thead>
                                        <tbody>
                                        <tr>
                                            <td style="padding: 0.5rem; border: 1px solid var(--border-color);">A</td>
                                            <td style="padding: 0.5rem; border: 1px solid var(--border-color);">(3, 3)</td>
                                            <td style="padding: 0.5rem; border: 1px solid var(--border-color); color: var(--accent-blue);">+1</td>
                                        </tr>
                                        <tr>
                                            <td style="padding: 0.5rem; border: 1px solid var(--border-color);">B</td>
                                            <td style="padding: 0.5rem; border: 1px solid var(--border-color);">(4, 3)</td>
                                            <td style="padding: 0.5rem; border: 1px solid var(--border-color); color: var(--accent-blue);">+1</td>
                                        </tr>
                                        <tr>
                                            <td style="padding: 0.5rem; border: 1px solid var(--border-color);">C</td>
                                            <td style="padding: 0.5rem; border: 1px solid var(--border-color);">(1, 1)</td>
                                            <td style="padding: 0.5rem; border: 1px solid var(--border-color); color: var(--accent-red);">-1</td>
                                        </tr>
                                        <tr>
                                            <td style="padding: 0.5rem; border: 1px solid var(--border-color);">D</td>
                                            <td style="padding: 0.5rem; border: 1px solid var(--border-color);">(2, 1)</td>
                                            <td style="padding: 0.5rem; border: 1px solid var(--border-color); color: var(--accent-red);">-1</td>
                                        </tr>
                                        </tbody>
                                    </table>

                                    <div style="margin-top: 1rem; padding: 1rem; background: rgba(255, 255, 255, 0.05); border-radius: 0.5rem;">
                                        <p><strong>初始化：</strong></p>
                                        <p>w = [0, 0]ᵀ</p>
                                        <p>b = 0</p>
                                        <p>学习率 η = 1</p>
                                    </div>
                                </div>

                                <div>
                                    <canvas id="perceptron-math-viz" width="400" height="400" style="background: rgba(0, 0, 0, 0.1); border-radius: 0.5rem;"></canvas>
                                </div>
                            </div>
                        </div>

                        <!-- 交互式计算演示 -->
                        <div class="interactive-demo mt-4">
                            <h4 style="color: var(--accent-yellow); margin-bottom: 1.5rem;">🎯 交互式计算过程</h4>

                            <div class="demo-controls">
                                <button class="btn btn-primary" id="start-calculation" onclick="startCalculation()" tabindex="0">
                                    ▶️ 开始计算
                                </button>
                                <button class="btn btn-secondary" onclick="stepCalculation()" tabindex="0">
                                    ⏭️ 单步执行
                                </button>
                                <button class="btn btn-secondary" onclick="resetCalculation()" tabindex="0">
                                    🔄 重置
                                </button>
                                <span style="margin-left: 2rem;">速度：</span>
                                <input type="range" id="calc-speed" min="500" max="3000" value="1500" style="width: 150px;">
                                <span id="calc-speed-value">1.5s</span>
                            </div>

                            <!-- 计算过程显示 -->
                            <div id="calculation-display" style="margin-top: 2rem;">
                                <!-- 当前步骤 -->
                                <div style="background: rgba(34, 197, 94, 0.1); border: 2px solid rgba(34, 197, 94, 0.3); padding: 1.5rem; border-radius: 0.5rem; margin-bottom: 1rem;">
                                    <h5 style="color: var(--accent-green); margin-bottom: 1rem;">当前步骤</h5>
                                    <div id="current-calculation" style="font-family: 'SF Mono', monospace; line-height: 1.8;">
                                        <div>迭代轮次: <span id="calc-epoch" style="font-weight: bold;">0</span></div>
                                        <div>当前样本: <span id="calc-sample" style="font-weight: bold;">等待开始...</span></div>
                                        <div>当前参数: w = [<span id="calc-w" style="color: var(--accent-purple);">0, 0</span>], b = <span id="calc-b" style="color: var(--accent-purple);">0</span></div>
                                    </div>
                                </div>

                                <!-- 详细计算步骤 -->
                                <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 1rem;">
                                    <!-- 计算过程 -->
                                    <div style="background: rgba(6, 182, 212, 0.05); border: 1px solid rgba(6, 182, 212, 0.3); padding: 1rem; border-radius: 0.5rem;">
                                        <h5 style="color: var(--accent-blue); margin-bottom: 0.5rem;">📊 计算过程</h5>
                                        <div id="calc-steps" style="font-size: 0.9rem; line-height: 2;">
                                            <div class="calc-step" style="opacity: 0.5;">1. 计算 w·x + b</div>
                                            <div class="calc-step" style="opacity: 0.5;">2. 应用符号函数</div>
                                            <div class="calc-step" style="opacity: 0.5;">3. 比较预测与真实标签</div>
                                            <div class="calc-step" style="opacity: 0.5;">4. 更新参数（如需要）</div>
                                        </div>
                                    </div>

                                    <!-- 数学公式 -->
                                    <div style="background: rgba(251, 191, 36, 0.05); border: 1px solid rgba(251, 191, 36, 0.3); padding: 1rem; border-radius: 0.5rem;">
                                        <h5 style="color: var(--accent-yellow); margin-bottom: 0.5rem;">✏️ 数学细节</h5>
                                        <div id="math-details" style="font-family: 'SF Mono', monospace; font-size: 0.85rem; line-height: 1.8;">
                                            等待计算...
                                        </div>
                                    </div>
                                </div>

                                <!-- 历史记录 -->
                                <div style="margin-top: 1rem; background: rgba(255, 255, 255, 0.05); border: 1px solid var(--border-color); border-radius: 0.5rem; padding: 1rem;">
                                    <h5 style="margin-bottom: 0.5rem;">📜 更新历史</h5>
                                    <div id="update-history" style="max-height: 200px; overflow-y: auto; font-size: 0.85rem; line-height: 1.6;">
                                        <div style="color: var(--text-secondary);">还没有更新记录...</div>
                                    </div>
                                </div>
                            </div>

                            <!-- 结果总结 -->
                            <div id="calculation-result" style="display: none; margin-top: 2rem; background: linear-gradient(135deg, rgba(34, 197, 94, 0.1), rgba(139, 92, 246, 0.1)); border: 2px solid rgba(34, 197, 94, 0.5); border-radius: 1rem; padding: 2rem;">
                                <h4 style="color: var(--accent-green); margin-bottom: 1rem;">🎉 收敛成功！</h4>
                                <div id="final-result"></div>
                            </div>
                        </div>

                        <!-- 关键洞察 -->
                        <div class="tip info mt-4">
                            <span class="tip-icon">💡</span>
                            <div class="tip-content">
                                <strong>关键洞察：</strong><br>
                                • 感知机不是随机更新，每次更新都有明确的数学依据<br>
                                • 更新的方向和大小都是为了纠正当前的错误<br>
                                • 只要数据线性可分，这个过程一定会收敛<br>
                                • 最终的决策边界取决于样本的遍历顺序
                            </div>
                        </div>
                    </div>
                </div>
            </div>

            <!-- 即时练习 -->
            <div class="instant-practice">
                <h3 style="color: var(--accent-green); margin-bottom: 1rem;">🎯 理解检查</h3>
                <div class="practice-question">
                    为什么感知机学习算法只在预测错误时更新参数？
                </div>
                <div class="practice-options">
                    <button class="practice-option" data-answer="a" tabindex="0">
                        A. 为了节省计算资源
                    </button>
                    <button class="practice-option" data-answer="b" tabindex="0">
                        B. 正确分类的样本不需要调整决策边界
                    </button>
                    <button class="practice-option" data-answer="c" tabindex="0">
                        C. 这是随机决定的
                    </button>
                    <button class="practice-option" data-answer="d" tabindex="0">
                        D. 为了让算法更复杂
                    </button>
                </div>
                <div class="practice-feedback" id="practice-feedback-3"></div>
            </div>
        </section>

        <!-- 代码实现部分 -->
        <section id="implementation" class="section-card">
            <h2 style="color: var(--accent-blue); margin-bottom: 1.5rem;">
                💻 代码实现：从理论到实践
                <span class="depth-indicator intermediate">进阶</span>
            </h2>

            <!-- 实现前的讨论 -->
            <div class="dialogue-container">
                <div class="dialogue-item">
                    <div class="dialogue-avatar student">💻</div>
                    <div class="dialogue-content">
                        <div class="dialogue-name">小陈</div>
                        <p>理论我都懂了，但怎么用代码实现呢？</p>
                    </div>
                </div>
                <div class="dialogue-item">
                    <div class="dialogue-avatar teacher">👨‍🏫</div>
                    <div class="dialogue-content">
                        <div class="dialogue-name">王教授</div>
                        <p>很简单！感知机的美妙之处就在于它的简洁。
                            我们先用NumPy实现基础版本，再看看现代框架的实现。</p>
                    </div>
                </div>
            </div>

            <div class="code-container">
                <div class="code-header">
                    <div class="code-header-left">
                        <button class="code-tab active" data-lang="numpy" tabindex="0">纯NumPy实现</button>
                        <button class="code-tab" data-lang="pytorch" tabindex="0">PyTorch实现</button>
                        <button class="code-tab" data-lang="visual" tabindex="0">可视化版本</button>
                    </div>
                    <div class="code-header-right">
                        <button class="code-action" onclick="copyCode()" tabindex="0">
                            <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                                <rect x="9" y="9" width="13" height="13" rx="2" ry="2"></rect>
                                <path d="M5 15H4a2 2 0 0 1-2-2V4a2 2 0 0 1 2-2h9a2 2 0 0 1 2 2v1"></path>
                            </svg>
                            复制
                        </button>
                        <button class="code-action" onclick="runCode()" tabindex="0">
                            ▶️ 运行
                        </button>
                    </div>
                </div>
                <div class="code-content" id="numpy-code">
<pre><code class="python">import numpy as np

class Perceptron:
    """感知机：深度学习的第一块积木

    这个实现包含了详细的注释和调试信息，
    帮助你理解每一步的计算过程。
    """

    def __init__(self, n_features, learning_rate=0.1, verbose=True):
        """初始化感知机

        Args:
            n_features: 输入特征的维度
            learning_rate: 学习率，控制每次更新的步长
            verbose: 是否打印训练过程信息
        """
        # 初始化权重为零向量
        self.w = np.zeros(n_features)
        self.b = 0.0
        self.lr = learning_rate
        self.verbose = verbose
        self.history = []  # 记录训练历史

    def predict(self, X):
        """预测函数：f(x) = sign(w·x + b)

        Args:
            X: 输入样本，可以是单个样本或批量样本

        Returns:
            预测的类别标签（+1 或 -1）
        """
        # 计算线性输出
        linear_output = np.dot(X, self.w) + self.b

        # 应用符号函数
        return np.sign(linear_output)

    def fit(self, X, y, epochs=100):
        """训练函数：实现感知机学习算法

        Args:
            X: 训练样本特征矩阵 [n_samples, n_features]
            y: 训练样本标签向量 [n_samples]
            epochs: 最大训练轮数

        Returns:
            self: 返回训练好的模型
        """
        n_samples = X.shape[0]

        for epoch in range(epochs):
            errors = 0
            epoch_updates = []

            # 遍历所有训练样本
            for idx in range(n_samples):
                xi, yi = X[idx], y[idx]

                # 预测当前样本
                yi_pred = self.predict(xi)

                # 检查是否分类错误
                if yi * yi_pred <= 0:  # 错误分类
                    # 更新权重和偏置
                    old_w = self.w.copy()
                    old_b = self.b

                    self.w += self.lr * yi * xi
                    self.b += self.lr * yi

                    errors += 1

                    # 记录更新信息
                    update_info = {
                        'sample': idx,
                        'x': xi,
                        'y_true': yi,
                        'y_pred': yi_pred,
                        'w_change': self.w - old_w,
                        'b_change': self.b - old_b
                    }
                    epoch_updates.append(update_info)

            # 记录本轮训练信息
            self.history.append({
                'epoch': epoch,
                'errors': errors,
                'accuracy': 1 - errors/n_samples,
                'updates': epoch_updates
            })

            if self.verbose and epoch % 10 == 0:
                print(f"Epoch {epoch}: 错误数 = {errors}, "
                      f"准确率 = {(1 - errors/n_samples)*100:.1f}%")

            # 如果没有错误，提前停止
            if errors == 0:
                if self.verbose:
                    print(f"✓ 完美收敛！仅用了 {epoch + 1} 轮迭代")
                break

        return self

    def score(self, X, y):
        """计算模型在给定数据集上的准确率"""
        predictions = self.predict(X)
        return np.mean(predictions == y)

    def decision_function(self, X):
        """返回决策函数的值（未经过sign函数）"""
        return np.dot(X, self.w) + self.b

    def get_hyperplane_params(self):
        """获取超平面参数，用于可视化"""
        return self.w, self.b


# ========== 使用示例 ==========
if __name__ == "__main__":
    # 创建一个简单的线性可分数据集
    np.random.seed(42)

    # 生成两类数据
    n_samples_per_class = 50

    # 第一类：中心在 (2, 2)
    X_class1 = np.random.randn(n_samples_per_class, 2) + [2, 2]
    y_class1 = np.ones(n_samples_per_class)

    # 第二类：中心在 (-2, -2)
    X_class2 = np.random.randn(n_samples_per_class, 2) + [-2, -2]
    y_class2 = -np.ones(n_samples_per_class)

    # 合并数据
    X = np.vstack([X_class1, X_class2])
    y = np.hstack([y_class1, y_class2])

    # 训练感知机
    print("="*50)
    print("感知机训练演示")
    print("="*50)

    model = Perceptron(n_features=2, learning_rate=0.1)
    model.fit(X, y, epochs=100)

    print(f"\n最终参数：")
    print(f"权重 w = {model.w}")
    print(f"偏置 b = {model.b:.4f}")
    print(f"训练准确率: {model.score(X, y)*100:.1f}%")

    # 测试一些新样本
    print("\n测试新样本：")
    test_points = np.array([[3, 3], [-3, -3], [0, 0]])
    for point in test_points:
        prediction = model.predict(point)
        confidence = model.decision_function(point)
        print(f"点 {point} -> 预测: {int(prediction)}, "
              f"决策值: {confidence:.3f}")</code></pre>
                </div>
                <div class="code-content" id="pytorch-code" style="display: none;">
<pre><code class="python">import torch
import torch.nn as nn
import torch.optim as optim
import numpy as np

class PerceptronPyTorch(nn.Module):
    """使用PyTorch实现的感知机

    展示了如何用现代深度学习框架实现经典算法
    """

    def __init__(self, n_features):
        super().__init__()
        # nn.Linear 包含了权重和偏置
        self.linear = nn.Linear(n_features, 1)

        # 初始化参数为零（与NumPy版本一致）
        nn.init.zeros_(self.linear.weight)
        nn.init.zeros_(self.linear.bias)

    def forward(self, x):
        """前向传播"""
        # 线性变换
        linear_output = self.linear(x)
        # 应用符号函数
        return torch.sign(linear_output)

    def predict(self, x):
        """预测函数（与sklearn接口兼容）"""
        with torch.no_grad():
            x_tensor = torch.FloatTensor(x)
            return self.forward(x_tensor).squeeze().numpy()


class PerceptronTrainer:
    """感知机训练器

    实现了感知机特定的损失函数和训练逻辑
    """

    def __init__(self, model, learning_rate=0.1):
        self.model = model
        self.lr = learning_rate

    def perceptron_loss(self, output, target):
        """感知机损失函数

        Loss = max(0, -y * f(x))
        只有错误分类的样本产生损失
        """
        return torch.mean(torch.clamp(-target * output, min=0))

    def train_epoch(self, X, y):
        """训练一个epoch"""
        # 随机打乱数据
        indices = torch.randperm(len(X))
        errors = 0

        for idx in indices:
            x_i = X[idx:idx+1]  # 保持批次维度
            y_i = y[idx:idx+1]

            # 前向传播
            output = self.model.linear(x_i)

            # 检查是否分类错误
            if y_i * output <= 0:
                errors += 1

                # 手动实现感知机更新规则
                with torch.no_grad():
                    # w = w + lr * y * x
                    self.model.linear.weight += self.lr * y_i * x_i
                    # b = b + lr * y
                    self.model.linear.bias += self.lr * y_i

        return errors

    def fit(self, X, y, epochs=100, verbose=True):
        """训练模型"""
        X = torch.FloatTensor(X)
        y = torch.FloatTensor(y).reshape(-1, 1)
        n_samples = len(X)

        for epoch in range(epochs):
            errors = self.train_epoch(X, y)
            accuracy = 1 - errors / n_samples

            if verbose and epoch % 10 == 0:
                print(f"Epoch {epoch}: 错误数 = {errors}, "
                      f"准确率 = {accuracy*100:.1f}%")

            if errors == 0:
                if verbose:
                    print(f"✓ 完美收敛！用时 {epoch + 1} 轮")
                break

    def score(self, X, y):
        """计算准确率"""
        X = torch.FloatTensor(X)
        y = torch.FloatTensor(y)

        with torch.no_grad():
            predictions = torch.sign(self.model.linear(X)).squeeze()
            return (predictions == y).float().mean().item()


# ========== 高级功能：批量训练 ==========
class BatchPerceptron(nn.Module):
    """支持批量更新的感知机"""

    def __init__(self, n_features):
        super().__init__()
        self.linear = nn.Linear(n_features, 1)
        nn.init.zeros_(self.linear.weight)
        nn.init.zeros_(self.linear.bias)

    def forward(self, x):
        return self.linear(x)

    def fit(self, X, y, epochs=100, batch_size=32, lr=0.1):
        """使用小批量梯度下降训练"""
        X = torch.FloatTensor(X)
        y = torch.FloatTensor(y).reshape(-1, 1)

        dataset = torch.utils.data.TensorDataset(X, y)
        dataloader = torch.utils.data.DataLoader(
            dataset, batch_size=batch_size, shuffle=True
        )

        optimizer = optim.SGD(self.parameters(), lr=lr)

        for epoch in range(epochs):
            total_loss = 0
            for batch_X, batch_y in dataloader:
                # 前向传播
                output = self.forward(batch_X)

                # 计算损失（感知机损失）
                loss = torch.mean(torch.clamp(-batch_y * output, min=0))

                # 反向传播
                optimizer.zero_grad()
                loss.backward()
                optimizer.step()

                total_loss += loss.item()

            if epoch % 10 == 0:
                print(f"Epoch {epoch}: Loss = {total_loss:.4f}")

            # 检查是否完全正确分类
            with torch.no_grad():
                all_output = self.forward(X)
                errors = (y * all_output <= 0).sum().item()
                if errors == 0:
                    print(f"✓ 收敛！用时 {epoch + 1} 轮")
                    break


# ========== 使用示例 ==========
if __name__ == "__main__":
    # 使用与NumPy版本相同的数据
    np.random.seed(42)
    n_samples_per_class = 50

    X_class1 = np.random.randn(n_samples_per_class, 2) + [2, 2]
    y_class1 = np.ones(n_samples_per_class)

    X_class2 = np.random.randn(n_samples_per_class, 2) + [-2, -2]
    y_class2 = -np.ones(n_samples_per_class)

    X = np.vstack([X_class1, X_class2])
    y = np.hstack([y_class1, y_class2])

    print("="*50)
    print("PyTorch 感知机训练演示")
    print("="*50)

    # 训练基础版本
    model = PerceptronPyTorch(n_features=2)
    trainer = PerceptronTrainer(model, learning_rate=0.1)
    trainer.fit(X, y, epochs=100)

    print(f"\n最终参数：")
    print(f"权重 w = {model.linear.weight.data.numpy()}")
    print(f"偏置 b = {model.linear.bias.data.item():.4f}")
    print(f"训练准确率: {trainer.score(X, y)*100:.1f}%")

    print("\n" + "="*50)
    print("批量训练版本")
    print("="*50)

    batch_model = BatchPerceptron(n_features=2)
    batch_model.fit(X, y, epochs=100, batch_size=16)</code></pre>
                </div>
                <div class="code-content" id="visual-code" style="display: none;">
<pre><code class="python">import numpy as np
import matplotlib.pyplot as plt
from matplotlib.animation import FuncAnimation
from IPython.display import HTML

class VisualPerceptron:
    """可视化的感知机实现

    实时展示训练过程中决策边界的变化
    """

    def __init__(self, n_features=2, learning_rate=0.1):
        self.w = np.zeros(n_features)
        self.b = 0.0
        self.lr = learning_rate
        self.history = []

    def predict(self, X):
        return np.sign(np.dot(X, self.w) + self.b)

    def fit_with_visualization(self, X, y, epochs=50):
        """带可视化的训练过程"""
        n_samples = X.shape[0]

        # 设置图形
        fig, (ax1, ax2) = plt.subplots(1, 2, figsize=(15, 6))

        # 左图：数据和决策边界
        ax1.set_title('决策边界演化', fontsize=14)
        ax1.set_xlabel('特征 1')
        ax1.set_ylabel('特征 2')

        # 右图：损失曲线
        ax2.set_title('训练进度', fontsize=14)
        ax2.set_xlabel('迭代次数')
        ax2.set_ylabel('错误数')

        # 绘制数据点
        colors = ['red' if yi == -1 else 'blue' for yi in y]
        scatter = ax1.scatter(X[:, 0], X[:, 1], c=colors,
                             s=100, alpha=0.6, edgecolors='black')

        # 初始化决策边界线
        x_min, x_max = X[:, 0].min() - 1, X[:, 0].max() + 1
        x_line = np.linspace(x_min, x_max, 100)

        line, = ax1.plot([], [], 'g-', linewidth=2, label='决策边界')
        ax1.set_xlim(x_min, x_max)
        ax1.set_ylim(X[:, 1].min() - 1, X[:, 1].max() + 1)
        ax1.legend()
        ax1.grid(True, alpha=0.3)

        # 初始化误差曲线
        error_line, = ax2.plot([], [], 'r-', linewidth=2)
        ax2.set_xlim(0, epochs)
        ax2.set_ylim(0, n_samples)
        ax2.grid(True, alpha=0.3)

        # 训练历史
        iteration_errors = []
        iteration_count = 0

        # 动画更新函数
        def update(frame):
            nonlocal iteration_count

            if frame < epochs:
                errors = 0

                </div>
                <div class="code-output" id="code-output">
                    <strong>运行结果：</strong>
                    <pre>感知机训练完成！
最终权重: [0.8, 0.6]
最终偏置: -1.2
训练准确率: 100%</pre>
                </div>
            </div>

            <!-- 代码要点总结 -->
            <div class="tip success mt-3">
                <span class="tip-icon">✅</span>
                <div class="tip-content">
                    <strong>实现要点：</strong><br>
                    • 感知机的核心代码不超过50行<br>
                    • 关键在于正确实现更新规则<br>
                    • 注意处理数据的维度和类型<br>
                    • 可视化能帮助理解算法行为
                </div>
            </div>
        </section>

        <!-- 实战演练：鸢尾花分类 -->
        <section id="experiment" class="section-card">
            <h2 style="color: var(--accent-yellow); margin-bottom: 1.5rem;">
                🌺 实战演练：鸢尾花分类
                <span class="depth-indicator intermediate">进阶</span>
            </h2>

            <!-- 问题介绍 -->
            <div class="story-card">
                <h3>经典数据集：Fisher的鸢尾花</h3>
                <p>1936年，统计学家Ronald Fisher收集了150朵鸢尾花的数据，
                    成为机器学习领域最经典的数据集之一。</p>

                <div style="display: grid; grid-template-columns: repeat(3, 1fr); gap: 1rem; margin-top: 1.5rem;">
                    <div style="text-align: center; padding: 1rem; background: rgba(239, 68, 68, 0.1); border-radius: 0.5rem;">
                        <div style="font-size: 3rem;">🌺</div>
                        <strong>Setosa</strong><br>
                        山鸢尾
                    </div>
                    <div style="text-align: center; padding: 1rem; background: rgba(34, 197, 94, 0.1); border-radius: 0.5rem;">
                        <div style="font-size: 3rem;">🌸</div>
                        <strong>Versicolor</strong><br>
                        变色鸢尾
                    </div>
                    <div style="text-align: center; padding: 1rem; background: rgba(6, 182, 212, 0.1); border-radius: 0.5rem;">
                        <div style="font-size: 3rem;">🌼</div>
                        <strong>Virginica</strong><br>
                        维吉尼亚鸢尾
                    </div>
                </div>
            </div>

            <!-- 数据探索 -->
            <div class="interactive-demo mt-4">
                <h3 style="color: var(--accent-purple); margin-bottom: 1.5rem;">📊 数据探索与可视化</h3>

                <div class="demo-controls">
                    <div class="control-group">
                        <label>X轴特征</label>
                        <select id="x-feature" class="form-select">
                            <option value="0">花萼长度</option>
                            <option value="1">花萼宽度</option>
                            <option value="2" selected>花瓣长度</option>
                            <option value="3">花瓣宽度</option>
                        </select>
                    </div>
                    <div class="control-group">
                        <label>Y轴特征</label>
                        <select id="y-feature" class="form-select">
                            <option value="0">花萼长度</option>
                            <option value="1">花萼宽度</option>
                            <option value="2">花瓣长度</option>
                            <option value="3" selected>花瓣宽度</option>
                        </select>
                    </div>
                    <div class="control-group">
                        <label>选择两个类别</label>
                        <div>
                            <label><input type="checkbox" id="class-0" checked> Setosa</label>
                            <label><input type="checkbox" id="class-1" checked> Versicolor</label>
                            <label><input type="checkbox" id="class-2"> Virginica</label>
                        </div>
                    </div>
                    <button class="btn btn-primary" onclick="trainIrisPerceptron()" tabindex="0">
                        🚀 训练感知机
                    </button>
                </div>

                <canvas id="iris-canvas" width="800" height="500"></canvas>

                <div class="mt-3" id="iris-results" style="display: none;">
                    <div style="background: rgba(34, 197, 94, 0.1); padding: 1rem; border-radius: 0.5rem;">
                        <h4 style="color: var(--accent-green);">训练结果</h4>
                        <div id="iris-stats"></div>
                    </div>
                </div>
            </div>

            <!-- 实验代码 -->
            <div class="code-container mt-4">
                <div class="code-header">
                    <div class="code-header-left">
                        <span style="color: var(--text-secondary);">完整的鸢尾花分类实验</span>
                    </div>
                </div>
                <div class="code-content">
<pre><code class="python">from sklearn import datasets
from sklearn.model_selection import train_test_split
from sklearn.preprocessing import StandardScaler
import numpy as np
import matplotlib.pyplot as plt

# 加载鸢尾花数据集
iris = datasets.load_iris()
X = iris.data
y = iris.target

# 为了演示感知机，我们只选择两个类别
# 选择 Setosa (0) 和 Versicolor (1)
mask = y != 2  # 排除 Virginica
X_binary = X[mask]
y_binary = y[mask]
y_binary = np.where(y_binary == 0, -1, 1)  # 转换为 -1 和 +1

# 只使用两个特征进行可视化
X_2d = X_binary[:, [2, 3]]  # 花瓣长度和宽度

# 数据标准化
scaler = StandardScaler()
X_scaled = scaler.fit_transform(X_2d)

# 划分训练集和测试集
X_train, X_test, y_train, y_test = train_test_split(
    X_scaled, y_binary, test_size=0.3, random_state=42
)

# 训练感知机
model = Perceptron(n_features=2, learning_rate=0.01)
model.fit(X_train, y_train, epochs=100)

# 评估性能
train_acc = model.score(X_train, y_train)
test_acc = model.score(X_test, y_test)

print(f"训练集准确率: {train_acc*100:.1f}%")
print(f"测试集准确率: {test_acc*100:.1f}%")

# 可视化结果
plt.figure(figsize=(12, 5))

# 子图1：训练数据和决策边界
plt.subplot(1, 2, 1)
plot_decision_boundary(model, X_train, y_train,
                      title='训练集上的决策边界')

# 子图2：测试数据和决策边界
plt.subplot(1, 2, 2)
plot_decision_boundary(model, X_test, y_test,
                      title='测试集上的决策边界')

plt.tight_layout()
plt.show()

# 尝试三分类问题（会失败！）
print("\n尝试三分类问题...")
X_multi = X[:, [2, 3]]
y_multi = y

# 感知机无法直接处理多分类
# 这是它的根本局限之一</code></pre>
                </div>
            </div>

            <!-- 关键发现 -->
            <div class="tip info mt-3">
                <span class="tip-icon">💡</span>
                <div class="tip-content">
                    <strong>关键发现：</strong><br>
                    • Setosa 类与其他两类是线性可分的<br>
                    • Versicolor 和 Virginica 有重叠，不完全线性可分<br>
                    • 感知机在线性可分数据上表现完美<br>
                    • 但无法处理非线性可分的情况
                </div>
            </div>
        </section>

        <!-- XOR问题：致命缺陷 -->
        <section id="limitation" class="section-card">
            <h2 style="color: var(--accent-red); margin-bottom: 1.5rem;">
                💥 致命缺陷：XOR问题
                <span class="depth-indicator advanced">深入</span>
            </h2>

            <!-- 问题引入 -->
            <div class="dialogue-container">
                <div class="dialogue-item">
                    <div class="dialogue-avatar student">😤</div>
                    <div class="dialogue-content">
                        <div class="dialogue-name">小陈（沮丧）</div>
                        <p>教授，我用感知机做异或（XOR）分类，训练了一晚上都不收敛！</p>
                    </div>
                </div>
                <div class="dialogue-item">
                    <div class="dialogue-avatar teacher">👨‍🏫</div>
                    <div class="dialogue-content">
                        <div class="dialogue-name">王教授</div>
                        <p>这不是你的问题。1969年，Minsky和Papert在《Perceptrons》一书中
                            证明了感知机无法解决XOR问题。这个发现直接导致了AI的第一个冬天...</p>
                    </div>
                </div>
            </div>

            <!-- XOR问题可视化 -->
            <div class="interactive-demo mt-4">
                <h3 style="color: var(--accent-purple); margin-bottom: 1.5rem;">🎮 XOR问题演示</h3>

                <div style="text-align: center; margin-bottom: 2rem;">
                    <h4>XOR（异或）逻辑</h4>
                    <table style="margin: 0 auto; background: rgba(0,0,0,0.2); border-radius: 0.5rem;">
                        <thead>
                        <tr>
                            <th style="padding: 1rem;">输入1</th>
                            <th style="padding: 1rem;">输入2</th>
                            <th style="padding: 1rem;">输出</th>
                        </tr>
                        </thead>
                        <tbody>
                        <tr>
                            <td style="padding: 1rem;">0</td>
                            <td style="padding: 1rem;">0</td>
                            <td style="padding: 1rem; color: var(--accent-red);">0</td>
                        </tr>
                        <tr>
                            <td style="padding: 1rem;">0</td>
                            <td style="padding: 1rem;">1</td>
                            <td style="padding: 1rem; color: var(--accent-green);">1</td>
                        </tr>
                        <tr>
                            <td style="padding: 1rem;">1</td>
                            <td style="padding: 1rem;">0</td>
                            <td style="padding: 1rem; color: var(--accent-green);">1</td>
                        </tr>
                        <tr>
                            <td style="padding: 1rem;">1</td>
                            <td style="padding: 1rem;">1</td>
                            <td style="padding: 1rem; color: var(--accent-red);">0</td>
                        </tr>
                        </tbody>
                    </table>
                </div>

                <div class="demo-controls">
                    <button class="btn btn-primary" onclick="tryXORPerceptron()" tabindex="0">
                        🔄 尝试训练（会失败）
                    </button>
                    <button class="btn btn-secondary" onclick="showXORSolution()" tabindex="0">
                        💡 查看解决方案
                    </button>
                </div>

                <canvas id="xor-canvas" width="800" height="400"></canvas>

                <div class="mt-3" id="xor-explanation" style="display: none;">
                    <div class="tip error">
                        <span class="tip-icon">❌</span>
                        <div class="tip-content">
                            <strong>为什么失败？</strong><br>
                            XOR的两个类别无法用一条直线分开！<br>
                            (0,0) 和 (1,1) 属于同一类，但 (0,1) 和 (1,0) 属于另一类。<br>
                            任何直线都无法正确分割这四个点。
                        </div>
                    </div>
                </div>
            </div>

            <!-- 数学证明 -->
            <div class="collapsible mt-4 advanced-content">
                <div class="collapsible-header" tabindex="0">
                    <div class="collapsible-title">
                        <span>🔬</span>
                        <span>XOR不可分的数学证明</span>
                        <span class="depth-indicator advanced">深入</span>
                    </div>
                    <svg class="collapsible-icon" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                        <polyline points="6 9 12 15 18 9"></polyline>
                    </svg>
                </div>
                <div class="collapsible-content">
                    <div class="collapsible-inner">
                        <div class="math-derivation">
                            <h4>反证法</h4>

                            <div class="math-step" data-step="1">
                                <strong>假设存在线性分类器</strong>
                                <p>假设存在权重 w₁, w₂ 和偏置 b，使得：</p>
                                <div style="text-align: center; margin: 1rem 0;">
                                    f(x₁, x₂) = sign(w₁x₁ + w₂x₂ + b)
                                </div>
                            </div>

                            <div class="math-step" data-step="2">
                                <strong>根据XOR定义，必须满足</strong>
                                <ul style="line-height: 2;">
                                    <li>f(0,0) = -1 → b < 0</li>
                                    <li>f(0,1) = +1 → w₂ + b > 0</li>
                                    <li>f(1,0) = +1 → w₁ + b > 0</li>
                                    <li>f(1,1) = -1 → w₁ + w₂ + b < 0</li>
                                </ul>
                            </div>

                            <div class="math-step" data-step="3">
                                <strong>导出矛盾</strong>
                                <p>从条件2和3：w₁ + b > 0 且 w₂ + b > 0</p>
                                <p>相加得：(w₁ + b) + (w₂ + b) > 0</p>
                                <p>即：w₁ + w₂ + 2b > 0</p>
                                <p>但从条件1：b < 0，所以：w₁ + w₂ + b > w₁ + w₂ + 2b > 0</p>
                                <p>这与条件4矛盾！</p>
                                <div class="math-explanation">
                                    因此，不存在满足所有条件的线性分类器
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
            </div>

            <!-- 解决方案预览 -->
            <div class="tip success mt-4">
                <span class="tip-icon">✅</span>
                <div class="tip-content">
                    <strong>解决方案：多层网络</strong><br>
                    • 单个感知机无法解决XOR<br>
                    • 但两层感知机可以！<br>
                    • 这就是深度学习中"深度"的意义<br>
                    • 下一章我们将学习多层感知机（MLP）
                </div>
            </div>
        </section>

        <!-- 历史回顾 -->
        <section id="history" class="section-card">
            <h2 style="color: var(--accent-yellow); margin-bottom: 1.5rem;">
                📚 历史回顾：AI的第一个冬天
                <span class="depth-indicator beginner">初学者</span>
            </h2>

            <!-- 时间线 -->
            <div style="position: relative; padding: 2rem 0;">
                <div style="position: absolute; left: 50%; top: 0; bottom: 0; width: 2px; background: var(--accent-purple);"></div>

                <!-- 1957年 -->
                <div style="display: flex; align-items: center; margin-bottom: 3rem;">
                    <div style="flex: 1; text-align: right; padding-right: 2rem;">
                        <h4 style="color: var(--accent-green);">1957年：希望的曙光</h4>
                        <p>Frank Rosenblatt 发明感知机</p>
                        <p style="font-style: italic; color: var(--text-secondary);">
                            "感知机最终将能够学习、做决定和翻译语言"
                        </p>
                    </div>
                    <div style="width: 20px; height: 20px; background: var(--accent-green); border-radius: 50%; position: relative; z-index: 1;"></div>
                    <div style="flex: 1; padding-left: 2rem;">
                        <div style="background: rgba(34, 197, 94, 0.1); padding: 1rem; border-radius: 0.5rem;">
                            🎉 媒体热烈报道，认为人工智能即将实现
                        </div>
                    </div>
                </div>

                <!-- 1960年代初 -->
                <div style="display: flex; align-items: center; margin-bottom: 3rem;">
                    <div style="flex: 1; text-align: right; padding-right: 2rem;">
                        <div style="background: rgba(251, 191, 36, 0.1); padding: 1rem; border-radius: 0.5rem;">
                            🚀 大量资金涌入，期望极高
                        </div>
                    </div>
                    <div style="width: 20px; height: 20px; background: var(--accent-yellow); border-radius: 50%; position: relative; z-index: 1;"></div>
                    <div style="flex: 1; padding-left: 2rem;">
                        <h4 style="color: var(--accent-yellow);">1960s：黄金时代</h4>
                        <p>感知机研究如火如荼</p>
                    </div>
                </div>

                <!-- 1969年 -->
                <div style="display: flex; align-items: center; margin-bottom: 3rem;">
                    <div style="flex: 1; text-align: right; padding-right: 2rem;">
                        <h4 style="color: var(--accent-red);">1969年：致命一击</h4>
                        <p>Minsky & Papert 出版《Perceptrons》</p>
                        <p style="font-style: italic; color: var(--text-secondary);">
                            "感知机连XOR都解决不了"
                        </p>
                    </div>
                    <div style="width: 20px; height: 20px; background: var(--accent-red); border-radius: 50%; position: relative; z-index: 1;"></div>
                    <div style="flex: 1; padding-left: 2rem;">
                        <div style="background: rgba(239, 68, 68, 0.1); padding: 1rem; border-radius: 0.5rem;">
                            💔 研究资金断崖式下跌，人才流失
                        </div>
                    </div>
                </div>

                <!-- 1970-1980年代 -->
                <div style="display: flex; align-items: center;">
                    <div style="flex: 1; text-align: right; padding-right: 2rem;">
                        <div style="background: rgba(15, 23, 42, 0.5); padding: 1rem; border-radius: 0.5rem;">
                            ❄️ AI冬天：研究停滞近20年
                        </div>
                    </div>
                    <div style="width: 20px; height: 20px; background: var(--text-muted); border-radius: 50%; position: relative; z-index: 1;"></div>
                    <div style="flex: 1; padding-left: 2rem;">
                        <h4 style="color: var(--text-muted);">1970s-80s：漫长的冬天</h4>
                        <p>神经网络研究几乎停止</p>
                    </div>
                </div>
            </div>

            <!-- 历史教训 -->
            <div class="common-mistakes">
                <h3 style="color: var(--accent-red); margin-bottom: 1rem;">🎓 历史的教训</h3>

                <div class="mistake-item">
                    <div class="mistake-icon">📍</div>
                    <div class="mistake-content">
                        <h4>过度承诺</h4>
                        <p>Rosenblatt对感知机能力的预测过于乐观，导致期望与现实的巨大落差。</p>
                    </div>
                </div>

                <div class="mistake-item">
                    <div class="mistake-icon">📍</div>
                    <div class="mistake-content">
                        <h4>理论局限</h4>
                        <p>单层感知机的表达能力确实有限，但Minsky的批评也过于悲观。</p>
                    </div>
                </div>

                <div class="mistake-item">
                    <div class="mistake-icon">📍</div>
                    <div class="mistake-content">
                        <h4>错失的机会</h4>
                        <p>其实早在1960年代就有人提出多层网络，但被忽视了20年！</p>
                    </div>
                </div>
            </div>

            <!-- 复兴的种子 -->
            <div class="tip info mt-4">
                <span class="tip-icon">🌱</span>
                <div class="tip-content">
                    <strong>复兴的种子：</strong><br>
                    • 1974年：Werbos 发明反向传播（博士论文，无人问津）<br>
                    • 1986年：Rumelhart 等人重新发现反向传播<br>
                    • 1989年：LeCun 用CNN识别手写数字<br>
                    • 深度学习的春天终于到来...
                </div>
            </div>
        </section>

        <!-- 突破思考 -->
        <section id="breakthrough" class="section-card">
            <h2 style="color: var(--accent-purple); margin-bottom: 1.5rem;">
                🚀 突破思考：深度的必要性
                <span class="depth-indicator intermediate">进阶</span>
            </h2>

            <!-- 思维实验 -->
            <div class="dialogue-container">
                <div class="dialogue-item">
                    <div class="dialogue-avatar student">💡</div>
                    <div class="dialogue-content">
                        <div class="dialogue-name">小陈（灵光一现）</div>
                        <p>等等！如果我们把多个感知机组合起来会怎样？
                            就像搭积木一样！</p>
                    </div>
                </div>
                <div class="dialogue-item">
                    <div class="dialogue-avatar teacher">👨‍🏫</div>
                    <div class="dialogue-content">
                        <div class="dialogue-name">王教授</div>
                        <p>恭喜你！你刚刚重新发现了多层感知机的思想。
                            这正是突破感知机局限的关键...</p>
                    </div>
                </div>
            </div>

            <!-- 多层网络演示 -->
            <div class="interactive-demo mt-4">
                <h3 style="color: var(--accent-blue); margin-bottom: 1.5rem;">🏗️ 从单层到多层</h3>

                <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 2rem;">
                    <!-- 单层限制 -->
                    <div style="text-align: center;">
                        <h4 style="color: var(--accent-red);">单层感知机</h4>
                        <div style="background: rgba(239, 68, 68, 0.1); padding: 1.5rem; border-radius: 0.5rem;">
                            <p><strong>表达能力：</strong>线性函数</p>
                            <p><strong>决策边界：</strong>直线/超平面</p>
                            <p><strong>可解决：</strong>线性可分问题</p>
                            <p><strong>无法解决：</strong>XOR、圆形边界等</p>
                        </div>
                    </div>

                    <!-- 多层能力 -->
                    <div style="text-align: center;">
                        <h4 style="color: var(--accent-green);">多层网络</h4>
                        <div style="background: rgba(34, 197, 94, 0.1); padding: 1.5rem; border-radius: 0.5rem;">
                            <p><strong>表达能力：</strong>非线性函数</p>
                            <p><strong>决策边界：</strong>任意复杂形状</p>
                            <p><strong>可解决：</strong>几乎所有分类问题</p>
                            <p><strong>通用近似定理：</strong>理论保证</p>
                        </div>
                    </div>
                </div>

                <!-- XOR的多层解决方案 -->
                <div class="mt-4">
                    <h4 style="text-align: center; color: var(--accent-purple);">两层网络解决XOR</h4>
                    <canvas id="mlp-xor-canvas" width="800" height="400"></canvas>
                </div>
            </div>

            <!-- 深度的意义 -->
            <div class="math-derivation mt-4">
                <h3>为什么需要"深度"？</h3>

                <div class="math-step" data-step="1">
                    <strong>表达效率</strong>
                    <p>深层网络可以用指数级更少的神经元表达同样的函数</p>
                    <div class="math-explanation">
                        例如：n位奇偶校验<br>
                        • 单隐层需要 2^n 个神经元<br>
                        • 深层只需要 O(n) 个神经元
                    </div>
                </div>

                <div class="math-step" data-step="2">
                    <strong>特征层次</strong>
                    <p>每一层学习不同抽象级别的特征</p>
                    <div class="math-explanation">
                        图像识别中：<br>
                        • 第1层：边缘、角点<br>
                        • 第2层：简单形状<br>
                        • 第3层：复杂模式<br>
                        • 更深层：语义概念
                    </div>
                </div>

                <div class="math-step" data-step="3">
                    <strong>组合性原理</strong>
                    <p>复杂概念由简单概念组合而成</p>
                    <div class="math-explanation">
                        就像语言：字母→单词→句子→段落→文章
                    </div>
                </div>
            </div>

            <!-- 展望未来 -->
            <div class="learning-path">
                <h3 style="color: var(--accent-purple); margin-bottom: 1.5rem;">🔮 展望：深度学习之路</h3>

                <div class="path-item">
                    <div class="path-icon">📐</div>
                    <div class="path-content">
                        <h4>下一步：反向传播</h4>
                        <p>如何训练多层网络？梯度下降的链式法则</p>
                    </div>
                </div>
                <div class="path-item">
                    <div class="path-icon">🧮</div>
                    <div class="path-content">
                        <h4>激活函数：非线性的魔法</h4>
                        <p>ReLU、Sigmoid、Tanh...为什么需要它们？</p>
                    </div>
                </div>
                <div class="path-item">
                    <div class="path-icon">🏗️</div>
                    <div class="path-content">
                        <h4>现代架构：CNN、RNN、Transformer</h4>
                        <p>从全连接到专门设计的网络结构</p>
                    </div>
                </div>
            </div>
        </section>

        <!-- 总结 -->
        <section id="summary" class="section-card">
            <h2 style="color: var(--accent-green); margin-bottom: 1.5rem;">
                📝 总结：承前启后
            </h2>

            <!-- 知识总结 -->
            <div class="concept-grid">
                <div class="concept-card what">
                    <h3 style="color: var(--accent-green);">✓ 我们学到了什么</h3>
                    <ul style="line-height: 1.8;">
                        <li>感知机的数学模型和几何意义</li>
                        <li>感知机学习算法的原理</li>
                        <li>线性可分性的重要性</li>
                        <li>感知机的实现和应用</li>
                    </ul>
                </div>
                <div class="concept-card why">
                    <h3 style="color: var(--accent-red);">✓ 为什么重要</h3>
                    <ul style="line-height: 1.8;">
                        <li>深度学习的历史起点</li>
                        <li>理解线性分类的本质</li>
                        <li>认识单层网络的局限</li>
                        <li>体会"深度"的必要性</li>
                    </ul>
                </div>
                <div class="concept-card how">
                    <h3 style="color: var(--accent-blue);">✓ 如何应用</h3>
                    <ul style="line-height: 1.8;">
                        <li>二分类问题的基准方法</li>
                        <li>特征工程的重要性</li>
                        <li>在线学习的简单实现</li>
                        <li>理解更复杂模型的基础</li>
                    </ul>
                </div>
                <div class="concept-card pitfall">
                    <h3 style="color: var(--accent-yellow);">✓ 需要注意</h3>
                    <ul style="line-height: 1.8;">
                        <li>仅适用于线性可分数据</li>
                        <li>对特征尺度敏感</li>
                        <li>无法直接处理多分类</li>
                        <li>不输出概率值</li>
                    </ul>
                </div>
            </div>

            <!-- 关键要点 -->
            <div class="tip success mt-4">
                <span class="tip-icon">🎯</span>
                <div class="tip-content">
                    <strong>三个关键要点：</strong><br>
                    1. <strong>简单而优雅：</strong>感知机用最简单的模型实现了机器学习的核心思想<br>
                    2. <strong>局限但重要：</strong>虽有XOR之限，但奠定了神经网络的基础<br>
                    3. <strong>深度的种子：</strong>多层网络的需求推动了深度学习的诞生
                </div>
            </div>

            <!-- 思考题 -->
            <div class="instant-practice mt-4">
                <h3 style="color: var(--accent-green); margin-bottom: 1rem;">🤔 深度思考</h3>
                <div class="practice-question">
                    如果你是1970年的研究者，知道了感知机的局限，你会如何尝试改进？
                </div>
                <div style="background: rgba(139, 92, 246, 0.1); padding: 1.5rem; border-radius: 0.5rem; margin-top: 1rem;">
                    <p><strong>提示：</strong></p>
                    <ul style="line-height: 1.8;">
                        <li>能否组合多个感知机？</li>
                        <li>如何引入非线性？</li>
                        <li>怎样训练多层结构？</li>
                        <li>计算资源的限制如何克服？</li>
                    </ul>
                </div>
            </div>

            <!-- 下一章预告 -->
            <div style="background: var(--primary-gradient); padding: 2rem; border-radius: 1rem; margin-top: 2rem; color: white; text-align: center;">
                <h3 style="margin-bottom: 1rem;">🎬 下一章预告</h3>
                <h2 style="font-size: 2rem; margin-bottom: 1rem;">反向传播：深度学习的引擎</h2>
                <p style="font-size: 1.1rem; opacity: 0.9;">
                    突破感知机的局限，开启深度网络训练的大门。<br>
                    我们将学习如何让误差信号在网络中反向流动，实现端到端的学习。
                </p>
                <button class="btn" style="background: white; color: var(--accent-purple); margin-top: 1.5rem;" tabindex="0">
                    继续学习 →
                </button>
            </div>
        </section>

        <!-- 学习反馈 -->
        <section class="section-card">
            <h2 style="color: var(--accent-purple); margin-bottom: 1.5rem;">💬 学习反馈</h2>
            <div style="text-align: center;">
                <p style="font-size: 1.1rem; margin-bottom: 1.5rem;">这一章的内容对你有帮助吗？</p>
                <div style="display: flex; gap: 1rem; justify-content: center;">
                    <button class="btn btn-secondary" onclick="submitFeedback('helpful')" tabindex="0">
                        👍 很有帮助
                    </button>
                    <button class="btn btn-secondary" onclick="submitFeedback('ok')" tabindex="0">
                        😐 还可以
                    </button>
                    <button class="btn btn-secondary" onclick="submitFeedback('confusing')" tabindex="0">
                        😕 有点困惑
                    </button>
                </div>
                <div id="feedback-response" style="margin-top: 1rem; display: none;">
                    <p style="color: var(--accent-green);">感谢你的反馈！我们会继续改进。</p>
                </div>
            </div>
        </section>
    </div>
</main>

<!-- JavaScript代码 -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.9/katex.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.9/contrib/auto-render.min.js"></script>
<script>

    class PerceptronMathVisualizer {
        constructor() {
            this.canvas = document.getElementById('perceptron-math-viz');
            this.ctx = this.canvas.getContext('2d');
            this.width = this.canvas.width;
            this.height = this.canvas.height;

            // 数据点
            this.points = [
                {x: [3, 3], y: 1, label: 'A', color: '#3b82f6'},
                {x: [4, 3], y: 1, label: 'B', color: '#3b82f6'},
                {x: [1, 1], y: -1, label: 'C', color: '#ef4444'},
                {x: [2, 1], y: -1, label: 'D', color: '#ef4444'}
            ];

            // 感知机参数
            this.w = [0, 0];
            this.b = 0;
            this.lr = 1;

            // 状态
            this.epoch = 0;
            this.sampleIdx = -1;
            this.isRunning = false;
            this.history = [];
            this.updateCount = 0;

            // 绘制初始状态
            this.draw();

            // 绑定速度控制
            const speedSlider = document.getElementById('calc-speed');
            speedSlider.addEventListener('input', (e) => {
                document.getElementById('calc-speed-value').textContent = (e.target.value / 1000).toFixed(1) + 's';
            });
        }

        draw() {
            this.ctx.clearRect(0, 0, this.width, this.height);

            // 设置坐标系
            this.ctx.save();
            this.ctx.translate(50, this.height - 50);
            this.ctx.scale(60, -60);

            // 绘制网格
            this.drawGrid();

            // 绘制决策边界
            this.drawDecisionBoundary();

            // 绘制数据点
            this.drawPoints();

            // 绘制坐标轴
            this.drawAxes();

            this.ctx.restore();

            // 绘制标签
            this.drawLabels();
        }

        drawGrid() {
            this.ctx.strokeStyle = 'rgba(255, 255, 255, 0.1)';
            this.ctx.lineWidth = 0.01;

            for (let i = 0; i <= 5; i++) {
                // 垂直线
                this.ctx.beginPath();
                this.ctx.moveTo(i, 0);
                this.ctx.lineTo(i, 5);
                this.ctx.stroke();

                // 水平线
                this.ctx.beginPath();
                this.ctx.moveTo(0, i);
                this.ctx.lineTo(5, i);
                this.ctx.stroke();
            }
        }

        drawAxes() {
            this.ctx.strokeStyle = 'rgba(255, 255, 255, 0.5)';
            this.ctx.lineWidth = 0.02;

            // x轴
            this.ctx.beginPath();
            this.ctx.moveTo(0, 0);
            this.ctx.lineTo(5, 0);
            this.ctx.stroke();

            // y轴
            this.ctx.beginPath();
            this.ctx.moveTo(0, 0);
            this.ctx.lineTo(0, 5);
            this.ctx.stroke();
        }

        drawDecisionBoundary() {
            if (this.w[0] === 0 && this.w[1] === 0) return;

            this.ctx.strokeStyle = '#22c55e';
            this.ctx.lineWidth = 0.05;

            // 计算边界线的两个端点
            let x1, y1, x2, y2;

            if (Math.abs(this.w[1]) > 0.001) {
                x1 = 0;
                y1 = -(this.w[0] * x1 + this.b) / this.w[1];
                x2 = 5;
                y2 = -(this.w[0] * x2 + this.b) / this.w[1];
            } else {
                x1 = x2 = -this.b / this.w[0];
                y1 = 0;
                y2 = 5;
            }

            this.ctx.beginPath();
            this.ctx.moveTo(x1, y1);
            this.ctx.lineTo(x2, y2);
            this.ctx.stroke();

            // 绘制法向量
            if (this.w[0] !== 0 || this.w[1] !== 0) {
                const norm = Math.sqrt(this.w[0]**2 + this.w[1]**2);
                const nx = this.w[0] / norm;
                const ny = this.w[1] / norm;

                this.ctx.strokeStyle = '#8b5cf6';
                this.ctx.lineWidth = 0.03;

                const centerX = 2.5;
                const centerY = 2.5;

                this.ctx.beginPath();
                this.ctx.moveTo(centerX, centerY);
                this.ctx.lineTo(centerX + nx, centerY + ny);
                this.ctx.stroke();

                // 箭头
                this.ctx.fillStyle = '#8b5cf6';
                this.ctx.beginPath();
                this.ctx.arc(centerX + nx, centerY + ny, 0.1, 0, Math.PI * 2);
                this.ctx.fill();
            }
        }

        drawPoints() {
            this.points.forEach((point, idx) => {
                const isActive = idx === this.sampleIdx;

                // 绘制点
                this.ctx.fillStyle = point.color;
                this.ctx.strokeStyle = isActive ? '#fbbf24' : '#1f2937';
                this.ctx.lineWidth = isActive ? 0.08 : 0.04;

                this.ctx.beginPath();
                this.ctx.arc(point.x[0], point.x[1], 0.15, 0, Math.PI * 2);
                this.ctx.fill();
                this.ctx.stroke();

                // 如果是当前处理的点，添加动画效果
                if (isActive) {
                    this.ctx.strokeStyle = '#fbbf24';
                    this.ctx.lineWidth = 0.02;
                    this.ctx.setLineDash([0.1, 0.1]);
                    this.ctx.beginPath();
                    this.ctx.arc(point.x[0], point.x[1], 0.25, 0, Math.PI * 2);
                    this.ctx.stroke();
                    this.ctx.setLineDash([]);
                }
            });
        }

        drawLabels() {
            this.ctx.font = '14px Arial';
            this.ctx.fillStyle = '#f1f5f9';

            // x轴标签
            for (let i = 0; i <= 5; i++) {
                this.ctx.fillText(i.toString(), 50 + i * 60 - 5, this.height - 30);
            }

            // y轴标签
            for (let i = 0; i <= 5; i++) {
                this.ctx.fillText(i.toString(), 25, this.height - 50 - i * 60 + 5);
            }

            // 轴名称
            this.ctx.fillText('x₁', this.width - 30, this.height - 10);
            this.ctx.fillText('x₂', 10, 20);

            // 点标签
            this.points.forEach(point => {
                const x = 50 + point.x[0] * 60;
                const y = this.height - 50 - point.x[1] * 60;
                this.ctx.fillText(point.label, x + 15, y - 15);
            });
        }

        step() {
            // 移动到下一个样本
            this.sampleIdx++;
            if (this.sampleIdx >= this.points.length) {
                this.sampleIdx = 0;
                this.epoch++;
            }

            const point = this.points[this.sampleIdx];
            const x = point.x;
            const y = point.y;

            // 更新显示
            document.getElementById('calc-epoch').textContent = this.epoch;
            document.getElementById('calc-sample').textContent = `${point.label} (${x[0]}, ${x[1]}), y = ${y > 0 ? '+1' : '-1'}`;
            document.getElementById('calc-w').textContent = `${this.w[0].toFixed(2)}, ${this.w[1].toFixed(2)}`;
            document.getElementById('calc-b').textContent = this.b.toFixed(2);

            // 计算
            const z = this.w[0] * x[0] + this.w[1] * x[1] + this.b;
            const pred = z >= 0 ? 1 : -1;
            const correct = pred === y;

            // 显示计算细节
            const mathDetails = document.getElementById('math-details');
            mathDetails.innerHTML = `
            <div>w·x + b = ${this.w[0].toFixed(2)}×${x[0]} + ${this.w[1].toFixed(2)}×${x[1]} + ${this.b.toFixed(2)}</div>
            <div style="margin-left: 3.5rem;">= ${(this.w[0]*x[0]).toFixed(2)} + ${(this.w[1]*x[1]).toFixed(2)} + ${this.b.toFixed(2)}</div>
            <div style="margin-left: 3.5rem;">= <strong>${z.toFixed(2)}</strong></div>
            <div style="margin-top: 0.5rem;">预测: sign(${z.toFixed(2)}) = <strong style="color: ${pred > 0 ? '#3b82f6' : '#ef4444'}">${pred > 0 ? '+1' : '-1'}</strong></div>
            <div>真实: <strong style="color: ${y > 0 ? '#3b82f6' : '#ef4444'}">${y > 0 ? '+1' : '-1'}</strong></div>
            <div style="margin-top: 0.5rem; color: ${correct ? '#22c55e' : '#ef4444'}"><strong>${correct ? '✓ 正确!' : '✗ 错误!'}</strong></div>
        `;

            // 高亮显示计算步骤
            const steps = document.querySelectorAll('.calc-step');
            steps.forEach((step, idx) => {
                step.style.opacity = '1';
                step.style.color = idx < 3 ? 'var(--accent-green)' : (correct ? 'var(--text-muted)' : 'var(--accent-yellow)');
            });

            // 如果预测错误，更新参数
            if (!correct) {
                const old_w = [...this.w];
                const old_b = this.b;

                this.w[0] += this.lr * y * x[0];
                this.w[1] += this.lr * y * x[1];
                this.b += this.lr * y;

                this.updateCount++;

                // 添加更新历史
                const history = document.getElementById('update-history');
                const updateInfo = `
                <div style="padding: 0.5rem; background: rgba(239, 68, 68, 0.1); border-radius: 0.25rem; margin-bottom: 0.5rem;">
                    <strong>第${this.updateCount}次更新</strong> (轮${this.epoch}, 样本${point.label})
                    <div style="font-size: 0.8rem; margin-top: 0.25rem;">
                        w: [${old_w[0].toFixed(2)}, ${old_w[1].toFixed(2)}] → [${this.w[0].toFixed(2)}, ${this.w[1].toFixed(2)}]<br>
                        b: ${old_b.toFixed(2)} → ${this.b.toFixed(2)}
                    </div>
                </div>
            `;

                if (this.updateCount === 1) {
                    history.innerHTML = updateInfo;
                } else {
                    history.innerHTML = updateInfo + history.innerHTML;
                }

                // 更新数学细节显示
                setTimeout(() => {
                    mathDetails.innerHTML += `
                    <div style="margin-top: 1rem; padding: 0.5rem; background: rgba(251, 191, 36, 0.2); border-radius: 0.25rem;">
                        <strong>更新参数:</strong><br>
                        w ← w + η·y·x = [${old_w[0].toFixed(2)}, ${old_w[1].toFixed(2)}] + 1×${y}×[${x[0]}, ${x[1]}]<br>
                        　　　　　　= [${this.w[0].toFixed(2)}, ${this.w[1].toFixed(2)}]<br>
                        b ← b + η·y = ${old_b.toFixed(2)} + 1×${y} = ${this.b.toFixed(2)}
                    </div>
                `;
                }, 500);
            }

            // 重新绘制
            this.draw();

            // 检查是否收敛
            if (this.checkConvergence()) {
                this.isRunning = false;
                this.showResult();
                return true;
            }

            return false;
        }

        checkConvergence() {
            if (this.epoch > 50) return true; // 防止无限循环

            for (const point of this.points) {
                const z = this.w[0] * point.x[0] + this.w[1] * point.x[1] + this.b;
                const pred = z >= 0 ? 1 : -1;
                if (pred !== point.y) return false;
            }
            return true;
        }

        showResult() {
            const resultDiv = document.getElementById('calculation-result');
            resultDiv.style.display = 'block';

            document.getElementById('final-result').innerHTML = `
            <p><strong>最终参数：</strong></p>
            <ul>
                <li>权重向量 w = [${this.w[0].toFixed(3)}, ${this.w[1].toFixed(3)}]</li>
                <li>偏置 b = ${this.b.toFixed(3)}</li>
                <li>决策边界方程：${this.w[0].toFixed(3)}x₁ + ${this.w[1].toFixed(3)}x₂ + ${this.b.toFixed(3)} = 0</li>
            </ul>
            <p><strong>训练统计：</strong></p>
            <ul>
                <li>总迭代轮次：${this.epoch}</li>
                <li>参数更新次数：${this.updateCount}</li>
                <li>最终准确率：100%</li>
            </ul>
        `;

            showNotification('🎉 感知机收敛成功！');
        }

        reset() {
            this.w = [0, 0];
            this.b = 0;
            this.epoch = 0;
            this.sampleIdx = -1;
            this.updateCount = 0;
            this.isRunning = false;

            document.getElementById('calc-epoch').textContent = '0';
            document.getElementById('calc-sample').textContent = '等待开始...';
            document.getElementById('calc-w').textContent = '0, 0';
            document.getElementById('calc-b').textContent = '0';
            document.getElementById('math-details').innerHTML = '等待计算...';
            document.getElementById('update-history').innerHTML = '<div style="color: var(--text-secondary);">还没有更新记录...</div>';
            document.getElementById('calculation-result').style.display = 'none';

            document.querySelectorAll('.calc-step').forEach(step => {
                step.style.opacity = '0.5';
                step.style.color = 'inherit';
            });

            this.draw();
        }
    }

    // 初始化数学可视化
    let mathViz = null;
    document.addEventListener('DOMContentLoaded', () => {
        if (document.getElementById('perceptron-math-viz')) {
            mathViz = new PerceptronMathVisualizer();
        }
    });

    // 控制函数
    function startCalculation() {
        if (!mathViz) mathViz = new PerceptronMathVisualizer();

        mathViz.isRunning = true;
        document.getElementById('start-calculation').innerHTML = '⏸️ 暂停';
        document.getElementById('start-calculation').onclick = pauseCalculation;

        const speed = parseInt(document.getElementById('calc-speed').value);

        const runStep = () => {
            if (!mathViz.isRunning) return;

            const converged = mathViz.step();

            if (!converged) {
                setTimeout(runStep, speed);
            } else {
                document.getElementById('start-calculation').innerHTML = '▶️ 开始计算';
                document.getElementById('start-calculation').onclick = startCalculation;
            }
        };

        runStep();
    }

    function pauseCalculation() {
        if (mathViz) {
            mathViz.isRunning = false;
            document.getElementById('start-calculation').innerHTML = '▶️ 继续';
            document.getElementById('start-calculation').onclick = startCalculation;
        }
    }

    function stepCalculation() {
        if (!mathViz) mathViz = new PerceptronMathVisualizer();
        mathViz.isRunning = false;
        mathViz.step();
    }

    function resetCalculation() {
        if (!mathViz) mathViz = new PerceptronMathVisualizer();
        mathViz.reset();
        document.getElementById('start-calculation').innerHTML = '▶️ 开始计算';
        document.getElementById('start-calculation').onclick = startCalculation;
    }
    // 初始化代码高亮
    hljs.highlightAll();

    // 初始化数学公式渲染
    renderMathInElement(document.body, {
        delimiters: [
            {left: '$$', right: '$$', display: true},
            {left: '$', right: '$', display: false}
        ]
    });

    // 全局变量
    let currentDifficulty = 'beginner';
    let buddyMessages = {
        beginner: [
            "记住：感知机就像一个简单的投票器！",
            "如果觉得数学公式难懂，先看几何直观。",
            "XOR问题告诉我们：有时候简单不够用。"
        ],
        intermediate: [
            "注意权重更新的方向与错误分类的关系。",
            "思考一下：为什么偏置项b也需要更新？",
            "收敛定理的条件很重要：线性可分！"
        ],
        advanced: [
            "感知机损失函数是非凸的，但依然能收敛。",
            "对偶形式能揭示支持向量机的联系。",
            "核技巧能让感知机处理非线性问题。"
        ]
    };

    // 导航功能
    const sidebar = document.getElementById('sidebar');
    const sidebarOverlay = document.getElementById('sidebar-overlay');
    const toggleSidebarBtn = document.getElementById('toggle-sidebar');

    toggleSidebarBtn.addEventListener('click', () => {
        sidebar.classList.toggle('open');
        sidebarOverlay.classList.toggle('active');
    });

    sidebarOverlay.addEventListener('click', () => {
        sidebar.classList.remove('open');
        sidebarOverlay.classList.remove('active');
    });

    // 学习伙伴功能
    const learningBuddy = document.getElementById('learning-buddy');
    const toggleBuddyBtn = document.getElementById('toggle-buddy');
    const minimizeBuddyBtn = document.getElementById('minimize-buddy');
    const closeBuddyBtn = document.getElementById('close-buddy');
    const buddyAvatar = document.getElementById('buddy-avatar');

    toggleBuddyBtn.addEventListener('click', () => {
        learningBuddy.classList.toggle('active');
    });

    minimizeBuddyBtn.addEventListener('click', () => {
        learningBuddy.classList.toggle('minimized');
    });

    closeBuddyBtn.addEventListener('click', () => {
        learningBuddy.classList.remove('active');
    });

    buddyAvatar.addEventListener('click', () => {
        if (learningBuddy.classList.contains('minimized')) {
            learningBuddy.classList.remove('minimized');
        }
    });

    // 学习伙伴提示功能
    function getBuddyHint() {
        const messages = buddyMessages[currentDifficulty];
        const randomMessage = messages[Math.floor(Math.random() * messages.length)];
        updateBuddyMessage(randomMessage);
    }

    function getBuddySummary() {
        const summary = `
        本章核心要点：<br>
        1. 感知机 = 线性组合 + 符号函数<br>
        2. 学习规则：从错误中学习<br>
        3. 局限性：只能处理线性可分问题<br>
        4. 历史意义：开启了神经网络时代
    `;
        updateBuddyMessage(summary);
    }

    function updateBuddyMessage(message) {
        const messageElement = document.querySelector('.buddy-message p');
        messageElement.innerHTML = message;

        // 添加动画效果
        messageElement.style.animation = 'none';
        setTimeout(() => {
            messageElement.style.animation = 'fadeIn 0.5s ease';
        }, 10);
    }

    // 主题切换
    const toggleThemeBtn = document.getElementById('toggle-theme');
    toggleThemeBtn.addEventListener('click', () => {
        const currentTheme = document.body.getAttribute('data-theme');
        const newTheme = currentTheme === 'light' ? 'dark' : 'light';
        document.body.setAttribute('data-theme', newTheme);
        localStorage.setItem('theme', newTheme);
    });

    // 加载保存的主题
    const savedTheme = localStorage.getItem('theme') || 'dark';
    document.body.setAttribute('data-theme', savedTheme);

    // 难度选择功能
    const difficultyOptions = document.querySelectorAll('.difficulty-option');
    difficultyOptions.forEach(option => {
        option.addEventListener('click', () => {
            const difficulty = option.querySelector('input').value;
            currentDifficulty = difficulty;

            // 更新选中状态
            difficultyOptions.forEach(opt => opt.classList.remove('active'));
            option.classList.add('active');

            // 更新内容显示
            updateContentVisibility(difficulty);

            // 显示通知
            showNotification(`已切换到${option.textContent.trim()}模式`);
        });
    });

    function updateContentVisibility(difficulty) {
        // 根据难度显示/隐藏内容
        const beginnerContent = document.querySelectorAll('.beginner-content');
        const intermediateContent = document.querySelectorAll('.intermediate-content');
        const advancedContent = document.querySelectorAll('.advanced-content');

        // 默认显示所有初学者内容
        beginnerContent.forEach(el => el.style.display = 'block');

        if (difficulty === 'beginner') {
            intermediateContent.forEach(el => el.style.display = 'none');
            advancedContent.forEach(el => el.style.display = 'none');
        } else if (difficulty === 'intermediate') {
            intermediateContent.forEach(el => el.style.display = 'block');
            advancedContent.forEach(el => el.style.display = 'none');
        } else {
            intermediateContent.forEach(el => el.style.display = 'block');
            advancedContent.forEach(el => el.style.display = 'block');
        }
    }

    // 折叠功能
    const collapsibles = document.querySelectorAll('.collapsible-header');
    collapsibles.forEach(header => {
        header.addEventListener('click', () => {
            const collapsible = header.parentElement;
            collapsible.classList.toggle('expanded');
        });

        // 键盘支持
        header.addEventListener('keypress', (e) => {
            if (e.key === 'Enter' || e.key === ' ') {
                e.preventDefault();
                header.click();
            }
        });
    });

    // 滚动进度条
    function updateProgressBar() {
        const scrollTop = window.pageYOffset || document.documentElement.scrollTop;
        const scrollHeight = document.documentElement.scrollHeight - document.documentElement.clientHeight;
        const scrollPercentage = (scrollTop / scrollHeight) * 100;
        document.getElementById('progress-bar').style.width = scrollPercentage + '%';
    }

    window.addEventListener('scroll', updateProgressBar);

    // 导航高亮
    const sections = document.querySelectorAll('section[id]');
    const navItems = document.querySelectorAll('.toc-item');

    function updateNavHighlight() {
        const scrollPosition = window.pageYOffset + 100;

        sections.forEach((section, index) => {
            const sectionTop = section.offsetTop;
            const sectionHeight = section.offsetHeight;

            if (scrollPosition >= sectionTop && scrollPosition < sectionTop + sectionHeight) {
                navItems.forEach(item => item.classList.remove('active'));
                navItems[index].classList.add('active');
            }
        });
    }

    window.addEventListener('scroll', updateNavHighlight);

    // 成就系统
    let completedSections = new Set();
    let achievements = {
        firstConcept: false,
        allPractice: false,
        deepDive: false,
        finishChapter: false
    };

    function checkAchievements() {
        const totalSections = sections.length;
        const completed = completedSections.size;

        if (completed === 1 && !achievements.firstConcept) {
            achievements.firstConcept = true;
            showAchievement("初识感知机", "完成了第一个概念的学习！");
        }

        if (completed === totalSections && !achievements.finishChapter) {
            achievements.finishChapter = true;
            showAchievement("感知机大师", "完成了整章的学习！");
        }

        updateAchievementProgress(completed, totalSections);
    }

    function showAchievement(title, description) {
        const popup = document.getElementById('achievement-popup');
        const textElement = document.getElementById('achievement-text');

        textElement.textContent = description;
        popup.classList.add('show');

        setTimeout(() => {
            popup.classList.remove('show');
        }, 5000);
    }

    function updateAchievementProgress(completed, total) {
        const progress = (completed / total) * 100;
        document.getElementById('achievement-progress').style.width = progress + '%';
        document.getElementById('achievement-count').textContent = completed;
    }

    // 交互式可视化
    class PerceptronVisualizer {
        constructor(canvasId) {
            this.canvas = document.getElementById(canvasId);
            this.ctx = this.canvas.getContext('2d');
            this.width = this.canvas.width;
            this.height = this.canvas.height;

            // 数据点
            this.points = this.generateData();

            // 感知机参数
            this.w1 = 1;
            this.w2 = 1;
            this.b = -120;

            // 绑定滑块
            this.bindSliders();

            // 初始绘制
            this.draw();

            // 鼠标交互
            this.canvas.addEventListener('click', (e) => this.addPoint(e));
        }

        generateData() {
            const points = [];

            // 生成两类数据
            // 第一类：通过考试的学生（蓝色）
            for (let i = 0; i < 20; i++) {
                points.push({
                    x: 60 + Math.random() * 40,  // 作业分数 60-100
                    y: 60 + Math.random() * 40,  // 期中分数 60-100
                    label: 1,
                    color: '#3b82f6'
                });
            }

            // 第二类：未通过的学生（红色）
            for (let i = 0; i < 20; i++) {
                points.push({
                    x: 20 + Math.random() * 40,  // 作业分数 20-60
                    y: 20 + Math.random() * 40,  // 期中分数 20-60
                    label: -1,
                    color: '#ef4444'
                });
            }

            return points;
        }

        bindSliders() {
            const w1Slider = document.getElementById('w1-slider');
            const w2Slider = document.getElementById('w2-slider');
            const bSlider = document.getElementById('b-slider');

            w1Slider.addEventListener('input', (e) => {
                this.w1 = parseFloat(e.target.value);
                document.getElementById('w1-value').textContent = this.w1.toFixed(1);
                this.draw();
            });

            w2Slider.addEventListener('input', (e) => {
                this.w2 = parseFloat(e.target.value);
                document.getElementById('w2-value').textContent = this.w2.toFixed(1);
                this.draw();
            });

            bSlider.addEventListener('input', (e) => {
                this.b = parseFloat(e.target.value);
                document.getElementById('b-value').textContent = this.b;
                this.draw();
            });
        }

        predict(x, y) {
            return Math.sign(this.w1 * x + this.w2 * y + this.b);
        }

        draw() {
            // 清空画布
            this.ctx.clearRect(0, 0, this.width, this.height);

            // 绘制决策边界
            this.drawDecisionBoundary();

            // 绘制数据点
            let correct = 0;
            let errors = 0;

            this.points.forEach(point => {
                const predicted = this.predict(point.x, point.y);
                const isCorrect = predicted === point.label;

                if (isCorrect) correct++;
                else errors++;

                this.drawPoint(point, isCorrect);
            });

            // 更新统计信息
            document.getElementById('correct-count').textContent = correct;
            document.getElementById('error-count').textContent = errors;
            document.getElementById('accuracy').textContent =
                ((correct / this.points.length) * 100).toFixed(1) + '%';
        }

        drawDecisionBoundary() {
            if (this.w2 === 0) return;

            this.ctx.strokeStyle = '#22c55e';
            this.ctx.lineWidth = 3;
            this.ctx.beginPath();

            // 计算决策边界的两个端点
            const x1 = 0;
            const y1 = -(this.w1 * x1 + this.b) / this.w2;

            const x2 = 100;
            const y2 = -(this.w1 * x2 + this.b) / this.w2;

            // 转换到画布坐标
            const canvasX1 = (x1 / 100) * this.width;
            const canvasY1 = this.height - (y1 / 100) * this.height;

            const canvasX2 = (x2 / 100) * this.width;
            const canvasY2 = this.height - (y2 / 100) * this.height;

            this.ctx.moveTo(canvasX1, canvasY1);
            this.ctx.lineTo(canvasX2, canvasY2);
            this.ctx.stroke();

            // 绘制法向量
            const centerX = this.width / 2;
            const centerY = this.height / 2;
            const normalScale = 50;

            this.ctx.strokeStyle = '#8b5cf6';
            this.ctx.beginPath();
            this.ctx.moveTo(centerX, centerY);
            this.ctx.lineTo(
                centerX + this.w1 * normalScale,
                centerY - this.w2 * normalScale
            );
            this.ctx.stroke();

            // 绘制箭头
            this.ctx.fillStyle = '#8b5cf6';
            this.ctx.beginPath();
            this.ctx.arc(
                centerX + this.w1 * normalScale,
                centerY - this.w2 * normalScale,
                5, 0, Math.PI * 2
            );
            this.ctx.fill();
        }

        drawPoint(point, isCorrect) {
            const canvasX = (point.x / 100) * this.width;
            const canvasY = this.height - (point.y / 100) * this.height;

            this.ctx.fillStyle = point.color;
            this.ctx.strokeStyle = isCorrect ? '#10b981' : '#fbbf24';
            this.ctx.lineWidth = isCorrect ? 2 : 4;

            this.ctx.beginPath();
            this.ctx.arc(canvasX, canvasY, 8, 0, Math.PI * 2);
            this.ctx.fill();
            this.ctx.stroke();
        }

        addPoint(event) {
            const rect = this.canvas.getBoundingClientRect();
            const canvasX = event.clientX - rect.left;
            const canvasY = event.clientY - rect.top;

            // 转换到数据坐标
            const x = (canvasX / this.width) * 100;
            const y = ((this.height - canvasY) / this.height) * 100;

            // 预测标签
            const label = this.predict(x, y);

            this.points.push({
                x: x,
                y: y,
                label: label,
                color: label === 1 ? '#3b82f6' : '#ef4444'
            });

            this.draw();
        }
    }

    // 创建可视化实例
    const perceptronViz = new PerceptronVisualizer('perceptron-canvas');

    // 自动训练功能
    function autoTrain() {
        const points = perceptronViz.points;
        const lr = 0.01;
        let iterations = 0;
        const maxIterations = 1000;

        const trainStep = () => {
            let hasError = false;

            // 随机选择一个错误分类的点
            const shuffled = [...points].sort(() => Math.random() - 0.5);

            for (const point of shuffled) {
                const predicted = perceptronViz.predict(point.x, point.y);

                if (predicted !== point.label) {
                    hasError = true;

                    // 更新权重
                    perceptronViz.w1 += lr * point.label * point.x;
                    perceptronViz.w2 += lr * point.label * point.y;
                    perceptronViz.b += lr * point.label;

                    // 更新滑块
                    document.getElementById('w1-slider').value = perceptronViz.w1;
                    document.getElementById('w2-slider').value = perceptronViz.w2;
                    document.getElementById('b-slider').value = perceptronViz.b;

                    document.getElementById('w1-value').textContent = perceptronViz.w1.toFixed(1);
                    document.getElementById('w2-value').textContent = perceptronViz.w2.toFixed(1);
                    document.getElementById('b-value').textContent = perceptronViz.b.toFixed(0);

                    perceptronViz.draw();
                    break;
                }
            }

            iterations++;

            if (!hasError || iterations >= maxIterations) {
                if (!hasError) {
                    showNotification('🎉 训练完成！所有样本都被正确分类。');
                } else {
                    showNotification('⚠️ 达到最大迭代次数，数据可能不是线性可分的。');
                }
            } else {
                setTimeout(trainStep, 50);
            }
        };

        trainStep();
    }

    function resetParams() {
        perceptronViz.w1 = 1;
        perceptronViz.w2 = 1;
        perceptronViz.b = -120;

        document.getElementById('w1-slider').value = 1;
        document.getElementById('w2-slider').value = 1;
        document.getElementById('b-slider').value = -120;

        document.getElementById('w1-value').textContent = '1.0';
        document.getElementById('w2-value').textContent = '1.0';
        document.getElementById('b-value').textContent = '-120';

        perceptronViz.draw();
    }

    // 练习题功能
    const practiceOptions = document.querySelectorAll('.practice-option');
    practiceOptions.forEach(option => {
        option.addEventListener('click', function() {
            const answer = this.getAttribute('data-answer');
            const questionNumber = this.closest('.instant-practice').querySelector('.practice-feedback').id.split('-').pop();

            // 清除之前的选择
            this.parentElement.querySelectorAll('.practice-option').forEach(opt => {
                opt.classList.remove('selected', 'correct', 'incorrect');
            });

            this.classList.add('selected');

            // 检查答案
            checkAnswer(answer, questionNumber);
        });
    });

    function checkAnswer(answer, questionNumber) {
        const correctAnswers = {
            '1': 'b',  // 不知道如何确定最佳的权重参数
            '2': 'b',  // 一条直线
            '3': 'b'   // 正确分类的样本不需要调整决策边界
        };

        const feedback = document.getElementById(`practice-feedback-${questionNumber}`);
        const isCorrect = answer === correctAnswers[questionNumber];

        if (isCorrect) {
            feedback.className = 'practice-feedback show correct';
            feedback.innerHTML = `
            <strong>✅ 正确！</strong><br>
            ${getFeedbackText(questionNumber, true)}
        `;

            // 标记完成
            completedSections.add(`practice-${questionNumber}`);
            checkAchievements();
        } else {
            feedback.className = 'practice-feedback show incorrect';
            feedback.innerHTML = `
            <strong>❌ 再想想...</strong><br>
            ${getFeedbackText(questionNumber, false)}
        `;
        }
    }

    function getFeedbackText(questionNumber, isCorrect) {
        const feedbacks = {
            '1': {
                correct: "没错！小陈的核心困难是不知道如何系统地找到最优参数，这正是机器学习要解决的问题。",
                incorrect: "提示：想想看，小陈尝试了各种权重组合但效果不好，他最需要的是什么？"
            },
            '2': {
                correct: "正确！在二维空间中，w₁x₁ + w₂x₂ + b = 0 确实表示一条直线，这就是感知机的决策边界。",
                incorrect: "提示：这是一个线性方程，想想线性方程在平面上表示什么几何图形？"
            },
            '3': {
                correct: "完全正确！这就是感知机学习算法的精髓 —— 只修正错误，保持正确。",
                incorrect: "提示：如果一个样本已经被正确分类了，调整参数可能会影响什么？"
            }
        };

        return feedbacks[questionNumber][isCorrect ? 'correct' : 'incorrect'];
    }

    // 代码标签切换
    const codeTabs = document.querySelectorAll('.code-tab');
    codeTabs.forEach(tab => {
        tab.addEventListener('click', function() {
            const lang = this.getAttribute('data-lang');

            // 更新标签状态
            codeTabs.forEach(t => t.classList.remove('active'));
            this.classList.add('active');

            // 切换代码内容
            document.querySelectorAll('.code-content').forEach(content => {
                content.style.display = 'none';
            });
            document.getElementById(`${lang}-code`).style.display = 'block';
        });
    });

    // 代码功能
    function copyCode() {
        const activeTab = document.querySelector('.code-tab.active');
        const lang = activeTab.getAttribute('data-lang');
        const codeContent = document.getElementById(`${lang}-code`).textContent;

        navigator.clipboard.writeText(codeContent).then(() => {
            showNotification('代码已复制到剪贴板！');
        });
    }

    function runCode() {
        const output = document.getElementById('code-output');
        output.classList.add('show');

        // 模拟运行效果
        output.innerHTML = `
        <strong>运行结果：</strong>
        <pre>正在训练感知机...
Epoch 0: 错误数 = 12, 准确率 = 88.0%
Epoch 10: 错误数 = 5, 准确率 = 95.0%
Epoch 20: 错误数 = 2, 准确率 = 98.0%
✓ 完美收敛！仅用了 23 轮迭代

最终参数：
权重 w = [0.832, 0.645]
偏置 b = -1.2451
训练准确率: 100.0%</pre>
    `;
    }

    // 通知功能
    function showNotification(message) {
        const notification = document.createElement('div');
        notification.className = 'notification';
        notification.textContent = message;
        document.body.appendChild(notification);

        setTimeout(() => {
            notification.remove();
        }, 3000);
    }

    // XOR演示
    class XORVisualizer {
        constructor() {
            this.canvas = document.getElementById('xor-canvas');
            this.ctx = this.canvas.getContext('2d');
            this.width = this.canvas.width;
            this.height = this.canvas.height;

            // XOR数据
            this.points = [
                {x: 0, y: 0, label: -1, color: '#ef4444'},
                {x: 0, y: 1, label: 1, color: '#3b82f6'},
                {x: 1, y: 0, label: 1, color: '#3b82f6'},
                {x: 1, y: 1, label: -1, color: '#ef4444'}
            ];

            this.drawXOR();
        }

        drawXOR() {
            this.ctx.clearRect(0, 0, this.width, this.height);

            // 绘制网格
            this.drawGrid();

            // 绘制数据点
            this.points.forEach(point => {
                const canvasX = point.x * this.width * 0.8 + this.width * 0.1;
                const canvasY = this.height - (point.y * this.height * 0.8 + this.height * 0.1);

                this.ctx.fillStyle = point.color;
                this.ctx.strokeStyle = '#1f2937';
                this.ctx.lineWidth = 3;

                this.ctx.beginPath();
                this.ctx.arc(canvasX, canvasY, 20, 0, Math.PI * 2);
                this.ctx.fill();
                this.ctx.stroke();

                // 绘制坐标标签
                this.ctx.fillStyle = '#f1f5f9';
                this.ctx.font = '14px sans-serif';
                this.ctx.textAlign = 'center';
                this.ctx.fillText(`(${point.x},${point.y})`, canvasX, canvasY + 40);
            });
        }

        drawGrid() {
            this.ctx.strokeStyle = 'rgba(255, 255, 255, 0.1)';
            this.ctx.lineWidth = 1;

            // 垂直线
            for (let i = 0; i <= 10; i++) {
                const x = (i / 10) * this.width;
                this.ctx.beginPath();
                this.ctx.moveTo(x, 0);
                this.ctx.lineTo(x, this.height);
                this.ctx.stroke();
            }

            // 水平线
            for (let i = 0; i <= 10; i++) {
                const y = (i / 10) * this.height;
                this.ctx.beginPath();
                this.ctx.moveTo(0, y);
                this.ctx.lineTo(this.width, y);
                this.ctx.stroke();
            }
        }

        animateFailure() {
            let angle = 0;
            const animate = () => {
                this.drawXOR();

                // 绘制旋转的直线，表示无法找到合适的决策边界
                this.ctx.save();
                this.ctx.translate(this.width / 2, this.height / 2);
                this.ctx.rotate(angle);

                this.ctx.strokeStyle = '#ef4444';
                this.ctx.lineWidth = 3;
                this.ctx.setLineDash([10, 10]);

                this.ctx.beginPath();
                this.ctx.moveTo(-this.width, 0);
                this.ctx.lineTo(this.width, 0);
                this.ctx.stroke();

                this.ctx.restore();

                angle += 0.02;

                if (angle < Math.PI * 2) {
                    requestAnimationFrame(animate);
                } else {
                    this.drawXOR();
                    document.getElementById('xor-explanation').style.display = 'block';
                }
            };

            animate();
        }
    }

    const xorViz = new XORVisualizer();

    function tryXORPerceptron() {
        showNotification('尝试训练感知机解决XOR问题...');
        xorViz.animateFailure();
    }

    function showXORSolution() {
        // 这里可以展示多层感知机的解决方案
        showNotification('使用两层神经网络可以解决XOR问题！详见下一章。');
    }

    // 反馈功能
    function submitFeedback(type) {
        document.getElementById('feedback-response').style.display = 'block';

        // 记录反馈
        console.log(`User feedback: ${type}`);

        // 可以发送到服务器
        // fetch('/api/feedback', { method: 'POST', body: JSON.stringify({ type, chapter: 1 }) });
    }

    // 页面加载完成后初始化
    document.addEventListener('DOMContentLoaded', () => {
        // 初始化难度
        updateContentVisibility(currentDifficulty);

        // 显示欢迎消息
        setTimeout(() => {
            learningBuddy.classList.add('active');
        }, 2000);

        // 检查学习进度
        const visited = localStorage.getItem('chapter1_visited');
        if (!visited) {
            localStorage.setItem('chapter1_visited', 'true');
            showAchievement('开始学习', '欢迎来到深度学习之旅！');
        }
    });

    // 生物神经元可视化
    function drawBioNeuron() {
        const canvas = document.getElementById('bio-neuron-canvas');
        const ctx = canvas.getContext('2d');
        const width = canvas.width;
        const height = canvas.height;

        ctx.clearRect(0, 0, width, height);

        // 细胞体
        ctx.fillStyle = '#fbbf24';
        ctx.beginPath();
        ctx.arc(width/2, height/2, 40, 0, Math.PI * 2);
        ctx.fill();

        // 树突
        ctx.strokeStyle = '#f59e0b';
        ctx.lineWidth = 3;
        for (let i = 0; i < 5; i++) {
            const angle = (i / 5) * Math.PI - Math.PI/2;
            const x1 = width/2 + Math.cos(angle) * 40;
            const y1 = height/2 + Math.sin(angle) * 40;
            const x2 = width/2 + Math.cos(angle) * 80;
            const y2 = height/2 + Math.sin(angle) * 80;

            ctx.beginPath();
            ctx.moveTo(x1, y1);
            ctx.lineTo(x2, y2);
            ctx.stroke();

            // 分支
            for (let j = 0; j < 2; j++) {
                const branchAngle = angle + (j - 0.5) * 0.3;
                const bx1 = x2;
                const by1 = y2;
                const bx2 = x2 + Math.cos(branchAngle) * 20;
                const by2 = y2 + Math.sin(branchAngle) * 20;

                ctx.beginPath();
                ctx.moveTo(bx1, by1);
                ctx.lineTo(bx2, by2);
                ctx.stroke();
            }
        }

        // 轴突
        ctx.strokeStyle = '#dc2626';
        ctx.lineWidth = 5;
        ctx.beginPath();
        ctx.moveTo(width/2, height/2 + 40);
        ctx.lineTo(width/2, height - 20);
        ctx.stroke();

        // 轴突末梢
        for (let i = 0; i < 3; i++) {
            const x = width/2 + (i - 1) * 30;
            const y = height - 20;

            ctx.fillStyle = '#ef4444';
            ctx.beginPath();
            ctx.arc(x, y, 8, 0, Math.PI * 2);
            ctx.fill();
        }

        // 标签
        ctx.fillStyle = '#f1f5f9';
        ctx.font = '12px sans-serif';
        ctx.fillText('树突', 50, 50);
        ctx.fillText('细胞体', width/2 + 50, height/2);
        ctx.fillText('轴突', width/2 + 20, height/2 + 80);
    }

    // 人工神经元可视化
    function drawArtificialNeuron() {
        const canvas = document.getElementById('artificial-neuron-canvas');
        const ctx = canvas.getContext('2d');
        const width = canvas.width;
        const height = canvas.height;

        ctx.clearRect(0, 0, width, height);

        // 输入
        const inputs = [
            {x: 50, y: 50, label: 'x₁'},
            {x: 50, y: 100, label: 'x₂'},
            {x: 50, y: 150, label: 'x₃'},
            {x: 50, y: 200, label: '...'},
            {x: 50, y: 250, label: 'xₙ'}
        ];

        // 绘制输入节点
        inputs.forEach(input => {
            ctx.fillStyle = '#3b82f6';
            ctx.beginPath();
            ctx.arc(input.x, input.y, 15, 0, Math.PI * 2);
            ctx.fill();

            ctx.fillStyle = '#f1f5f9';
            ctx.font = '14px sans-serif';
            ctx.textAlign = 'center';
            ctx.fillText(input.label, input.x, input.y + 5);
        });

        // 中心神经元
        const centerX = width/2;
        const centerY = height/2;

        ctx.fillStyle = '#8b5cf6';
        ctx.beginPath();
        ctx.arc(centerX, centerY, 40, 0, Math.PI * 2);
        ctx.fill();

        ctx.fillStyle = '#ffffff';
        ctx.font = '20px sans-serif';
        ctx.textAlign = 'center';
        ctx.fillText('Σ', centerX, centerY + 7);

        // 连接线和权重
        inputs.forEach((input, i) => {
            if (i < 3) {
                ctx.strokeStyle = '#6366f1';
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.moveTo(input.x + 15, input.y);
                ctx.lineTo(centerX - 40, centerY);
                ctx.stroke();

                // 权重标签
                const midX = (input.x + centerX) / 2;
                const midY = (input.y + centerY) / 2;
                ctx.fillStyle = '#f1f5f9';
                ctx.font = '12px sans-serif';
                ctx.fillText(`w${i+1}`, midX, midY - 5);
            }
        });

        // 输出
        ctx.strokeStyle = '#22c55e';
        ctx.lineWidth = 3;
        ctx.beginPath();
        ctx.moveTo(centerX + 40, centerY);
        ctx.lineTo(width - 50, centerY);
        ctx.stroke();

        // 输出节点
        ctx.fillStyle = '#22c55e';
        ctx.beginPath();
        ctx.arc(width - 50, centerY, 20, 0, Math.PI * 2);
        ctx.fill();

        ctx.fillStyle = '#ffffff';
        ctx.font = '16px sans-serif';
        ctx.fillText('y', width - 50, centerY + 5);

        // 激活函数标签
        ctx.fillStyle = '#f1f5f9';
        ctx.font = '12px sans-serif';
        ctx.fillText('sign()', centerX + 80, centerY - 10);
    }

    // 初始化生物神经元和人工神经元可视化
    drawBioNeuron();
    drawArtificialNeuron();

    // 3D超平面可视化
    class HyperplaneVisualizer {
        constructor() {
            this.canvas = document.getElementById('hyperplane-canvas');
            this.ctx = this.canvas.getContext('2d');
            this.width = this.canvas.width;
            this.height = this.canvas.height;

            this.rotation = 45;
            this.elevation = 30;
            this.animating = false;

            this.bindControls();
            this.draw();
        }

        bindControls() {
            const rotationSlider = document.getElementById('rotation-slider');
            const elevationSlider = document.getElementById('elevation-slider');

            rotationSlider.addEventListener('input', (e) => {
                this.rotation = parseFloat(e.target.value);
                document.getElementById('rotation-value').textContent = this.rotation + '°';
                this.draw();
            });

            elevationSlider.addEventListener('input', (e) => {
                this.elevation = parseFloat(e.target.value);
                document.getElementById('elevation-value').textContent = this.elevation + '°';
                this.draw();
            });
        }

        project3D(x, y, z) {
            // 简单的3D投影
            const rotRad = this.rotation * Math.PI / 180;
            const eleRad = this.elevation * Math.PI / 180;

            // 旋转
            const x1 = x * Math.cos(rotRad) - y * Math.sin(rotRad);
            const y1 = x * Math.sin(rotRad) + y * Math.cos(rotRad);
            const z1 = z;

            // 俯仰
            const y2 = y1 * Math.cos(eleRad) - z1 * Math.sin(eleRad);
            const z2 = y1 * Math.sin(eleRad) + z1 * Math.cos(eleRad);

            // 投影到2D
            const scale = 200;
            const px = this.width/2 + x1 * scale;
            const py = this.height/2 - y2 * scale;

            return {x: px, y: py, z: z2};
        }

        draw() {
            this.ctx.clearRect(0, 0, this.width, this.height);

            // 绘制坐标轴
            this.drawAxes();

            // 绘制数据点
            this.drawDataPoints();

            // 绘制超平面
            this.drawHyperplane();
        }

        drawAxes() {
            this.ctx.strokeStyle = 'rgba(255, 255, 255, 0.3)';
            this.ctx.lineWidth = 1;

            // X轴
            const xStart = this.project3D(-1, 0, 0);
            const xEnd = this.project3D(1, 0, 0);
            this.ctx.beginPath();
            this.ctx.moveTo(xStart.x, xStart.y);
            this.ctx.lineTo(xEnd.x, xEnd.y);
            this.ctx.stroke();

            // Y轴
            const yStart = this.project3D(0, -1, 0);
            const yEnd = this.project3D(0, 1, 0);
            this.ctx.beginPath();
            this.ctx.moveTo(yStart.x, yStart.y);
            this.ctx.lineTo(yEnd.x, yEnd.y);
            this.ctx.stroke();

            // Z轴
            const zStart = this.project3D(0, 0, -1);
            const zEnd = this.project3D(0, 0, 1);
            this.ctx.beginPath();
            this.ctx.moveTo(zStart.x, zStart.y);
            this.ctx.lineTo(zEnd.x, zEnd.y);
            this.ctx.stroke();

            // 轴标签
            this.ctx.fillStyle = '#f1f5f9';
            this.ctx.font = '14px sans-serif';
            this.ctx.fillText('X', xEnd.x + 10, xEnd.y);
            this.ctx.fillText('Y', yEnd.x + 10, yEnd.y);
            this.ctx.fillText('Z', zEnd.x + 10, zEnd.y);
        }

        drawDataPoints() {
            // 示例数据点
            const points = [
                // 正类
                {x: 0.5, y: 0.5, z: 0.3, class: 1},
                {x: 0.4, y: 0.6, z: 0.4, class: 1},
                {x: 0.6, y: 0.4, z: 0.5, class: 1},
                // 负类
                {x: -0.5, y: -0.5, z: -0.3, class: -1},
                {x: -0.4, y: -0.6, z: -0.4, class: -1},
                {x: -0.6, y: -0.4, z: -0.5, class: -1}
            ];

            points.forEach(point => {
                const p = this.project3D(point.x, point.y, point.z);

                this.ctx.fillStyle = point.class === 1 ? '#3b82f6' : '#ef4444';
                this.ctx.beginPath();
                this.ctx.arc(p.x, p.y, 8, 0, Math.PI * 2);
                this.ctx.fill();

                this.ctx.strokeStyle = '#1f2937';
                this.ctx.lineWidth = 2;
                this.ctx.stroke();
            });
        }

        drawHyperplane() {
            // 绘制超平面网格
            this.ctx.strokeStyle = 'rgba(34, 197, 94, 0.3)';
            this.ctx.lineWidth = 1;

            const steps = 10;
            for (let i = 0; i <= steps; i++) {
                const t = (i / steps) * 2 - 1;

                // 横线
                this.ctx.beginPath();
                for (let j = 0; j <= steps; j++) {
                    const s = (j / steps) * 2 - 1;
                    const z = -0.5 * t - 0.5 * s;  // 平面方程: 0.5x + 0.5y + z = 0
                    const p = this.project3D(t, s, z);

                    if (j === 0) {
                        this.ctx.moveTo(p.x, p.y);
                    } else {
                        this.ctx.lineTo(p.x, p.y);
                    }
                }
                this.ctx.stroke();

                // 纵线
                this.ctx.beginPath();
                for (let j = 0; j <= steps; j++) {
                    const s = (j / steps) * 2 - 1;
                    const z = -0.5 * s - 0.5 * t;
                    const p = this.project3D(s, t, z);

                    if (j === 0) {
                        this.ctx.moveTo(p.x, p.y);
                    } else {
                        this.ctx.lineTo(p.x, p.y);
                    }
                }
                this.ctx.stroke();
            }

            // 绘制法向量
            const origin = this.project3D(0, 0, 0);
            const normal = this.project3D(0.3, 0.3, 0.6);  // 归一化的法向量

            this.ctx.strokeStyle = '#8b5cf6';
            this.ctx.lineWidth = 3;
            this.ctx.beginPath();
            this.ctx.moveTo(origin.x, origin.y);
            this.ctx.lineTo(normal.x, normal.y);
            this.ctx.stroke();

            // 箭头
            this.ctx.fillStyle = '#8b5cf6';
            this.ctx.beginPath();
            this.ctx.arc(normal.x, normal.y, 5, 0, Math.PI * 2);
            this.ctx.fill();
        }
    }

    const hyperplaneViz = new HyperplaneVisualizer();

    function toggleAnimation() {
        hyperplaneViz.animating = !hyperplaneViz.animating;
        document.getElementById('animation-toggle').textContent =
            hyperplaneViz.animating ? '⏸️ 暂停动画' : '▶️ 播放动画';

        if (hyperplaneViz.animating) {
            const animate = () => {
                if (!hyperplaneViz.animating) return;

                hyperplaneViz.rotation = (hyperplaneViz.rotation + 1) % 360;
                document.getElementById('rotation-slider').value = hyperplaneViz.rotation;
                document.getElementById('rotation-value').textContent = hyperplaneViz.rotation + '°';

                hyperplaneViz.draw();
                requestAnimationFrame(animate);
            };
            animate();
        }
    }

    // 训练可视化
    class TrainingVisualizer {
        constructor() {
            this.canvas = document.getElementById('training-canvas');
            this.ctx = this.canvas.getContext('2d');
            this.width = this.canvas.width;
            this.height = this.canvas.height;

            this.training = false;
            this.epoch = 0;
            this.currentSample = -1;

            // 简单的训练数据
            this.data = [
                {x: [0.2, 0.3], y: -1},
                {x: [0.8, 0.9], y: 1},
                {x: [0.3, 0.2], y: -1},
                {x: [0.7, 0.8], y: 1},
                {x: [0.1, 0.4], y: -1},
                {x: [0.9, 0.7], y: 1}
            ];

            // 感知机参数
            this.w = [0.1, 0.1];
            this.b = 0;
            this.lr = 0.1;

            this.draw();
        }

        predict(x) {
            const z = this.w[0] * x[0] + this.w[1] * x[1] + this.b;
            return z >= 0 ? 1 : -1;
        }

        update(x, y) {
            const pred = this.predict(x);
            if (pred !== y) {
                this.w[0] += this.lr * y * x[0];
                this.w[1] += this.lr * y * x[1];
                this.b += this.lr * y;
                return true;
            }
            return false;
        }

        draw() {
            this.ctx.clearRect(0, 0, this.width, this.height);

            // 绘制决策边界
            this.drawDecisionBoundary();

            // 绘制数据点
            this.data.forEach((point, idx) => {
                const x = point.x[0] * this.width;
                const y = this.height - point.x[1] * this.height;

                this.ctx.fillStyle = point.y === 1 ? '#3b82f6' : '#ef4444';
                this.ctx.strokeStyle = idx === this.currentSample ? '#fbbf24' : '#1f2937';
                this.ctx.lineWidth = idx === this.currentSample ? 4 : 2;

                this.ctx.beginPath();
                this.ctx.arc(x, y, 12, 0, Math.PI * 2);
                this.ctx.fill();
                this.ctx.stroke();
            });

            // 绘制权重向量
            this.drawWeightVector();
        }

        drawDecisionBoundary() {
            if (this.w[1] === 0) return;

            this.ctx.strokeStyle = '#22c55e';
            this.ctx.lineWidth = 3;
            this.ctx.beginPath();

            const x1 = 0;
            const y1 = -(this.w[0] * 0 + this.b) / this.w[1];

            const x2 = 1;
            const y2 = -(this.w[0] * 1 + this.b) / this.w[1];

            this.ctx.moveTo(x1 * this.width, this.height - y1 * this.height);
            this.ctx.lineTo(x2 * this.width, this.height - y2 * this.height);
            this.ctx.stroke();
        }

        drawWeightVector() {
            const centerX = this.width / 2;
            const centerY = this.height / 2;
            const scale = 100;

            this.ctx.strokeStyle = '#8b5cf6';
            this.ctx.lineWidth = 2;
            this.ctx.beginPath();
            this.ctx.moveTo(centerX, centerY);
            this.ctx.lineTo(
                centerX + this.w[0] * scale,
                centerY - this.w[1] * scale
            );
            this.ctx.stroke();

            // 箭头
            this.ctx.fillStyle = '#8b5cf6';
            this.ctx.beginPath();
            this.ctx.arc(
                centerX + this.w[0] * scale,
                centerY - this.w[1] * scale,
                5, 0, Math.PI * 2
            );
            this.ctx.fill();
        }

        step() {
            this.currentSample = (this.currentSample + 1) % this.data.length;

            if (this.currentSample === 0) {
                this.epoch++;
            }

            const sample = this.data[this.currentSample];
            const updated = this.update(sample.x, sample.y);

            // 更新显示
            document.getElementById('epoch-count').textContent = this.epoch;
            document.getElementById('current-sample').textContent =
                `(${sample.x[0].toFixed(2)}, ${sample.x[1].toFixed(2)})`;
            document.getElementById('prediction').textContent =
                this.predict(sample.x) === 1 ? '+1' : '-1';

            if (updated) {
                document.getElementById('update-info').textContent =
                    `更新了权重: w=[${this.w[0].toFixed(3)}, ${this.w[1].toFixed(3)}], b=${this.b.toFixed(3)}`;
            } else {
                document.getElementById('update-info').textContent = '正确分类，无需更新';
            }

            this.draw();

            // 检查是否收敛
            let allCorrect = true;
            for (const sample of this.data) {
                if (this.predict(sample.x) !== sample.y) {
                    allCorrect = false;
                    break;
                }
            }

            if (allCorrect) {
                this.training = false;
                document.getElementById('train-button').textContent = '▶️ 开始训练';
                showNotification('🎉 感知机已收敛！');
            }
        }
    }

    const trainingViz = new TrainingVisualizer();

    function startTraining() {
        trainingViz.training = !trainingViz.training;
        document.getElementById('train-button').textContent =
            trainingViz.training ? '⏸️ 暂停' : '▶️ 开始训练';

        if (trainingViz.training) {
            const speed = parseInt(document.getElementById('speed-slider').value);

            const trainLoop = () => {
                if (!trainingViz.training) return;

                trainingViz.step();

                if (trainingViz.training) {
                    setTimeout(trainLoop, speed);
                }
            };

            trainLoop();
        }
    }

    function stepTraining() {
        trainingViz.training = false;
        document.getElementById('train-button').textContent = '▶️ 开始训练';
        trainingViz.step();
    }

    // 鸢尾花数据集演示
    const irisData = {
        setosa: [
            [5.1, 3.5, 1.4, 0.2], [4.9, 3.0, 1.4, 0.2], [4.7, 3.2, 1.3, 0.2],
            [4.6, 3.1, 1.5, 0.2], [5.0, 3.6, 1.4, 0.2], [5.4, 3.9, 1.7, 0.4]
        ],
        versicolor: [
            [7.0, 3.2, 4.7, 1.4], [6.4, 3.2, 4.5, 1.5], [6.9, 3.1, 4.9, 1.5],
            [5.5, 2.3, 4.0, 1.3], [6.5, 2.8, 4.6, 1.5], [5.7, 2.8, 4.5, 1.3]
        ],
        virginica: [
            [6.3, 3.3, 6.0, 2.5], [5.8, 2.7, 5.1, 1.9], [7.1, 3.0, 5.9, 2.1],
            [6.3, 2.9, 5.6, 1.8], [6.5, 3.0, 5.8, 2.2], [7.6, 3.0, 6.6, 2.1]
        ]
    };

    function trainIrisPerceptron() {
        const canvas = document.getElementById('iris-canvas');
        const ctx = canvas.getContext('2d');
        const width = canvas.width;
        const height = canvas.height;

        // 获取选择的特征和类别
        const xFeature = parseInt(document.getElementById('x-feature').value);
        const yFeature = parseInt(document.getElementById('y-feature').value);

        const classes = [];
        if (document.getElementById('class-0').checked) classes.push(0);
        if (document.getElementById('class-1').checked) classes.push(1);
        if (document.getElementById('class-2').checked) classes.push(2);

        if (classes.length !== 2) {
            showNotification('请选择恰好两个类别进行二分类！');
            return;
        }

        // 准备数据
        const data = [];
        const labels = [];
        const classNames = ['setosa', 'versicolor', 'virginica'];
        const colors = ['#ef4444', '#22c55e', '#3b82f6'];

        classes.forEach(classIdx => {
            const className = classNames[classIdx];
            const samples = irisData[className];

            samples.forEach(sample => {
                data.push([sample[xFeature], sample[yFeature]]);
                labels.push(classIdx === classes[0] ? -1 : 1);
            });
        });

        // 归一化数据
        const xMin = Math.min(...data.map(d => d[0]));
        const xMax = Math.max(...data.map(d => d[0]));
        const yMin = Math.min(...data.map(d => d[1]));
        const yMax = Math.max(...data.map(d => d[1]));

        const normalizedData = data.map(d => [
            (d[0] - xMin) / (xMax - xMin),
            (d[1] - yMin) / (yMax - yMin)
        ]);

        // 训练感知机
        let w = [0, 0];
        let b = 0;
        const lr = 0.1;
        let epoch = 0;
        const maxEpochs = 100;

        const trainStep = () => {
            let errors = 0;

            for (let i = 0; i < normalizedData.length; i++) {
                const x = normalizedData[i];
                const y = labels[i];
                const pred = Math.sign(w[0] * x[0] + w[1] * x[1] + b) || 1;

                if (pred !== y) {
                    w[0] += lr * y * x[0];
                    w[1] += lr * y * x[1];
                    b += lr * y;
                    errors++;
                }
            }

            // 绘制
            ctx.clearRect(0, 0, width, height);

            // 绘制决策边界
            if (w[1] !== 0) {
                ctx.strokeStyle = '#8b5cf6';
                ctx.lineWidth = 3;
                ctx.beginPath();

                const x1 = 0;
                const y1 = -(w[0] * x1 + b) / w[1];
                const x2 = 1;
                const y2 = -(w[0] * x2 + b) / w[1];

                ctx.moveTo(x1 * width, height - y1 * height);
                ctx.lineTo(x2 * width, height - y2 * height);
                ctx.stroke();
            }

            // 绘制数据点
            normalizedData.forEach((point, idx) => {
                const x = point[0] * width;
                const y = height - point[1] * height;
                const label = labels[idx];

                ctx.fillStyle = label === -1 ? colors[classes[0]] : colors[classes[1]];
                ctx.beginPath();
                ctx.arc(x, y, 8, 0, Math.PI * 2);
                ctx.fill();

                ctx.strokeStyle = '#1f2937';
                ctx.lineWidth = 2;
                ctx.stroke();
            });

            // 显示结果
            document.getElementById('iris-results').style.display = 'block';
            document.getElementById('iris-stats').innerHTML = `
            <p>训练轮次：${epoch}</p>
            <p>错误数：${errors}</p>
            <p>准确率：${((1 - errors/normalizedData.length) * 100).toFixed(1)}%</p>
            <p>权重：w = [${w[0].toFixed(3)}, ${w[1].toFixed(3)}], b = ${b.toFixed(3)}</p>
        `;

            epoch++;

            if (errors > 0 && epoch < maxEpochs) {
                setTimeout(trainStep, 100);
            } else {
                if (errors === 0) {
                    showNotification('🎉 鸢尾花数据集训练成功！');
                } else {
                    showNotification('⚠️ 达到最大轮次，可能数据不是线性可分的。');
                }
            }
        };

        trainStep();
    }

    // 隐藏导航栏
    let lastScrollTop = 0;
    const navHeader = document.querySelector('.nav-header');

    window.addEventListener('scroll', () => {
        const scrollTop = window.pageYOffset || document.documentElement.scrollTop;

        if (scrollTop > lastScrollTop && scrollTop > 100) {
            // 向下滚动
            navHeader.classList.add('hidden');
        } else {
            // 向上滚动
            navHeader.classList.remove('hidden');
        }

        lastScrollTop = scrollTop;
    });

    // 多层感知机解决XOR演示
    function drawMLPXOR() {
        const canvas = document.getElementById('mlp-xor-canvas');
        if (!canvas) return;

        const ctx = canvas.getContext('2d');
        const width = canvas.width;
        const height = canvas.height;

        // 清空画布
        ctx.clearRect(0, 0, width, height);

        // 绘制网络结构
        const layers = [
            {neurons: 2, x: width * 0.2, label: '输入层'},
            {neurons: 2, x: width * 0.5, label: '隐藏层'},
            {neurons: 1, x: width * 0.8, label: '输出层'}
        ];

        const neuronRadius = 25;
        const verticalSpacing = 80;

        // 计算神经元位置
        const positions = [];
        layers.forEach((layer, layerIdx) => {
            const layerPositions = [];
            const startY = (height - (layer.neurons - 1) * verticalSpacing) / 2;

            for (let i = 0; i < layer.neurons; i++) {
                layerPositions.push({
                    x: layer.x,
                    y: startY + i * verticalSpacing
                });
            }
            positions.push(layerPositions);
        });

        // 绘制连接
        for (let l = 0; l < positions.length - 1; l++) {
            const currentLayer = positions[l];
            const nextLayer = positions[l + 1];

            currentLayer.forEach(fromNeuron => {
                nextLayer.forEach(toNeuron => {
                    ctx.strokeStyle = 'rgba(139, 92, 246, 0.3)';
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.moveTo(fromNeuron.x + neuronRadius, fromNeuron.y);
                    ctx.lineTo(toNeuron.x - neuronRadius, toNeuron.y);
                    ctx.stroke();
                });
            });
        }

        // 绘制神经元
        positions.forEach((layer, layerIdx) => {
            layer.forEach(neuron => {
                // 神经元圆圈
                ctx.fillStyle = layerIdx === 0 ? '#3b82f6' :
                    layerIdx === 1 ? '#8b5cf6' : '#22c55e';
                ctx.beginPath();
                ctx.arc(neuron.x, neuron.y, neuronRadius, 0, Math.PI * 2);
                ctx.fill();

                ctx.strokeStyle = '#1f2937';
                ctx.lineWidth = 2;
                ctx.stroke();
            });
        });

        // 绘制层标签
        ctx.fillStyle = '#f1f5f9';
        ctx.font = '14px sans-serif';
        ctx.textAlign = 'center';

        layers.forEach((layer, idx) => {
            ctx.fillText(layer.label, layer.x, height - 20);
        });

        // 绘制XOR真值表
        const tableX = width * 0.1;
        const tableY = height * 0.7;

        ctx.fillStyle = 'rgba(255, 255, 255, 0.1)';
        ctx.fillRect(tableX - 10, tableY - 10, 100, 80);

        ctx.fillStyle = '#f1f5f9';
        ctx.font = '12px monospace';
        ctx.textAlign = 'left';

        const xorTable = [
            'XOR真值表:',
            '0 XOR 0 = 0',
            '0 XOR 1 = 1',
            '1 XOR 0 = 1',
            '1 XOR 1 = 0'
        ];

        xorTable.forEach((line, idx) => {
            ctx.fillText(line, tableX, tableY + idx * 15);
        });

        // 解释文字
        ctx.fillStyle = '#10b981';
        ctx.font = '16px sans-serif';
        ctx.textAlign = 'center';
        ctx.fillText('✓ 两层网络可以解决XOR!', width / 2, 30);
    }

    // 初始化MLP XOR演示
    setTimeout(drawMLPXOR, 1000);

    // 学习进度跟踪
    function trackSectionView(sectionId) {
        completedSections.add(sectionId);
        checkAchievements();

        // 保存进度到本地存储
        const progress = Array.from(completedSections);
        localStorage.setItem('chapter1_progress', JSON.stringify(progress));
    }

    // 恢复学习进度
    const savedProgress = localStorage.getItem('chapter1_progress');
    if (savedProgress) {
        const progress = JSON.parse(savedProgress);
        progress.forEach(section => completedSections.add(section));
        checkAchievements();
    }

    // 监听章节进入视图
    const sectionObserver = new IntersectionObserver((entries) => {
        entries.forEach(entry => {
            if (entry.isIntersecting) {
                const sectionId = entry.target.id;
                if (sectionId) {
                    trackSectionView(sectionId);
                }
            }
        });
    }, {
        threshold: 0.5
    });

    sections.forEach(section => {
        sectionObserver.observe(section);
    });

    console.log('🚀 感知机章节加载完成！祝学习愉快！');
</script>
</body>
</html>