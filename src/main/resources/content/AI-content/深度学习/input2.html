<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>第8章：长短期记忆网络LSTM - 让神经网络学会遗忘与记忆 | 深度学习序列建模</title>
    <meta name="description" content="通过交互式可视化深入理解LSTM的精妙设计，一步步推导门控机制的数学原理">

    <!-- 外部依赖 - 按需加载 -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/github-dark.min.css">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.9/katex.min.css">

    <style>
        /* ===== CSS变量定义 ===== */
        :root {
            --primary-gradient: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            --lstm-gradient: linear-gradient(135deg, #a8edea 0%, #fed6e3 100%);
            --gru-gradient: linear-gradient(135deg, #fdbb2d 0%, #22c1c3 100%);
            --forget-gradient: linear-gradient(135deg, #f093fb 0%, #f5576c 100%);
            --input-gradient: linear-gradient(135deg, #4facfe 0%, #00f2fe 100%);
            --output-gradient: linear-gradient(135deg, #43e97b 0%, #38f9d7 100%);
            --cell-gradient: linear-gradient(135deg, #fa709a 0%, #fee140 100%);
            --bg-dark: #0f172a;
            --bg-section: #1e293b;
            --text-primary: #f1f5f9;
            --text-secondary: #cbd5e1;
            --text-muted: #94a3b8;
            --accent-red: #ef4444;
            --accent-green: #22c55e;
            --accent-blue: #3b82f6;
            --accent-yellow: #fbbf24;
            --accent-purple: #8b5cf6;
            --accent-pink: #ec4899;
            --accent-orange: #f97316;
            --accent-cyan: #06b6d4;
            --border-color: rgba(255, 255, 255, 0.1);
            --shadow-lg: 0 10px 40px rgba(0, 0, 0, 0.3);
            --animation-duration: 0.3s;
            --content-max-width: 1400px;
        }

        /* ===== 全局样式 ===== */
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        html {
            scroll-behavior: smooth;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
            background: var(--bg-dark);
            color: var(--text-primary);
            line-height: 1.6;
            overflow-x: hidden;
            position: relative;
        }

        /* ===== 背景动画 ===== */
        .bg-animation {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            overflow: hidden;
            z-index: -1;
        }

        .bg-particle {
            position: absolute;
            width: 2px;
            height: 2px;
            background: rgba(168, 237, 234, 0.5);
            border-radius: 50%;
            animation: float 20s infinite linear;
        }

        @keyframes float {
            from {
                transform: translateY(100vh) translateX(0);
            }
            to {
                transform: translateY(-100px) translateX(100px);
            }
        }

        /* ===== 布局组件 ===== */
        .container {
            max-width: var(--content-max-width);
            margin: 0 auto;
            padding: 0 1rem;
            position: relative;
        }

        /* ===== 导航栏 ===== */
        .nav-header {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            background: rgba(15, 23, 42, 0.95);
            backdrop-filter: blur(10px);
            z-index: 1000;
            border-bottom: 1px solid var(--border-color);
            transition: transform 0.3s ease;
        }

        .nav-header.hidden {
            transform: translateY(-100%);
        }

        .nav-content {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 1rem 0;
        }

        .nav-title h1 {
            font-size: 1.25rem;
            font-weight: 600;
            background: var(--lstm-gradient);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
        }

        .nav-progress {
            position: absolute;
            bottom: 0;
            left: 0;
            right: 0;
            height: 3px;
            background: rgba(255, 255, 255, 0.1);
        }

        .progress-bar {
            height: 100%;
            background: var(--lstm-gradient);
            width: 0%;
            transition: width 0.3s ease;
        }

        /* ===== 侧边导航 ===== */
        .sidebar {
            position: fixed;
            left: -300px;
            top: 60px;
            bottom: 0;
            width: 300px;
            background: var(--bg-section);
            border-right: 1px solid var(--border-color);
            padding: 2rem;
            overflow-y: auto;
            transition: transform 0.3s ease;
            z-index: 999;
        }

        .sidebar.open {
            transform: translateX(300px);
        }

        .toc-item {
            display: block;
            padding: 0.75rem 1rem;
            color: var(--text-secondary);
            text-decoration: none;
            border-radius: 0.5rem;
            transition: all var(--animation-duration) ease;
            margin-bottom: 0.25rem;
        }

        .toc-item:hover {
            background: rgba(255, 255, 255, 0.05);
            color: var(--text-primary);
            transform: translateX(4px);
        }

        .toc-item.active {
            background: var(--lstm-gradient);
            color: #0f172a;
        }

        /* ===== 主内容 ===== */
        main {
            margin-top: 80px;
            padding-bottom: 4rem;
        }

        /* ===== 章节标题 ===== */
        .chapter-hero {
            background: var(--lstm-gradient);
            padding: 6rem 0;
            margin-bottom: 3rem;
            position: relative;
            overflow: hidden;
        }

        .chapter-hero::before {
            content: '';
            position: absolute;
            top: -50%;
            left: -50%;
            width: 200%;
            height: 200%;
            background: radial-gradient(circle, rgba(255, 255, 255, 0.2) 0%, transparent 70%);
            animation: pulse 10s ease-in-out infinite;
        }

        @keyframes pulse {
            0%, 100% { transform: scale(1) rotate(0deg); }
            50% { transform: scale(1.1) rotate(180deg); }
        }

        .chapter-hero-content {
            position: relative;
            z-index: 2;
            text-align: center;
            color: #0f172a;
        }

        .chapter-hero h1 {
            font-size: 3.5rem;
            margin-bottom: 1rem;
            animation: fadeInUp 0.8s ease;
        }

        @keyframes fadeInUp {
            from {
                opacity: 0;
                transform: translateY(20px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        /* ===== 三栏公式解释布局 ===== */
        .formula-explainer {
            display: grid;
            grid-template-columns: 1fr 1.5fr 1fr;
            gap: 2rem;
            background: var(--bg-section);
            border-radius: 1rem;
            padding: 2.5rem;
            margin: 2rem 0;
            border: 1px solid var(--border-color);
            box-shadow: var(--shadow-lg);
            position: relative;
            overflow: hidden;
        }

        .formula-explainer::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            height: 4px;
            background: var(--lstm-gradient);
        }

        .formula-column {
            position: relative;
        }

        .formula-column h4 {
            color: var(--accent-cyan);
            margin-bottom: 1rem;
            font-size: 0.9rem;
            text-transform: uppercase;
            letter-spacing: 0.05em;
        }

        /* 公式列 */
        .formula-math {
            font-size: 1.3rem;
            text-align: center;
            padding: 2rem 1rem;
            background: rgba(255, 255, 255, 0.05);
            border-radius: 0.5rem;
            position: relative;
            overflow: hidden;
        }

        .formula-math::before {
            content: '∑';
            position: absolute;
            top: -20px;
            right: -10px;
            font-size: 4rem;
            opacity: 0.05;
            font-family: 'Times New Roman', serif;
        }

        /* 矩阵可视化列 - 优化左右布局 */
        .matrix-visual {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            padding: 1rem;
        }

        .matrix-operation {
            display: flex;
            align-items: center;
            gap: 1rem;
            flex-wrap: wrap;
            justify-content: center;
            margin: 1rem 0;
        }

        .matrix-visual svg {
            filter: drop-shadow(0 4px 15px rgba(0, 0, 0, 0.3));
        }

        /* 释义列 */
        .formula-meaning {
            padding: 1rem;
            font-size: 0.95rem;
            line-height: 1.8;
        }

        .meaning-item {
            padding: 0.75rem;
            margin-bottom: 0.5rem;
            border-radius: 0.5rem;
            transition: all 0.3s ease;
            border: 1px solid transparent;
            cursor: pointer;
        }

        .meaning-item:hover {
            background: rgba(255, 255, 255, 0.05);
            border-color: var(--border-color);
        }

        /* 高亮交互样式 */
        .highlight-target {
            transition: all 0.3s ease;
            cursor: pointer;
            padding: 0.2rem 0.4rem;
            border-radius: 0.25rem;
            position: relative;
        }

        .highlight-target:hover {
            background: rgba(255, 255, 255, 0.1);
            transform: scale(1.05);
        }

        .highlight-active {
            background: rgba(79, 172, 254, 0.3) !important;
            color: var(--accent-blue) !important;
            font-weight: bold;
            box-shadow: 0 0 20px rgba(79, 172, 254, 0.5);
        }

        /* 实时联动高亮 */
        .live-highlight {
            animation: pulse-highlight 1s ease-in-out;
        }

        @keyframes pulse-highlight {
            0%, 100% {
                background: rgba(79, 172, 254, 0.3);
                transform: scale(1);
            }
            50% {
                background: rgba(79, 172, 254, 0.6);
                transform: scale(1.05);
            }
        }

        /* ===== 交互式矩阵可视化 ===== */
        .matrix-container {
            position: relative;
            display: inline-block;
            margin: 0.5rem;
            transition: all 0.3s ease;
        }

        .matrix-bracket {
            position: absolute;
            width: 10px;
            height: 100%;
            border: 2px solid var(--text-secondary);
        }

        .matrix-bracket.left {
            left: -10px;
            border-right: none;
            border-radius: 5px 0 0 5px;
        }

        .matrix-bracket.right {
            right: -10px;
            border-left: none;
            border-radius: 0 5px 5px 0;
        }

        .matrix-grid {
            display: grid;
            gap: 0.5rem;
            padding: 0.5rem;
            background: rgba(255, 255, 255, 0.02);
            border-radius: 0.5rem;
        }

        .matrix-cell {
            width: 3.5rem;
            height: 2.5rem;
            display: flex;
            align-items: center;
            justify-content: center;
            background: rgba(255, 255, 255, 0.05);
            border: 1px solid var(--border-color);
            border-radius: 0.25rem;
            font-size: 0.85rem;
            transition: all 0.3s ease;
            position: relative;
            overflow: hidden;
        }

        .matrix-cell::before {
            content: '';
            position: absolute;
            top: 50%;
            left: 50%;
            width: 0;
            height: 0;
            background: rgba(79, 172, 254, 0.3);
            border-radius: 50%;
            transform: translate(-50%, -50%);
            transition: all 0.5s ease;
        }

        .matrix-cell:hover {
            background: rgba(79, 172, 254, 0.2);
            transform: scale(1.1);
            z-index: 10;
            box-shadow: 0 0 20px rgba(79, 172, 254, 0.5);
        }

        .matrix-cell:hover::before {
            width: 100px;
            height: 100px;
        }

        /* 运算符样式 */
        .operation-symbol {
            font-size: 2rem;
            color: var(--accent-cyan);
            font-weight: bold;
            padding: 0 1rem;
        }

        /* ===== 交互式LSTM单元图 ===== */
        .lstm-unit-interactive {
            width: 100%;
            max-width: 1000px;
            margin: 3rem auto;
            position: relative;
            background: linear-gradient(135deg, rgba(168, 237, 234, 0.1), rgba(254, 214, 227, 0.05));
            border-radius: 2rem;
            padding: 3rem;
            border: 2px solid var(--border-color);
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.3);
        }

        #lstmCanvas {
            width: 100%;
            height: 500px;
            cursor: grab;
        }

        #lstmCanvas:active {
            cursor: grabbing;
        }

        /* ===== 思考引导卡片 ===== */
        .think-card {
            background: linear-gradient(135deg, rgba(139, 92, 246, 0.15), rgba(236, 72, 153, 0.1));
            border: 2px solid rgba(139, 92, 246, 0.3);
            border-radius: 1rem;
            padding: 2rem;
            margin: 2rem 0;
            position: relative;
            overflow: hidden;
        }

        .think-card::before {
            content: '🤔';
            position: absolute;
            top: -20px;
            right: 20px;
            font-size: 5rem;
            opacity: 0.1;
            transform: rotate(15deg);
        }

        .think-card h3 {
            color: var(--accent-purple);
            margin-bottom: 1rem;
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        .think-options {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 1rem;
            margin-top: 1.5rem;
        }

        .think-option {
            background: rgba(255, 255, 255, 0.05);
            padding: 1rem;
            border-radius: 0.5rem;
            border: 1px solid var(--border-color);
            cursor: pointer;
            transition: all 0.3s ease;
            position: relative;
            overflow: hidden;
        }

        .think-option:hover {
            transform: translateY(-3px);
            box-shadow: 0 10px 30px rgba(139, 92, 246, 0.3);
            border-color: var(--accent-purple);
        }

        .think-option.selected {
            background: rgba(139, 92, 246, 0.2);
            border-color: var(--accent-purple);
        }

        .think-feedback {
            margin-top: 1.5rem;
            padding: 1rem;
            border-radius: 0.5rem;
            display: none;
        }

        .think-feedback.show {
            display: block;
            animation: fadeIn 0.5s ease;
        }

        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(10px); }
            to { opacity: 1; transform: translateY(0); }
        }

        /* ===== 实时计算演示 ===== */
        .live-demo {
            background: linear-gradient(135deg, rgba(6, 182, 212, 0.1), rgba(59, 130, 246, 0.05));
            border-radius: 1.5rem;
            padding: 3rem;
            margin: 2rem 0;
            border: 2px solid var(--accent-cyan);
            position: relative;
            overflow: hidden;
        }

        .live-demo::before {
            content: '';
            position: absolute;
            top: -50%;
            right: -50%;
            width: 100%;
            height: 100%;
            background: radial-gradient(circle, rgba(6, 182, 212, 0.2), transparent);
            animation: rotate 20s linear infinite;
        }

        @keyframes rotate {
            from { transform: rotate(0deg); }
            to { transform: rotate(360deg); }
        }

        .live-demo-content {
            position: relative;
            z-index: 2;
        }

        .input-group {
            display: flex;
            gap: 1rem;
            margin-bottom: 2rem;
        }

        .live-demo-input {
            flex: 1;
            padding: 1rem 1.5rem;
            background: rgba(255, 255, 255, 0.05);
            border: 2px solid var(--border-color);
            border-radius: 0.75rem;
            color: var(--text-primary);
            font-size: 1.1rem;
            transition: all 0.3s ease;
        }

        .live-demo-input:focus {
            outline: none;
            border-color: var(--accent-cyan);
            background: rgba(255, 255, 255, 0.08);
            box-shadow: 0 0 30px rgba(6, 182, 212, 0.3);
        }

        /* 实时输入预测 */
        .prediction-preview {
            position: absolute;
            background: var(--bg-dark);
            border: 1px solid var(--border-color);
            border-radius: 0.5rem;
            padding: 0.5rem 1rem;
            font-size: 0.9rem;
            z-index: 1000;
            display: none;
            max-width: 200px;
        }

        .analyze-btn {
            padding: 1rem 2rem;
            background: var(--accent-cyan);
            color: white;
            border: none;
            border-radius: 0.75rem;
            font-size: 1.1rem;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
            position: relative;
            overflow: hidden;
        }

        .analyze-btn::before {
            content: '';
            position: absolute;
            top: 50%;
            left: 50%;
            width: 0;
            height: 0;
            background: rgba(255, 255, 255, 0.3);
            border-radius: 50%;
            transform: translate(-50%, -50%);
            transition: all 0.6s ease;
        }

        .analyze-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 10px 30px rgba(6, 182, 212, 0.4);
        }

        .analyze-btn:active::before {
            width: 300px;
            height: 300px;
        }

        .live-demo-output {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 2rem;
            margin-top: 2rem;
        }

        .demo-result-card {
            background: rgba(255, 255, 255, 0.05);
            padding: 2rem;
            border-radius: 1rem;
            border: 1px solid var(--border-color);
            transition: all 0.3s ease;
            position: relative;
            overflow: hidden;
        }

        .demo-result-card::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            height: 3px;
            background: var(--lstm-gradient);
            transform: scaleX(0);
            transition: transform 0.5s ease;
        }

        .demo-result-card:hover::before {
            transform: scaleX(1);
        }

        /* ===== 双模型对比展示 ===== */
        .model-comparison {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 2rem;
            margin: 2rem 0;
        }

        .model-demo {
            background: var(--bg-section);
            border-radius: 1rem;
            padding: 2rem;
            border: 1px solid var(--border-color);
            position: relative;
        }

        .model-demo.rnn {
            border-color: var(--accent-red);
        }

        .model-demo.lstm {
            border-color: var(--accent-green);
        }

        .model-demo::before {
            content: attr(data-model);
            position: absolute;
            top: -10px;
            left: 20px;
            background: var(--bg-dark);
            padding: 0.25rem 1rem;
            border-radius: 0.5rem;
            font-size: 0.8rem;
            font-weight: bold;
        }

        .model-demo.rnn::before {
            color: var(--accent-red);
        }

        .model-demo.lstm::before {
            color: var(--accent-green);
        }

        /* ===== 步进动画控制 ===== */
        .step-animation {
            background: var(--bg-section);
            border-radius: 1rem;
            padding: 2.5rem;
            margin: 2rem 0;
            border: 1px solid var(--border-color);
            position: relative;
        }

        .step-indicator {
            display: flex;
            justify-content: center;
            gap: 1rem;
            margin-bottom: 2rem;
        }

        .step-dot {
            width: 12px;
            height: 12px;
            border-radius: 50%;
            background: var(--text-muted);
            transition: all 0.3s ease;
            cursor: pointer;
        }

        .step-dot.active {
            width: 30px;
            border-radius: 6px;
            background: var(--accent-cyan);
        }

        .step-content {
            min-height: 400px;
            display: flex;
            align-items: center;
            justify-content: center;
            position: relative;
        }

        .step-visual {
            position: absolute;
            width: 100%;
            height: 100%;
            display: flex;
            align-items: center;
            justify-content: center;
            opacity: 0;
            transform: translateX(20px);
            transition: all 0.5s ease;
        }

        .step-visual.active {
            opacity: 1;
            transform: translateX(0);
        }

        /* ===== 代码分层展示 ===== */
        .code-layers {
            margin: 2rem 0;
            background: var(--bg-section);
            border-radius: 1rem;
            overflow: hidden;
            border: 1px solid var(--border-color);
            box-shadow: var(--shadow-lg);
        }

        .code-layer-tabs {
            display: flex;
            background: rgba(255, 255, 255, 0.02);
            border-bottom: 2px solid var(--border-color);
        }

        .code-layer-tab {
            flex: 1;
            padding: 1rem 1.5rem;
            background: transparent;
            border: none;
            color: var(--text-secondary);
            cursor: pointer;
            transition: all 0.3s ease;
            font-weight: 500;
            position: relative;
        }

        .code-layer-tab::after {
            content: '';
            position: absolute;
            bottom: -2px;
            left: 0;
            right: 0;
            height: 2px;
            background: var(--accent-blue);
            transform: scaleX(0);
            transition: transform 0.3s ease;
        }

        .code-layer-tab.active {
            color: var(--text-primary);
            background: rgba(255, 255, 255, 0.05);
        }

        .code-layer-tab.active::after {
            transform: scaleX(1);
        }

        .code-layer-content {
            display: none;
            padding: 2rem;
            max-height: 600px;
            overflow-y: auto;
        }

        .code-layer-content.active {
            display: block;
            animation: fadeIn 0.5s ease;
        }

        /* ===== 比较表格 ===== */
        .comparison-table {
            background: rgba(255, 255, 255, 0.05);
            border-radius: 1rem;
            overflow: hidden;
            margin: 2rem 0;
            box-shadow: var(--shadow-lg);
        }

        .comparison-table table {
            width: 100%;
            border-collapse: collapse;
        }

        .comparison-table th {
            background: var(--lstm-gradient);
            color: #0f172a;
            padding: 1.25rem;
            text-align: left;
            font-weight: 600;
        }

        .comparison-table td {
            padding: 1.25rem;
            border-bottom: 1px solid var(--border-color);
            transition: all 0.3s ease;
        }

        .comparison-table tr:hover td {
            background: rgba(255, 255, 255, 0.05);
            transform: translateX(5px);
        }

        /* ===== LSTM vs GRU 对比区域 ===== */
        .architecture-comparison {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 3rem;
            margin: 3rem 0;
            padding: 3rem;
            background: linear-gradient(135deg, rgba(168, 237, 234, 0.1), rgba(253, 187, 45, 0.1));
            border-radius: 2rem;
            border: 2px solid var(--border-color);
        }

        .architecture-card {
            background: rgba(255, 255, 255, 0.05);
            border-radius: 1.5rem;
            padding: 2.5rem;
            position: relative;
            overflow: hidden;
        }

        .architecture-card::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            height: 4px;
        }

        .architecture-card.lstm::before {
            background: var(--lstm-gradient);
        }

        .architecture-card.gru::before {
            background: var(--gru-gradient);
        }

        .architecture-title {
            display: flex;
            align-items: center;
            gap: 1rem;
            margin-bottom: 2rem;
        }

        .architecture-icon {
            width: 60px;
            height: 60px;
            border-radius: 15px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 2rem;
            color: white;
        }

        .architecture-icon.lstm {
            background: var(--lstm-gradient);
        }

        .architecture-icon.gru {
            background: var(--gru-gradient);
        }

        /* ===== 数学推导动画 ===== */
        .math-derivation {
            background: linear-gradient(135deg, rgba(139, 92, 246, 0.1), rgba(236, 72, 153, 0.05));
            border-radius: 1rem;
            padding: 2.5rem;
            margin: 2rem 0;
            position: relative;
            overflow: hidden;
        }

        .derivation-step {
            background: rgba(255, 255, 255, 0.05);
            border-left: 4px solid var(--accent-cyan);
            padding: 1.5rem;
            margin: 1.5rem 0;
            border-radius: 0 0.5rem 0.5rem 0;
            position: relative;
            opacity: 0;
            transform: translateX(-20px);
            animation: slideIn 0.5s ease forwards;
        }

        .derivation-step:nth-child(1) { animation-delay: 0.1s; }
        .derivation-step:nth-child(2) { animation-delay: 0.2s; }
        .derivation-step:nth-child(3) { animation-delay: 0.3s; }
        .derivation-step:nth-child(4) { animation-delay: 0.4s; }

        @keyframes slideIn {
            to {
                opacity: 1;
                transform: translateX(0);
            }
        }

        .derivation-step-number {
            position: absolute;
            left: -20px;
            top: 1.5rem;
            width: 40px;
            height: 40px;
            background: var(--accent-cyan);
            color: white;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: bold;
            box-shadow: 0 4px 15px rgba(6, 182, 212, 0.4);
        }

        /* ===== 实践练习 ===== */
        .practice-section {
            background: linear-gradient(135deg, rgba(251, 191, 36, 0.1), rgba(245, 158, 11, 0.05));
            border-radius: 1rem;
            padding: 2.5rem;
            margin: 2rem 0;
            border: 2px solid rgba(251, 191, 36, 0.3);
        }

        .practice-item {
            background: rgba(255, 255, 255, 0.05);
            padding: 1.5rem;
            border-radius: 0.75rem;
            margin-bottom: 1.5rem;
            cursor: pointer;
            transition: all 0.3s ease;
            position: relative;
            overflow: hidden;
        }

        .practice-item:hover {
            transform: translateY(-3px);
            box-shadow: 0 10px 30px rgba(251, 191, 36, 0.3);
        }

        .practice-solution {
            max-height: 0;
            overflow: hidden;
            transition: max-height 0.5s ease;
            margin-top: 1rem;
        }

        .practice-item.open .practice-solution {
            max-height: 1000px;
        }

        /* ===== 可视化图表 ===== */
        .visualization-container {
            background: rgba(15, 23, 42, 0.8);
            border: 1px solid var(--border-color);
            border-radius: 1rem;
            padding: 2rem;
            margin: 2rem 0;
            position: relative;
            overflow: hidden;
        }

        .viz-controls {
            display: flex;
            gap: 1rem;
            align-items: center;
            margin-bottom: 2rem;
            flex-wrap: wrap;
        }

        /* ===== 按钮样式 ===== */
        .btn {
            padding: 0.75rem 1.5rem;
            border-radius: 0.5rem;
            border: none;
            font-weight: 500;
            cursor: pointer;
            transition: all var(--animation-duration) ease;
            display: inline-flex;
            align-items: center;
            gap: 0.5rem;
            text-decoration: none;
            position: relative;
            overflow: hidden;
        }

        .btn::before {
            content: '';
            position: absolute;
            top: 50%;
            left: 50%;
            width: 0;
            height: 0;
            background: rgba(255, 255, 255, 0.2);
            border-radius: 50%;
            transform: translate(-50%, -50%);
            transition: all 0.6s ease;
        }

        .btn:active::before {
            width: 300px;
            height: 300px;
        }

        .btn-primary {
            background: var(--lstm-gradient);
            color: #0f172a;
        }

        .btn-primary:hover {
            transform: translateY(-2px);
            box-shadow: 0 10px 20px rgba(168, 237, 234, 0.3);
        }

        .btn-secondary {
            background: transparent;
            color: var(--text-primary);
            border: 1px solid var(--border-color);
        }

        .btn-secondary:hover {
            background: rgba(255, 255, 255, 0.1);
            border-color: var(--accent-cyan);
        }

        /* ===== 提示框 ===== */
        .tip {
            display: flex;
            gap: 1rem;
            padding: 1.5rem;
            border-radius: 0.75rem;
            margin: 1.5rem 0;
            position: relative;
            overflow: hidden;
        }

        .tip::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            bottom: 0;
            width: 4px;
        }

        .tip.info {
            background: rgba(79, 172, 254, 0.1);
            border: 1px solid rgba(79, 172, 254, 0.3);
        }

        .tip.info::before {
            background: var(--accent-blue);
        }

        .tip.warning {
            background: rgba(251, 191, 36, 0.1);
            border: 1px solid rgba(251, 191, 36, 0.3);
        }

        .tip.warning::before {
            background: var(--accent-yellow);
        }

        .tip.success {
            background: rgba(34, 197, 94, 0.1);
            border: 1px solid rgba(34, 197, 94, 0.3);
        }

        .tip.success::before {
            background: var(--accent-green);
        }

        /* ===== 术语提示 ===== */
        .term-tooltip {
            position: relative;
            border-bottom: 2px dotted var(--accent-cyan);
            cursor: help;
            display: inline-block;
        }

        .term-tooltip .tooltip-content {
            position: absolute;
            bottom: 100%;
            left: 50%;
            transform: translateX(-50%);
            background: var(--bg-dark);
            border: 1px solid var(--border-color);
            border-radius: 0.5rem;
            padding: 1rem 1.5rem;
            font-size: 0.9rem;
            white-space: nowrap;
            opacity: 0;
            pointer-events: none;
            transition: all 0.3s ease;
            z-index: 1000;
            box-shadow: var(--shadow-lg);
            margin-bottom: 0.5rem;
        }

        .term-tooltip:hover .tooltip-content {
            opacity: 1;
            transform: translateX(-50%) translateY(-5px);
        }

        /* ===== 折叠内容 ===== */
        .collapsible {
            margin: 1rem 0;
        }

        .collapsible-header {
            background: rgba(255, 255, 255, 0.05);
            padding: 1rem 1.5rem;
            border-radius: 0.5rem;
            cursor: pointer;
            display: flex;
            justify-content: space-between;
            align-items: center;
            transition: all 0.3s ease;
            user-select: none;
        }

        .collapsible-header:hover {
            background: rgba(255, 255, 255, 0.08);
        }

        .collapsible-content {
            max-height: 0;
            overflow: hidden;
            transition: max-height 0.5s ease;
        }

        .collapsible.open .collapsible-content {
            max-height: 2000px;
            padding: 1rem 1.5rem;
        }

        .collapsible-icon {
            transition: transform 0.3s ease;
        }

        .collapsible.open .collapsible-icon {
            transform: rotate(180deg);
        }

        /* ===== 卡片样式 ===== */
        .section-card {
            background: var(--bg-section);
            border-radius: 1rem;
            padding: 3rem;
            margin-bottom: 2rem;
            border: 1px solid var(--border-color);
            box-shadow: var(--shadow-lg);
            position: relative;
            overflow: hidden;
        }

        .section-card::before {
            content: '';
            position: absolute;
            top: -100px;
            right: -100px;
            width: 200px;
            height: 200px;
            background: radial-gradient(circle, rgba(168, 237, 234, 0.1), transparent);
            border-radius: 50%;
        }

        /* ===== 故事卡片 ===== */
        .story-card {
            background: linear-gradient(135deg, rgba(168, 237, 234, 0.15), rgba(254, 214, 227, 0.1));
            border-radius: 1rem;
            padding: 2.5rem;
            margin-bottom: 2rem;
            border: 2px solid rgba(168, 237, 234, 0.2);
            position: relative;
            overflow: hidden;
        }

        .story-card::before {
            content: '📖';
            position: absolute;
            top: -20px;
            right: -20px;
            font-size: 5rem;
            opacity: 0.1;
            transform: rotate(15deg);
        }

        /* ===== 对话框 ===== */
        .dialogue-box {
            background: rgba(255, 255, 255, 0.05);
            border-left: 4px solid var(--accent-pink);
            padding: 1.5rem;
            margin: 1.5rem 0;
            border-radius: 0 0.5rem 0.5rem 0;
            position: relative;
            opacity: 0;
            transform: translateX(-20px);
            animation: slideInLeft 0.5s ease forwards;
        }

        .dialogue-box:nth-child(1) { animation-delay: 0.1s; }
        .dialogue-box:nth-child(2) { animation-delay: 0.3s; }
        .dialogue-box:nth-child(3) { animation-delay: 0.5s; }

        @keyframes slideInLeft {
            to {
                opacity: 1;
                transform: translateX(0);
            }
        }

        .dialogue-box .speaker {
            font-weight: bold;
            color: var(--accent-pink);
            margin-bottom: 0.5rem;
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        .dialogue-box .avatar {
            width: 40px;
            height: 40px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 1.5rem;
        }

        /* ===== 概念网格 ===== */
        .concept-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 1.5rem;
            margin: 2rem 0;
        }

        .concept-card {
            padding: 2rem;
            border-radius: 0.75rem;
            transition: all var(--animation-duration) ease;
            cursor: pointer;
            position: relative;
            overflow: hidden;
        }

        .concept-card::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            height: 4px;
            transform: scaleX(0);
            transition: transform var(--animation-duration) ease;
        }

        .concept-card:hover {
            transform: translateY(-5px);
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.2);
        }

        .concept-card:hover::before {
            transform: scaleX(1);
        }

        .concept-card.forget {
            background: rgba(240, 147, 251, 0.1);
            border: 1px solid rgba(240, 147, 251, 0.3);
        }

        .concept-card.forget::before {
            background: var(--forget-gradient);
        }

        .concept-card.input {
            background: rgba(79, 172, 254, 0.1);
            border: 1px solid rgba(79, 172, 254, 0.3);
        }

        .concept-card.input::before {
            background: var(--input-gradient);
        }

        .concept-card.output {
            background: rgba(67, 233, 123, 0.1);
            border: 1px solid rgba(67, 233, 123, 0.3);
        }

        .concept-card.output::before {
            background: var(--output-gradient);
        }

        .concept-card.cell {
            background: rgba(250, 112, 154, 0.1);
            border: 1px solid rgba(250, 112, 154, 0.3);
        }

        .concept-card.cell::before {
            background: var(--cell-gradient);
        }

        /* ===== 时间线 ===== */
        .timeline {
            position: relative;
            padding: 2rem 0;
        }

        .timeline::before {
            content: '';
            position: absolute;
            left: 50%;
            top: 0;
            bottom: 0;
            width: 2px;
            background: var(--border-color);
        }

        .timeline-item {
            position: relative;
            margin: 2rem 0;
            padding: 0 2rem;
            opacity: 0;
            animation: fadeIn 0.5s ease forwards;
        }

        .timeline-item:nth-child(1) { animation-delay: 0.1s; }
        .timeline-item:nth-child(2) { animation-delay: 0.2s; }
        .timeline-item:nth-child(3) { animation-delay: 0.3s; }
        .timeline-item:nth-child(4) { animation-delay: 0.4s; }

        .timeline-item:nth-child(odd) {
            text-align: right;
            padding-right: 50%;
        }

        .timeline-item:nth-child(even) {
            padding-left: 50%;
        }

        .timeline-dot {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 20px;
            height: 20px;
            background: var(--lstm-gradient);
            border-radius: 50%;
            z-index: 1;
            box-shadow: 0 0 20px rgba(168, 237, 234, 0.5);
        }

        /* ===== 音乐键盘 ===== */
        .piano-keyboard {
            display: flex;
            gap: 2px;
            margin: 2rem 0;
            padding: 1rem;
            background: rgba(255, 255, 255, 0.05);
            border-radius: 1rem;
            justify-content: center;
            flex-wrap: wrap;
        }

        .piano-key {
            width: 40px;
            height: 120px;
            background: white;
            border: 1px solid #ccc;
            border-radius: 0 0 8px 8px;
            cursor: pointer;
            position: relative;
            transition: all 0.1s ease;
            user-select: none;
        }

        .piano-key:hover {
            background: #f0f0f0;
            transform: translateY(2px);
        }

        .piano-key.active {
            background: var(--accent-cyan);
            transform: translateY(3px);
            box-shadow: 0 0 20px rgba(6, 182, 212, 0.5);
        }

        .piano-key.black {
            width: 25px;
            height: 80px;
            background: #333;
            margin: 0 -12.5px;
            z-index: 2;
            border-radius: 0 0 4px 4px;
        }

        .piano-key.black:hover {
            background: #555;
        }

        .piano-key.black.active {
            background: var(--accent-orange);
        }

        /* ===== 响应式设计 ===== */
        @media (max-width: 1024px) {
            .formula-explainer {
                grid-template-columns: 1fr;
                gap: 1.5rem;
            }

            .live-demo-output {
                grid-template-columns: 1fr;
            }

            .concept-grid {
                grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            }

            .model-comparison {
                grid-template-columns: 1fr;
            }

            .architecture-comparison {
                grid-template-columns: 1fr;
                gap: 2rem;
            }
        }

        @media (max-width: 768px) {
            .chapter-hero h1 {
                font-size: 2.5rem;
            }

            .section-card {
                padding: 2rem;
            }

            .timeline-item:nth-child(odd),
            .timeline-item:nth-child(even) {
                padding-left: 3rem;
                padding-right: 1rem;
                text-align: left;
            }

            .timeline::before {
                left: 20px;
            }

            .timeline-dot {
                left: 20px;
            }

            .code-layer-tabs {
                flex-direction: column;
            }

            .code-layer-tab {
                border-bottom: 1px solid var(--border-color);
            }

            .matrix-operation {
                flex-direction: column;
                align-items: center;
            }

            .piano-keyboard {
                overflow-x: auto;
                justify-content: flex-start;
            }
        }

        /* ===== 加载动画 ===== */
        .loading {
            display: inline-block;
            width: 20px;
            height: 20px;
            border: 3px solid rgba(255, 255, 255, 0.3);
            border-radius: 50%;
            border-top-color: var(--accent-pink);
            animation: spin 1s ease-in-out infinite;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        /* ===== 懒加载占位符 ===== */
        .lazy-placeholder {
            background: rgba(255, 255, 255, 0.05);
            border-radius: 1rem;
            padding: 3rem;
            text-align: center;
            color: var(--text-secondary);
            position: relative;
            overflow: hidden;
        }

        .lazy-placeholder::before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.1), transparent);
            animation: shimmer 2s infinite;
        }

        @keyframes shimmer {
            0% { left: -100%; }
            100% { left: 100%; }
        }

        /* ===== 滚动条美化 ===== */
        ::-webkit-scrollbar {
            width: 10px;
            height: 10px;
        }

        ::-webkit-scrollbar-track {
            background: var(--bg-dark);
        }

        ::-webkit-scrollbar-thumb {
            background: var(--text-muted);
            border-radius: 5px;
        }

        ::-webkit-scrollbar-thumb:hover {
            background: var(--text-secondary);
        }

        /* ===== 打印样式 ===== */
        @media print {
            body {
                background: white;
                color: black;
            }

            .nav-header,
            .sidebar,
            .btn,
            .viz-controls {
                display: none;
            }
        }
    </style>
</head>
<body>

<!-- 背景动画 -->
<div class="bg-animation" id="bgAnimation"></div>

<!-- 导航栏 -->
<nav class="nav-header" role="navigation" aria-label="主导航">
    <div class="container">
        <div class="nav-content">
            <div class="nav-title">
                <button id="toggle-sidebar" class="btn btn-secondary" style="margin-right: 1rem;" aria-label="切换侧边栏">
                    <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                        <line x1="3" y1="12" x2="21" y2="12"></line>
                        <line x1="3" y1="6" x2="21" y2="6"></line>
                        <line x1="3" y1="18" x2="21" y2="18"></line>
                    </svg>
                </button>
                <h1>第8章：长短期记忆网络LSTM</h1>
            </div>
            <div style="display: flex; gap: 1rem;">
                <button id="toggle-animations" class="btn btn-secondary" aria-label="切换动画">
                    <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                        <circle cx="12" cy="12" r="10"></circle>
                        <path d="M10 8l6 4-6 4V8z"></path>
                    </svg>
                </button>
                <button id="toggle-theme" class="btn btn-secondary" aria-label="切换主题">
                    <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                    </svg>
                </button>
            </div>
        </div>
        <div class="nav-progress">
            <div class="progress-bar" id="progress-bar"></div>
        </div>
    </div>
</nav>

<!-- 侧边栏 -->
<aside class="sidebar" id="sidebar">
    <h3 style="margin-bottom: 1.5rem; color: var(--accent-pink);">📚 目录导航</h3>
    <nav>
        <a href="#intro" class="toc-item active">序言：记忆的艺术</a>
        <a href="#problem" class="toc-item">RNN的困境</a>
        <a href="#solution" class="toc-item">解决思路推导</a>
        <a href="#forget-gate" class="toc-item">遗忘门的诞生</a>
        <a href="#input-gate" class="toc-item">输入门的设计</a>
        <a href="#cell-state" class="toc-item">细胞状态更新</a>
        <a href="#output-gate" class="toc-item">输出门的控制</a>
        <a href="#complete-lstm" class="toc-item">LSTM完整结构</a>
        <a href="#lstm-vs-gru" class="toc-item">LSTM vs GRU对比</a>
        <a href="#math-proof" class="toc-item">数学证明</a>
        <a href="#implementation" class="toc-item">从零实现LSTM</a>
        <a href="#visualization" class="toc-item">可视化理解</a>
        <a href="#practice" class="toc-item">实战应用</a>
        <a href="#exercises" class="toc-item">练习与思考</a>
        <a href="#summary" class="toc-item">总结与展望</a>
    </nav>
</aside>

<!-- 主内容 -->
<main>
    <!-- 章节标题 -->
    <section class="chapter-hero">
        <div class="container">
            <div class="chapter-hero-content">
                <h1>长短期记忆网络：让AI学会遗忘与记忆</h1>
                <p style="font-size: 1.5rem; margin-bottom: 2rem;">深入理解LSTM的精妙设计，一步步推导门控机制的数学原理</p>
                <div style="display: flex; justify-content: center; gap: 1.5rem; flex-wrap: wrap;">
                    <span style="background: rgba(0, 0, 0, 0.1); padding: 0.75rem 1.5rem; border-radius: 30px; display: flex; align-items: center; gap: 0.5rem;">
                        <span style="font-size: 1.3rem;">🚪</span> 门控机制
                    </span>
                    <span style="background: rgba(0, 0, 0, 0.1); padding: 0.75rem 1.5rem; border-radius: 30px; display: flex; align-items: center; gap: 0.5rem;">
                        <span style="font-size: 1.3rem;">🧠</span> 长期记忆
                    </span>
                    <span style="background: rgba(0, 0, 0, 0.1); padding: 0.75rem 1.5rem; border-radius: 30px; display: flex; align-items: center; gap: 0.5rem;">
                        <span style="font-size: 1.3rem;">📐</span> 数学推导
                    </span>
                </div>
            </div>
        </div>
    </section>

    <div class="container">

        <!-- 一句话理解 -->
        <section class="section-card">
            <h2 style="color: var(--accent-pink); margin-bottom: 2rem; text-align: center; font-size: 2.5rem;">
                💡 一句话理解LSTM
            </h2>
            <p style="font-size: 1.5rem; text-align: center; line-height: 2; margin-bottom: 3rem;">
                LSTM就像一个精密的记忆管理系统，<br>
                通过三个门控制信息的流动：<br>
                <span style="color: #f5576c; font-weight: bold;">遗忘门</span>决定忘记什么，
                <span style="color: #4facfe; font-weight: bold;">输入门</span>决定记住什么，
                <span style="color: #43e97b; font-weight: bold;">输出门</span>决定输出什么。
            </p>

            <!-- 四个核心概念 -->
            <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 2rem;">
                <div style="text-align: center;">
                    <div style="
                        width: 100px;
                        height: 100px;
                        margin: 0 auto 1rem;
                        background: var(--forget-gradient);
                        border-radius: 25px;
                        display: flex;
                        align-items: center;
                        justify-content: center;
                        font-size: 3rem;
                        color: white;
                        box-shadow: 0 10px 30px rgba(240, 147, 251, 0.4);
                        transition: all 0.3s ease;
                        cursor: pointer;
                    " onmouseover="this.style.transform='translateY(-5px) scale(1.05)'" onmouseout="this.style.transform='translateY(0) scale(1)'">
                        🚪
                    </div>
                    <h4 style="color: white; margin-bottom: 0.5rem; font-size: 1.2rem;">遗忘门</h4>
                    <p style="color: #94a3b8; font-size: 0.95rem; line-height: 1.5;">
                        选择性遗忘<br>过滤无用信息
                    </p>
                </div>

                <div style="text-align: center;">
                    <div style="
                        width: 100px;
                        height: 100px;
                        margin: 0 auto 1rem;
                        background: var(--input-gradient);
                        border-radius: 25px;
                        display: flex;
                        align-items: center;
                        justify-content: center;
                        font-size: 3rem;
                        color: white;
                        box-shadow: 0 10px 30px rgba(79, 172, 254, 0.4);
                        transition: all 0.3s ease;
                        cursor: pointer;
                    " onmouseover="this.style.transform='translateY(-5px) scale(1.05)'" onmouseout="this.style.transform='translateY(0) scale(1)'">
                        ➕
                    </div>
                    <h4 style="color: white; margin-bottom: 0.5rem; font-size: 1.2rem;">输入门</h4>
                    <p style="color: #94a3b8; font-size: 0.95rem; line-height: 1.5;">
                        选择性记忆<br>存储重要信息
                    </p>
                </div>

                <div style="text-align: center;">
                    <div style="
                        width: 100px;
                        height: 100px;
                        margin: 0 auto 1rem;
                        background: var(--output-gradient);
                        border-radius: 25px;
                        display: flex;
                        align-items: center;
                        justify-content: center;
                        font-size: 3rem;
                        color: white;
                        box-shadow: 0 10px 30px rgba(67, 233, 123, 0.4);
                        transition: all 0.3s ease;
                        cursor: pointer;
                    " onmouseover="this.style.transform='translateY(-5px) scale(1.05)'" onmouseout="this.style.transform='translateY(0) scale(1)'">
                        📤
                    </div>
                    <h4 style="color: white; margin-bottom: 0.5rem; font-size: 1.2rem;">输出门</h4>
                    <p style="color: #94a3b8; font-size: 0.95rem; line-height: 1.5;">
                        控制输出<br>决定展示什么
                    </p>
                </div>

                <div style="text-align: center;">
                    <div style="
                        width: 100px;
                        height: 100px;
                        margin: 0 auto 1rem;
                        background: var(--cell-gradient);
                        border-radius: 25px;
                        display: flex;
                        align-items: center;
                        justify-content: center;
                        font-size: 3rem;
                        color: white;
                        box-shadow: 0 10px 30px rgba(250, 112, 154, 0.4);
                        transition: all 0.3s ease;
                        cursor: pointer;
                    " onmouseover="this.style.transform='translateY(-5px) scale(1.05)'" onmouseout="this.style.transform='translateY(0) scale(1)'">
                        📦
                    </div>
                    <h4 style="color: white; margin-bottom: 0.5rem; font-size: 1.2rem;">细胞状态</h4>
                    <p style="color: #94a3b8; font-size: 0.95rem; line-height: 1.5;">
                        长期记忆<br>信息高速通道
                    </p>
                </div>
            </div>
        </section>

        <!-- 思考引导：为什么需要LSTM -->
        <section class="think-card">
            <h3>🤔 思考时刻：为什么RNN会失败？</h3>
            <p>在学习LSTM之前，让我们先思考一个问题：为什么传统RNN在处理长序列时会失败？</p>

            <div class="think-options">
                <div class="think-option" data-answer="a">
                    A. 计算速度太慢
                </div>
                <div class="think-option" data-answer="b">
                    B. 梯度消失/爆炸
                </div>
                <div class="think-option" data-answer="c">
                    C. 参数太多
                </div>
                <div class="think-option" data-answer="d">
                    D. 激活函数选择不当
                </div>
            </div>

            <div class="think-feedback" id="thinkFeedback1">
                <!-- 反馈内容将动态插入 -->
            </div>
        </section>

        <!-- 序言：记忆的艺术 -->
        <section id="intro" class="section-card">
            <div class="story-card">
                <h2 style="color: var(--accent-pink); margin-bottom: 1.5rem;">📖 序言：记忆的艺术</h2>

                <p style="font-size: 1.2rem; line-height: 1.8; margin-bottom: 2rem;">
                    1997年，德国慕尼黑工业大学的一个研究小组正在为一个棘手的问题苦恼...
                </p>

                <div class="dialogue-box">
                    <div class="speaker">
                        <div class="avatar" style="background: linear-gradient(135deg, #f093fb, #f5576c);">👨‍🔬</div>
                        Sepp Hochreiter：
                    </div>
                    <div>"我们的RNN在处理长句子时总是失败。比如这个德语句子，动词在最后，但网络在处理到动词时已经忘记了主语是什么！"</div>
                </div>

                <div class="dialogue-box">
                    <div class="speaker">
                        <div class="avatar" style="background: linear-gradient(135deg, #4facfe, #00f2fe);">👨‍🏫</div>
                        Jürgen Schmidhuber：
                    </div>
                    <div>"问题的根源是梯度消失。当误差信号通过时间反向传播时，它会指数级衰减。我们需要一种新的架构！"</div>
                </div>

                <div class="dialogue-box">
                    <div class="speaker">
                        <div class="avatar" style="background: linear-gradient(135deg, #fa709a, #fee140);">🧑‍🔬</div>
                        研究生：
                    </div>
                    <div>"如果我们能创建一条'高速公路'，让梯度可以无损地传播呢？就像...就像水管中的阀门，可以控制水流！"</div>
                </div>

                <div class="timeline mt-4">
                    <div class="timeline-item">
                        <div class="timeline-dot"></div>
                        <h4 style="color: var(--accent-pink);">1991年</h4>
                        <p>Hochreiter发现梯度消失问题</p>
                    </div>
                    <div class="timeline-item">
                        <div class="timeline-dot"></div>
                        <h4 style="color: var(--accent-blue);">1997年</h4>
                        <p>LSTM论文发表，引入门控机制</p>
                    </div>
                    <div class="timeline-item">
                        <div class="timeline-dot"></div>
                        <h4 style="color: var(--accent-green);">2000年</h4>
                        <p>添加遗忘门，LSTM结构完善</p>
                    </div>
                    <div class="timeline-item">
                        <div class="timeline-dot"></div>
                        <h4 style="color: var(--accent-orange);">2014年</h4>
                        <p>LSTM在机器翻译中大放异彩</p>
                    </div>
                </div>
            </div>
        </section>

        <!-- RNN的困境 -->
        <section id="problem" class="section-card">
            <h2 style="color: var(--accent-red); margin-bottom: 2rem;">💔 RNN的困境：为什么需要LSTM？</h2>

            <!-- 双模型对比 -->
            <div class="model-comparison">
                <div class="model-demo rnn" data-model="传统RNN">
                    <h3 style="color: var(--accent-red); margin-bottom: 1rem;">传统RNN的长距离依赖测试</h3>
                    <div style="background: rgba(239, 68, 68, 0.1); padding: 1.5rem; border-radius: 0.5rem; margin-bottom: 1rem;">
                        <p style="margin-bottom: 1rem;">测试句子：<em>"我在<strong>法国</strong>长大，接受了优质的教育，学习了语言和文化，现在我能说一口流利的<strong>____</strong>。"</em></p>
                        <div id="rnnPrediction" style="font-size: 1.2rem; color: var(--accent-red);">
                            RNN预测：<span style="background: rgba(239, 68, 68, 0.2); padding: 0.25rem 0.5rem; border-radius: 0.25rem;">中文</span> ❌
                        </div>
                        <p style="margin-top: 1rem; font-size: 0.9rem; color: var(--text-secondary);">
                            RNN忘记了句子开头的"法国"信息
                        </p>
                    </div>
                </div>

                <div class="model-demo lstm" data-model="LSTM网络">
                    <h3 style="color: var(--accent-green); margin-bottom: 1rem;">LSTM的长距离依赖测试</h3>
                    <div style="background: rgba(34, 197, 94, 0.1); padding: 1.5rem; border-radius: 0.5rem; margin-bottom: 1rem;">
                        <p style="margin-bottom: 1rem;">同样句子：<em>"我在<strong>法国</strong>长大，接受了优质的教育，学习了语言和文化，现在我能说一口流利的<strong>____</strong>。"</em></p>
                        <div id="lstmPrediction" style="font-size: 1.2rem; color: var(--accent-green);">
                            LSTM预测：<span style="background: rgba(34, 197, 94, 0.2); padding: 0.25rem 0.5rem; border-radius: 0.25rem;">法语</span> ✅
                        </div>
                        <p style="margin-top: 1rem; font-size: 0.9rem; color: var(--text-secondary);">
                            LSTM成功记住了关键信息"法国"
                        </p>
                    </div>
                </div>
            </div>
            <div class="static-illustration">
                <h3 style="color: var(--accent-cyan); margin-bottom: 1.5rem;">梯度消失问题</h3>
                <div style="background: rgba(255, 255, 255, 0.05); padding: 2rem; border-radius: 0.5rem;">
                    <p style="font-size: 1.2rem; margin-bottom: 2rem;">
                        RNN在处理长序列时，梯度会指数级衰减：
                    </p>
                    <div style="display: flex; align-items: center; justify-content: center; gap: 2rem; flex-wrap: wrap;">
                        <div style="text-align: center;">
                            <div style="width: 80px; height: 80px; background: rgba(239, 68, 68, 1); border-radius: 50%; display: flex; align-items: center; justify-content: center; color: white; font-weight: bold;">
                                t=1<br>1.0
                            </div>
                            <p style="margin-top: 0.5rem;">初始梯度</p>
                        </div>
                        <span style="font-size: 2rem;">→</span>
                        <div style="text-align: center;">
                            <div style="width: 60px; height: 60px; background: rgba(239, 68, 68, 0.5); border-radius: 50%; display: flex; align-items: center; justify-content: center; color: white; font-size: 0.9rem;">
                                t=10<br>0.1
                            </div>
                            <p style="margin-top: 0.5rem;">衰减90%</p>
                        </div>
                        <span style="font-size: 2rem;">→</span>
                        <div style="text-align: center;">
                            <div style="width: 40px; height: 40px; background: rgba(239, 68, 68, 0.2); border-radius: 50%; display: flex; align-items: center; justify-content: center; color: white; font-size: 0.8rem;">
                                t=50<br>≈0
                            </div>
                            <p style="margin-top: 0.5rem;">几乎消失</p>
                        </div>
                    </div>
                </div>
            </div>


            <div class="math-derivation">
                <h3 style="color: var(--accent-red); margin-bottom: 1.5rem;">🔬 梯度消失的数学本质</h3>

                <div class="derivation-step">
                    <div class="derivation-step-number">1</div>
                    <h4>RNN的梯度传播</h4>
                    <p>回忆RNN的隐藏状态更新公式：</p>
                    <div style="text-align: center; margin: 1rem 0; font-size: 1.2rem;">
                        $$\mathbf{h}_t = \tanh(\mathbf{W}_{hh} \mathbf{h}_{t-1} + \mathbf{W}_{xh} \mathbf{x}_t + \mathbf{b}_h)$$
                    </div>
                    <p>当我们计算损失对早期隐藏状态的梯度时：</p>
                    <div style="text-align: center; margin: 1rem 0; font-size: 1.2rem;">
                        $$\frac{\partial L}{\partial \mathbf{h}_1} = \frac{\partial L}{\partial \mathbf{h}_T} \cdot \prod_{t=2}^{T} \frac{\partial \mathbf{h}_t}{\partial \mathbf{h}_{t-1}}$$
                    </div>
                </div>

                <div class="derivation-step">
                    <div class="derivation-step-number">2</div>
                    <h4>问题的根源</h4>
                    <p>每一项梯度都包含tanh的导数：</p>
                    <div style="text-align: center; margin: 1rem 0; font-size: 1.2rem;">
                        $$\frac{\partial \mathbf{h}_t}{\partial \mathbf{h}_{t-1}} = \text{diag}(\tanh'(\mathbf{z}_t)) \cdot \mathbf{W}_{hh}$$
                    </div>
                    <p>由于 $\tanh'(x) = 1 - \tanh^2(x) \in (0, 1]$，梯度会指数级衰减！</p>
                </div>
            </div>

            <div class="tip warning">
                <span style="font-size: 1.5rem;">⚠️</span>
                <div>
                    <strong>关键洞察：</strong>当序列长度为100时，如果每步梯度衰减0.9，最终梯度只有初始的 $0.9^{100} \approx 10^{-5}$！
                    这就是为什么RNN无法学习长期依赖。
                </div>
            </div>
        </section>

        <!-- 解决思路推导 -->
        <section id="solution" class="section-card">
            <h2 style="color: var(--accent-blue); margin-bottom: 2rem;">💡 解决思路：如何设计更好的记忆机制？</h2>

            <div class="think-card">
                <h3>🧠 设计思考：如果你来设计，会怎么做？</h3>
                <p>在看LSTM的解决方案之前，让我们自己思考一下：如何让网络既能记住重要信息，又能忘记无用信息？</p>

                <div style="display: grid; gap: 1rem; margin-top: 1.5rem;">
                    <div style="background: rgba(255, 255, 255, 0.05); padding: 1.5rem; border-radius: 0.5rem;">
                        <h4 style="color: var(--accent-cyan); margin-bottom: 0.5rem;">💭 思考1：信息传递</h4>
                        <p>如何创建一条"高速公路"，让信息可以无损传递？</p>
                    </div>
                    <div style="background: rgba(255, 255, 255, 0.05); padding: 1.5rem; border-radius: 0.5rem;">
                        <h4 style="color: var(--accent-pink); margin-bottom: 0.5rem;">💭 思考2：选择机制</h4>
                        <p>如何让网络自己决定什么信息重要，什么信息可以丢弃？</p>
                    </div>
                    <div style="background: rgba(255, 255, 255, 0.05); padding: 1.5rem; border-radius: 0.5rem;">
                        <h4 style="color: var(--accent-green); margin-bottom: 0.5rem;">💭 思考3：控制方式</h4>
                        <p>用什么数学工具来实现这种选择性控制？</p>
                    </div>
                </div>
            </div>

            <div class="story-card" style="margin-top: 2rem;">
                <h3 style="color: var(--accent-blue); margin-bottom: 1.5rem;">🎯 LSTM的核心创新</h3>
                <p style="font-size: 1.1rem; line-height: 1.8;">
                    LSTM的天才之处在于引入了<strong>细胞状态（Cell State）</strong>作为信息的高速公路，
                    并通过<strong>门控机制（Gating Mechanism）</strong>来控制信息的流动。
                </p>

                <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 2rem; margin-top: 2rem;">
                    <div style="background: rgba(255, 255, 255, 0.05); padding: 1.5rem; border-radius: 0.75rem;">
                        <h4 style="color: var(--accent-cyan); margin-bottom: 1rem;">🛤️ 细胞状态</h4>
                        <ul style="margin-left: 1.5rem;">
                            <li>线性传播，避免非线性激活</li>
                            <li>梯度可以无损地反向传播</li>
                            <li>就像一条信息高速公路</li>
                        </ul>
                    </div>
                    <div style="background: rgba(255, 255, 255, 0.05); padding: 1.5rem; border-radius: 0.75rem;">
                        <h4 style="color: var(--accent-pink); margin-bottom: 1rem;">🚪 门控机制</h4>
                        <ul style="margin-left: 1.5rem;">
                            <li>使用Sigmoid函数作为开关</li>
                            <li>输出在[0,1]之间，像百分比</li>
                            <li>可学习的参数决定开关程度</li>
                        </ul>
                    </div>
                </div>
            </div>
        </section>

        <!-- 核心LSTM单元交互图 -->
        <section class="section-card">
            <h2 style="color: var(--accent-purple); margin-bottom: 2rem;">🎯 LSTM核心结构 - 交互式探索</h2>

            <div class="lstm-unit-interactive">
                <canvas id="lstmCanvas"></canvas>

                <div style="margin-top: 2rem; display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 1rem;">
                    <button class="btn btn-primary" onclick="window.lstmTutorial.highlightForgetGate()">
                        🗑️ 高亮遗忘门
                    </button>
                    <button class="btn btn-primary" onclick="window.lstmTutorial.highlightInputGate()">
                        ➕ 高亮输入门
                    </button>
                    <button class="btn btn-primary" onclick="window.lstmTutorial.highlightOutputGate()">
                        📤 高亮输出门
                    </button>
                    <button class="btn btn-primary" onclick="window.lstmTutorial.animateDataFlow()">
                        🌊 演示数据流
                    </button>
                </div>
            </div>

            <div id="gateDescription" style="margin-top: 2rem; padding: 2rem; background: rgba(255, 255, 255, 0.05); border-radius: 1rem; min-height: 150px;">
                <p style="text-align: center; color: var(--text-secondary); font-size: 1.1rem;">
                    👆 点击上方按钮，探索LSTM的各个组件
                </p>
            </div>
        </section>

        <!-- 遗忘门详细解析 - 完整版 -->
        <section id="forget-gate-detail" class="section-card">
            <h2 style="color: var(--accent-pink); margin-bottom: 2rem;">🚪 遗忘门详细解析</h2>

            <!-- 公式展示 -->
            <div class="formula-explainer">
                <div class="formula-column">
                    <h4>数学公式</h4>
                    <div class="formula-math">
                        <span class="highlight-target" data-symbol="f_t">f<sub>t</sub></span> =
                        <span class="highlight-target" data-symbol="sigma">σ</span>(<span class="highlight-target" data-symbol="W_f">W<sub>f</sub></span> ·
                        [<span class="highlight-target" data-symbol="h_t-1">h<sub>t-1</sub></span>,
                        <span class="highlight-target" data-symbol="x_t">x<sub>t</sub></span>] +
                        <span class="highlight-target" data-symbol="b_f">b<sub>f</sub></span>)
                    </div>
                </div>

                <div class="formula-column">
                    <h4>矩阵运算可视化</h4>
                    <div class="matrix-visual">
                        <div class="matrix-operation">
                            <svg width="200" height="150" viewBox="0 0 200 150">
                                <!-- 权重矩阵 -->
                                <rect x="10" y="20" width="60" height="80" fill="rgba(240, 147, 251, 0.2)" stroke="#f5576c" stroke-width="2"/>
                                <text x="40" y="15" text-anchor="middle" fill="#f5576c" font-size="12">W<tspan baseline-shift="sub" font-size="10">f</tspan></text>
                                <text x="40" y="60" text-anchor="middle" fill="#fff" font-size="10">128×228</text>

                                <!-- 输入向量 -->
                                <rect x="90" y="30" width="30" height="60" fill="rgba(79, 172, 254, 0.2)" stroke="#4facfe" stroke-width="2"/>
                                <text x="105" y="25" text-anchor="middle" fill="#4facfe" font-size="12">[h,x]</text>
                                <text x="105" y="60" text-anchor="middle" fill="#fff" font-size="10">228×1</text>

                                <!-- 结果 -->
                                <rect x="140" y="40" width="30" height="40" fill="rgba(67, 233, 123, 0.2)" stroke="#43e97b" stroke-width="2"/>
                                <text x="155" y="35" text-anchor="middle" fill="#43e97b" font-size="12">f<tspan baseline-shift="sub" font-size="10">t</tspan></text>
                                <text x="155" y="60" text-anchor="middle" fill="#fff" font-size="10">128×1</text>

                                <!-- 运算符号 -->
                                <text x="80" y="65" text-anchor="middle" fill="#fff" font-size="16">×</text>
                                <text x="130" y="65" text-anchor="middle" fill="#fff" font-size="16">=</text>
                            </svg>
                        </div>
                    </div>
                </div>

                <div class="formula-column">
                    <h4>含义解释</h4>
                    <div class="formula-meaning">
                        <div class="meaning-item">
                            <strong>f<sub>t</sub>:</strong> 遗忘门输出，控制遗忘程度
                        </div>
                        <div class="meaning-item">
                            <strong>σ:</strong> Sigmoid函数，输出[0,1]
                        </div>
                        <div class="meaning-item">
                            <strong>W<sub>f</sub>:</strong> 遗忘门权重矩阵
                        </div>
                        <div class="meaning-item">
                            <strong>[h<sub>t-1</sub>, x<sub>t</sub>]:</strong> 拼接的输入向量
                        </div>
                    </div>
                </div>
            </div>

            <!-- 使用5列网格布局的详细卡片 -->
            <div class="card-grid" style="display: grid; grid-template-columns: repeat(auto-fit, minmax(220px, 1fr)); gap: 1rem; margin: 2rem 0;">
                <!-- 第1个卡片：遗忘门输出 -->
                <div class="info-card forget-card slide-in-left">
                    <span class="card-icon">🎯</span>
                    <h3 class="card-title">f<sub>t</sub> - 遗忘门输出</h3>
                    <div class="card-content">
                        <p>控制向量，每个元素∈[0,1]</p>
                        <ul style="margin-top: 0.5rem; margin-left: 1rem; font-size: 0.875rem;">
                            <li>0 = 完全遗忘</li>
                            <li>1 = 完全保留</li>
                            <li>0.5 = 保留一半</li>
                        </ul>
                        <p style="margin-top: 0.5rem; font-size: 0.875rem;"><strong>维度：</strong>与隐藏状态相同</p>

                        <!-- 向量可视化 -->
                        <div style="margin-top: 1rem; background: rgba(0,0,0,0.2); border-radius: 8px; padding: 0.75rem;">
                            <div style="display: flex; align-items: center; justify-content: center; gap: 0.25rem; flex-wrap: wrap;">
                                <span style="font-family: monospace; color: var(--accent-yellow); font-size: 0.8rem;">f<sub>t</sub> =</span>
                                <div style="display: flex; flex-direction: column; align-items: center; border-left: 2px solid var(--accent-pink); border-right: 2px solid var(--accent-pink); padding: 0.2rem 0.4rem;">
                                    <div style="background: rgba(244,114,182,0.2); padding: 0.2rem 0.4rem; margin: 0.05rem; border-radius: 3px; font-family: monospace; font-size: 0.75rem;">0.9</div>
                                    <div style="background: rgba(244,114,182,0.2); padding: 0.2rem 0.4rem; margin: 0.05rem; border-radius: 3px; font-family: monospace; font-size: 0.75rem;">0.1</div>
                                    <div style="background: rgba(244,114,182,0.2); padding: 0.2rem 0.4rem; margin: 0.05rem; border-radius: 3px; font-family: monospace; font-size: 0.75rem;">0.5</div>
                                    <div style="color: var(--text-dim); font-size: 0.7rem;">⋮</div>
                                </div>
                                <span style="color: var(--text-secondary); font-size: 0.75rem; text-align: center;">每个值控制<br>对应特征</span>
                            </div>
                        </div>
                    </div>
                </div>

                <!-- 第2个卡片：Sigmoid函数 -->
                <div class="info-card forget-card slide-in-right">
                    <span class="card-icon">🔄</span>
                    <h3 class="card-title">σ(·) - Sigmoid函数</h3>
                    <div class="card-content">
                        <p style="font-size: 0.875rem;">将任意值映射到[0,1]</p>
                        <p style="font-family: monospace; margin: 0.5rem 0; font-size: 0.875rem;">σ(x) = 1/(1+e<sup>-x</sup>)</p>
                        <ul style="margin-top: 0.5rem; margin-left: 1rem; font-size: 0.875rem;">
                            <li>大正数 → ≈1</li>
                            <li>大负数 → ≈0</li>
                            <li>0 → 0.5</li>
                        </ul>

                        <!-- Sigmoid函数曲线 -->
                        <div style="margin-top: 1rem; background: rgba(0,0,0,0.2); border-radius: 8px; padding: 0.75rem;">
                            <svg width="100%" height="100" viewBox="0 0 200 100" style="display: block;">
                                <!-- 坐标轴 -->
                                <line x1="20" y1="50" x2="180" y2="50" stroke="var(--text-dim)" stroke-width="1"/>
                                <line x1="100" y1="10" x2="100" y2="90" stroke="var(--text-dim)" stroke-width="1"/>

                                <!-- Sigmoid曲线 -->
                                <path d="M 20 85 Q 50 85, 70 75 Q 85 60, 100 50 Q 115 40, 130 25 Q 150 15, 180 15"
                                      fill="none" stroke="var(--accent-cyan)" stroke-width="2.5"/>

                                <!-- 标注点 -->
                                <circle cx="100" cy="50" r="3" fill="var(--accent-yellow)"/>
                                <text x="105" y="55" fill="var(--text-secondary)" font-size="10">0.5</text>

                                <circle cx="35" cy="85" r="2.5" fill="var(--accent-pink)"/>
                                <text x="25" y="80" fill="var(--text-secondary)" font-size="9">≈0</text>

                                <circle cx="165" cy="15" r="2.5" fill="var(--accent-green)"/>
                                <text x="155" y="28" fill="var(--text-secondary)" font-size="9">≈1</text>
                            </svg>
                        </div>
                    </div>
                </div>

                <!-- 第3个卡片：权重矩阵 -->
                <div class="info-card forget-card slide-in-left">
                    <span class="card-icon">⚡</span>
                    <h3 class="card-title">W<sub>f</sub> - 权重矩阵</h3>
                    <div class="card-content">
                        <p style="font-size: 0.875rem;">学习如何组合输入信息</p>
                        <p style="margin-top: 0.5rem; font-size: 0.875rem;"><strong>维度：</strong></p>
                        <ul style="margin-left: 1rem; font-size: 0.875rem;">
                            <li>行 = 隐藏维度</li>
                            <li>列 = h维度 + x维度</li>
                        </ul>
                        <p style="margin-top: 0.5rem; color: var(--accent-yellow); font-size: 0.875rem;">例：128×228矩阵</p>

                        <!-- 矩阵结构可视化 -->
                        <div style="margin-top: 1rem; background: rgba(0,0,0,0.2); border-radius: 8px; padding: 0.75rem;">
                            <div style="text-align: center;">
                                <div style="display: inline-block; position: relative;">
                                    <!-- 矩阵表示 -->
                                    <div style="display: grid; grid-template-columns: repeat(6, 30px); grid-template-rows: repeat(4, 25px); gap: 2px;">
                                        <!-- 第一行 -->
                                        <div style="background: rgba(244,114,182,0.3); border: 1px solid var(--accent-pink); border-radius: 2px; font-size: 10px; display: flex; align-items: center; justify-content: center; font-family: monospace;">w₁₁</div>
                                        <div style="background: rgba(244,114,182,0.2); border: 1px solid var(--border-color); border-radius: 2px;"></div>
                                        <div style="background: rgba(244,114,182,0.2); border: 1px solid var(--border-color); border-radius: 2px;"></div>
                                        <div style="background: rgba(244,114,182,0.2); border: 1px solid var(--border-color); border-radius: 2px;"></div>
                                        <div style="background: rgba(244,114,182,0.2); border: 1px solid var(--border-color); border-radius: 2px;"></div>
                                        <div style="background: rgba(244,114,182,0.3); border: 1px solid var(--accent-pink); border-radius: 2px; font-size: 8px; display: flex; align-items: center; justify-content: center; font-family: monospace;">w₁,₂₂₈</div>

                                        <!-- 第二行 -->
                                        <div style="background: rgba(244,114,182,0.15); border: 1px solid var(--border-color); border-radius: 2px;"></div>
                                        <div style="background: rgba(244,114,182,0.1); border: 1px solid var(--border-color); border-radius: 2px;"></div>
                                        <div style="background: rgba(244,114,182,0.15); border: 1px solid var(--border-color); border-radius: 2px;"></div>
                                        <div style="background: rgba(244,114,182,0.1); border: 1px solid var(--border-color); border-radius: 2px;"></div>
                                        <div style="background: rgba(244,114,182,0.15); border: 1px solid var(--border-color); border-radius: 2px;"></div>
                                        <div style="background: rgba(244,114,182,0.1); border: 1px solid var(--border-color); border-radius: 2px;"></div>

                                        <!-- 第三行 - 省略号 -->
                                        <div style="grid-column: 1/7; display: flex; align-items: center; justify-content: center; color: var(--text-dim); font-size: 16px; height: 25px;">⋮</div>

                                        <!-- 第四行 -->
                                        <div style="background: rgba(244,114,182,0.3); border: 1px solid var(--accent-pink); border-radius: 2px; font-size: 8px; display: flex; align-items: center; justify-content: center; font-family: monospace;">w₁₂₈,₁</div>
                                        <div style="background: rgba(244,114,182,0.2); border: 1px solid var(--border-color); border-radius: 2px;"></div>
                                        <div style="background: rgba(244,114,182,0.2); border: 1px solid var(--border-color); border-radius: 2px;"></div>
                                        <div style="background: rgba(244,114,182,0.2); border: 1px solid var(--border-color); border-radius: 2px;"></div>
                                        <div style="background: rgba(244,114,182,0.2); border: 1px solid var(--border-color); border-radius: 2px;"></div>
                                        <div style="background: rgba(244,114,182,0.3); border: 1px solid var(--accent-pink); border-radius: 2px; font-size: 7px; display: flex; align-items: center; justify-content: center; font-family: monospace;">w₁₂₈,₂₂₈</div>
                                    </div>

                                    <!-- 维度标注 -->
                                    <div style="position: absolute; left: -40px; top: 50%; transform: translateY(-50%); color: var(--accent-yellow); font-size: 12px; font-weight: 600;">128</div>
                                    <div style="position: absolute; bottom: -25px; left: 50%; transform: translateX(-50%); color: var(--accent-yellow); font-size: 12px; font-weight: 600;">228</div>
                                </div>
                            </div>
                            <p style="text-align: center; margin-top: 1.5rem; color: var(--text-secondary); font-size: 0.75rem;">
                                将228维输入映射到128维
                            </p>
                        </div>
                    </div>
                </div>

                <!-- 第4个卡片：拼接输入 -->
                <div class="info-card forget-card slide-in-right">
                    <span class="card-icon">🔗</span>
                    <h3 class="card-title">[h<sub>t-1</sub>, x<sub>t</sub>] - 拼接输入</h3>
                    <div class="card-content">
                        <p style="font-size: 0.875rem;">垂直拼接两个向量</p>
                        <ul style="margin-top: 0.5rem; margin-left: 1rem; font-size: 0.875rem;">
                            <li>h<sub>t-1</sub>: 历史信息</li>
                            <li>x<sub>t</sub>: 当前输入</li>
                        </ul>
                        <p style="margin-top: 0.5rem; font-family: monospace; font-size: 0.8rem;">
                            [a,b] + [c,d] = [a,b,c,d]
                        </p>

                        <!-- 拼接过程可视化 -->
                        <div style="margin-top: 1rem; background: rgba(0,0,0,0.2); border-radius: 8px; padding: 0.75rem;">
                            <div style="display: flex; align-items: center; justify-content: center; gap: 0.5rem; flex-wrap: wrap;">
                                <!-- h向量 -->
                                <div style="text-align: center;">
                                    <div style="font-size: 0.7rem; color: var(--accent-yellow); margin-bottom: 0.2rem;">h<sub>t-1</sub></div>
                                    <div style="display: flex; flex-direction: column; border: 2px solid var(--accent-pink); border-radius: 3px; padding: 0.2rem;">
                                        <div style="background: rgba(244,114,182,0.2); padding: 0.15rem 0.3rem; margin: 0.05rem; border-radius: 2px; font-size: 0.7rem;">h₁</div>
                                        <div style="background: rgba(244,114,182,0.2); padding: 0.15rem 0.3rem; margin: 0.05rem; border-radius: 2px; font-size: 0.7rem;">h₂</div>
                                        <div style="color: var(--text-dim); font-size: 0.5rem;">⋮</div>
                                    </div>
                                    <div style="font-size: 0.65rem; color: var(--text-secondary); margin-top: 0.2rem;">128维</div>
                                </div>

                                <div style="font-size: 1.2rem; color: var(--accent-cyan);">+</div>

                                <!-- x向量 -->
                                <div style="text-align: center;">
                                    <div style="font-size: 0.7rem; color: var(--accent-yellow); margin-bottom: 0.2rem;">x<sub>t</sub></div>
                                    <div style="display: flex; flex-direction: column; border: 2px solid var(--accent-cyan); border-radius: 3px; padding: 0.2rem;">
                                        <div style="background: rgba(34,211,238,0.2); padding: 0.15rem 0.3rem; margin: 0.05rem; border-radius: 2px; font-size: 0.7rem;">x₁</div>
                                        <div style="background: rgba(34,211,238,0.2); padding: 0.15rem 0.3rem; margin: 0.05rem; border-radius: 2px; font-size: 0.7rem;">x₂</div>
                                        <div style="color: var(--text-dim); font-size: 0.5rem;">⋮</div>
                                    </div>
                                    <div style="font-size: 0.65rem; color: var(--text-secondary); margin-top: 0.2rem;">100维</div>
                                </div>

                                <div style="font-size: 1.2rem; color: var(--accent-green);">=</div>

                                <!-- 结果向量 -->
                                <div style="text-align: center;">
                                    <div style="font-size: 0.7rem; color: var(--accent-yellow); margin-bottom: 0.2rem;">[h,x]</div>
                                    <div style="display: flex; flex-direction: column; border: 2px solid var(--accent-purple); border-radius: 3px; padding: 0.2rem;">
                                        <div style="background: rgba(244,114,182,0.2); padding: 0.15rem 0.3rem; margin: 0.05rem; border-radius: 2px; font-size: 0.7rem;">h₁</div>
                                        <div style="color: var(--text-dim); font-size: 0.5rem;">⋮</div>
                                        <div style="background: rgba(34,211,238,0.2); padding: 0.15rem 0.3rem; margin: 0.05rem; border-radius: 2px; font-size: 0.7rem;">x₁</div>
                                        <div style="color: var(--text-dim); font-size: 0.5rem;">⋮</div>
                                    </div>
                                    <div style="font-size: 0.65rem; color: var(--text-secondary); margin-top: 0.2rem;">228维</div>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>

                <!-- 第5个卡片：偏置向量 -->
                <div class="info-card forget-card slide-in-left">
                    <span class="card-icon">➕</span>
                    <h3 class="card-title">b<sub>f</sub> - 偏置向量</h3>
                    <div class="card-content">
                        <p style="font-size: 0.875rem;">可训练的偏置向量，提供基准值</p>
                        <ul style="margin-top: 0.5rem; margin-left: 1rem; font-size: 0.875rem;">
                            <li>维度 = 隐藏状态维度</li>
                            <li>通常初始化为正值</li>
                        </ul>
                        <p style="margin-top: 0.5rem; font-size: 0.875rem;"><strong>作用：</strong>让模型默认倾向于记住</p>

                        <!-- 偏置效果可视化 -->
                        <div style="margin-top: 1rem; background: rgba(0,0,0,0.2); border-radius: 8px; padding: 0.75rem;">
                            <div style="text-align: center;">
                                <p style="font-size: 0.75rem; color: var(--text-secondary); margin-bottom: 0.5rem;">偏置如何影响遗忘倾向</p>
                                <div style="display: flex; justify-content: space-around; align-items: flex-end; height: 60px; margin-top: 0.5rem;">
                                    <div style="text-align: center;">
                                        <div style="width: 30px; height: 20px; background: rgba(244,114,182,0.3); border: 1px solid var(--accent-pink); border-radius: 3px 3px 0 0;"></div>
                                        <div style="font-size: 0.7rem; color: var(--accent-pink); margin-top: 0.2rem;">b=-1</div>
                                        <div style="font-size: 0.65rem; color: var(--text-dim);">易忘</div>
                                    </div>
                                    <div style="text-align: center;">
                                        <div style="width: 30px; height: 35px; background: rgba(251,191,36,0.3); border: 1px solid var(--accent-yellow); border-radius: 3px 3px 0 0;"></div>
                                        <div style="font-size: 0.7rem; color: var(--accent-yellow); margin-top: 0.2rem;">b=0</div>
                                        <div style="font-size: 0.65rem; color: var(--text-dim);">中性</div>
                                    </div>
                                    <div style="text-align: center;">
                                        <div style="width: 30px; height: 50px; background: rgba(34,197,94,0.3); border: 1px solid var(--accent-green); border-radius: 3px 3px 0 0;"></div>
                                        <div style="font-size: 0.7rem; color: var(--accent-green); margin-top: 0.2rem;">b=1</div>
                                        <div style="font-size: 0.65rem; color: var(--text-dim);">易记</div>
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
            </div>

            <!-- 矩阵运算详解 -->
            <h3 style="text-align: center; color: var(--accent-cyan); margin: 3rem 0 2rem;">🔢 矩阵维度变化详解</h3>

            <p style="text-align: center; color: var(--text-secondary); margin-bottom: 2rem;">
                假设：隐藏状态h为128维，输入x为100维
            </p>

            <div class="matrix-visualization" style="display: flex; align-items: center; justify-content: center; gap: 2rem; flex-wrap: wrap; margin: 2rem 0;">
                <div class="matrix-container">
                    <div class="matrix-bracket left"></div>
                    <div class="matrix-bracket right"></div>
                    <div class="matrix-grid" style="grid-template-columns: 1fr;">
                        <div class="matrix-cell">h₁</div>
                        <div class="matrix-cell">⋮</div>
                        <div class="matrix-cell">h₁₂₈</div>
                    </div>
                    <div style="color: var(--accent-green); margin-top: 0.5rem; text-align: center;">[128×1]</div>
                </div>

                <span class="operation-symbol">+</span>

                <div class="matrix-container">
                    <div class="matrix-bracket left"></div>
                    <div class="matrix-bracket right"></div>
                    <div class="matrix-grid" style="grid-template-columns: 1fr;">
                        <div class="matrix-cell">x₁</div>
                        <div class="matrix-cell">⋮</div>
                        <div class="matrix-cell">x₁₀₀</div>
                    </div>
                    <div style="color: var(--accent-cyan); margin-top: 0.5rem; text-align: center;">[100×1]</div>
                </div>

                <span class="operation-symbol">=</span>

                <div class="matrix-container">
                    <div class="matrix-bracket left"></div>
                    <div class="matrix-bracket right"></div>
                    <div class="matrix-grid" style="grid-template-columns: 1fr;">
                        <div class="matrix-cell">h₁</div>
                        <div class="matrix-cell">⋮</div>
                        <div class="matrix-cell">x₁₀₀</div>
                    </div>
                    <div style="color: var(--accent-purple); margin-top: 0.5rem; text-align: center;">[228×1]</div>
                </div>
            </div>

            <!-- 维度总结表 -->
            <div class="comparison-table">
                <table>
                    <thead>
                    <tr>
                        <th>符号</th>
                        <th>含义</th>
                        <th>维度</th>
                        <th>说明</th>
                    </tr>
                    </thead>
                    <tbody>
                    <tr>
                        <td><strong>h<sub>t-1</sub></strong></td>
                        <td>前一时刻隐藏状态</td>
                        <td>128×1</td>
                        <td>包含历史信息的向量</td>
                    </tr>
                    <tr>
                        <td><strong>x<sub>t</sub></strong></td>
                        <td>当前输入</td>
                        <td>100×1</td>
                        <td>当前时刻的输入特征</td>
                    </tr>
                    <tr>
                        <td><strong>W<sub>f</sub></strong></td>
                        <td>遗忘门权重</td>
                        <td>128×228</td>
                        <td>学习如何组合输入信息</td>
                    </tr>
                    <tr>
                        <td><strong>b<sub>f</sub></strong></td>
                        <td>遗忘门偏置</td>
                        <td>128×1</td>
                        <td>每个隐藏单元的基准值</td>
                    </tr>
                    <tr>
                        <td><strong>f<sub>t</sub></strong></td>
                        <td>遗忘门输出</td>
                        <td>128×1</td>
                        <td>控制遗忘程度，值∈[0,1]</td>
                    </tr>
                    </tbody>
                </table>
            </div>

            <!-- 核心概念与应用 -->
            <h3 style="text-align: center; color: var(--accent-yellow); margin: 3rem 0 2rem;">💡 核心概念与应用</h3>

            <div class="insight-box" style="background: linear-gradient(135deg, rgba(34, 197, 94, 0.1), rgba(6, 182, 212, 0.1)); border: 2px solid rgba(34, 197, 94, 0.3);">
                <h3 class="insight-title" style="color: var(--accent-green);">遗忘门如何作用于细胞状态？</h3>
                <div class="formula-display" style="margin: 1.5rem 0; background: rgba(0,0,0,0.2);">
                    <div style="font-size: 1.75rem; font-family: Georgia, serif;">
                        C<sub>t</sub><sup>new</sup> = f<sub>t</sub> ⊙ C<sub>t-1</sub>
                    </div>
                    <p style="color: var(--text-secondary); margin-top: 1rem;">
                        ⊙ 表示逐元素相乘（Hadamard积）
                    </p>
                </div>

                <div class="card-grid" style="margin-top: 2rem;">
                    <div class="info-card" style="background: rgba(34, 197, 94, 0.1); border-color: var(--accent-green);">
                        <h4 style="color: var(--accent-green);">f = 0.9 (强记忆)</h4>
                        <p>C<sub>old</sub> = 2.0</p>
                        <p>C<sub>new</sub> = 0.9 × 2.0 = 1.8</p>
                        <p style="margin-top: 0.5rem; font-weight: 600;">保留90%的信息</p>

                        <!-- 可视化进度条 -->
                        <div style="margin-top: 1rem; background: rgba(0,0,0,0.3); border-radius: 8px; padding: 0.75rem;">
                            <div style="position: relative; height: 40px;">
                                <!-- 原始值 -->
                                <div style="position: absolute; width: 100%; height: 20px; background: rgba(255,255,255,0.1); border-radius: 10px; top: 0;">
                                    <div style="width: 100%; height: 100%; background: linear-gradient(90deg, var(--accent-green) 0%, var(--accent-cyan) 100%); border-radius: 10px;"></div>
                                </div>
                                <!-- 保留值 -->
                                <div style="position: absolute; width: 90%; height: 20px; background: rgba(255,255,255,0.2); border-radius: 10px; bottom: 0; box-shadow: 0 2px 10px rgba(34,197,94,0.5);">
                                    <div style="width: 100%; height: 100%; background: var(--accent-green); border-radius: 10px;"></div>
                                </div>
                                <!-- 标签 -->
                                <div style="position: absolute; right: 5px; top: 1px; color: white; font-size: 0.75rem;">100%</div>
                                <div style="position: absolute; right: 15%; bottom: 1px; color: white; font-size: 0.75rem;">90%</div>
                            </div>
                        </div>
                    </div>

                    <div class="info-card" style="background: rgba(251, 191, 36, 0.1); border-color: var(--accent-yellow);">
                        <h4 style="color: var(--accent-yellow);">f = 0.5 (中等记忆)</h4>
                        <p>C<sub>old</sub> = 2.0</p>
                        <p>C<sub>new</sub> = 0.5 × 2.0 = 1.0</p>
                        <p style="margin-top: 0.5rem; font-weight: 600;">保留50%的信息</p>

                        <!-- 可视化进度条 -->
                        <div style="margin-top: 1rem; background: rgba(0,0,0,0.3); border-radius: 8px; padding: 0.75rem;">
                            <div style="position: relative; height: 40px;">
                                <!-- 原始值 -->
                                <div style="position: absolute; width: 100%; height: 20px; background: rgba(255,255,255,0.1); border-radius: 10px; top: 0;">
                                    <div style="width: 100%; height: 100%; background: linear-gradient(90deg, var(--accent-yellow) 0%, var(--accent-purple) 100%); border-radius: 10px;"></div>
                                </div>
                                <!-- 保留值 -->
                                <div style="position: absolute; width: 50%; height: 20px; background: rgba(255,255,255,0.2); border-radius: 10px; bottom: 0; box-shadow: 0 2px 10px rgba(251,191,36,0.5);">
                                    <div style="width: 100%; height: 100%; background: var(--accent-yellow); border-radius: 10px;"></div>
                                </div>
                                <!-- 标签 -->
                                <div style="position: absolute; right: 5px; top: 1px; color: white; font-size: 0.75rem;">100%</div>
                                <div style="position: absolute; right: 52%; bottom: 1px; color: white; font-size: 0.75rem;">50%</div>
                            </div>
                        </div>
                    </div>

                    <div class="info-card" style="background: rgba(244, 114, 182, 0.1); border-color: var(--accent-pink);">
                        <h4 style="color: var(--accent-pink);">f = 0.1 (弱记忆)</h4>
                        <p>C<sub>old</sub> = 2.0</p>
                        <p>C<sub>new</sub> = 0.1 × 2.0 = 0.2</p>
                        <p style="margin-top: 0.5rem; font-weight: 600;">仅保留10%的信息</p>

                        <!-- 可视化进度条 -->
                        <div style="margin-top: 1rem; background: rgba(0,0,0,0.3); border-radius: 8px; padding: 0.75rem;">
                            <div style="position: relative; height: 40px;">
                                <!-- 原始值 -->
                                <div style="position: absolute; width: 100%; height: 20px; background: rgba(255,255,255,0.1); border-radius: 10px; top: 0;">
                                    <div style="width: 100%; height: 100%; background: linear-gradient(90deg, var(--accent-pink) 0%, var(--accent-purple) 100%); border-radius: 10px; opacity: 0.5;"></div>
                                </div>
                                <!-- 保留值 -->
                                <div style="position: absolute; width: 10%; height: 20px; background: rgba(255,255,255,0.2); border-radius: 10px; bottom: 0; box-shadow: 0 2px 10px rgba(244,114,182,0.5);">
                                    <div style="width: 100%; height: 100%; background: var(--accent-pink); border-radius: 10px;"></div>
                                </div>
                                <!-- 标签 -->
                                <div style="position: absolute; right: 5px; top: 1px; color: white; font-size: 0.75rem;">100%</div>
                                <div style="position: absolute; left: 12%; bottom: 1px; color: white; font-size: 0.75rem;">10%</div>
                            </div>
                        </div>
                    </div>
                </div>
            </div>

            <div class="insight-box" style="background: linear-gradient(135deg, rgba(139, 92, 246, 0.1), rgba(96, 165, 250, 0.1)); border-color: var(--accent-purple);">
                <h3 class="insight-title" style="color: var(--accent-purple);">🔑 设计的巧妙之处</h3>
                <ul class="insight-list">
                    <li><strong>线性路径：</strong>通过简单乘法更新，避免梯度消失</li>
                    <li><strong>选择性控制：</strong>每个维度独立，精确控制特征保留</li>
                    <li><strong>可学习性：</strong>反向传播自动学习遗忘策略</li>
                    <li><strong>数值稳定：</strong>Sigmoid确保输出在[0,1]范围</li>
                </ul>
            </div>

            <!-- 直观理解 -->
            <h3 style="text-align: center; color: var(--accent-cyan); margin: 3rem 0 2rem;">🎭 用生活类比理解遗忘门</h3>

            <div class="insight-box" style="background: linear-gradient(135deg, rgba(240, 147, 251, 0.1), rgba(34, 211, 238, 0.1)); border: 2px solid rgba(240, 147, 251, 0.3);">
                <h3 class="insight-title" style="color: var(--accent-pink);">遗忘门就像大脑的"记忆过滤器"</h3>
                <div class="insight-content">
                    <p>想象你在听一个精彩的故事，你的大脑会自动：</p>
                    <ul class="insight-list">
                        <li><strong>重要情节（f ≈ 0.9）：</strong>主角名字、关键转折 → 深刻记忆</li>
                        <li><strong>普通细节（f ≈ 0.5）：</strong>环境描述、背景音乐 → 模糊印象</li>
                        <li><strong>无关信息（f ≈ 0.1）：</strong>路人对话、重复内容 → 自动过滤</li>
                    </ul>
                    <p style="margin-top: 1rem; color: var(--accent-cyan);">
                        💡 遗忘门通过训练，学会识别哪些信息对任务重要！
                    </p>
                </div>
            </div>

            <div class="process-flow">
                <div class="process-connector"></div>
                <div class="process-step">
                    <span class="step-number">1</span>
                    <span class="step-icon">📥</span>
                    <h4 class="step-title">接收信息</h4>
                    <p class="step-description">
                        结合历史状态h<sub>t-1</sub>和当前输入x<sub>t</sub>
                    </p>
                </div>

                <div class="process-step">
                    <span class="step-number">2</span>
                    <span class="step-icon">⚖️</span>
                    <h4 class="step-title">权重评估</h4>
                    <p class="step-description">
                        通过W<sub>f</sub>矩阵计算每个特征的重要性
                    </p>
                </div>

                <div class="process-step">
                    <span class="step-number">3</span>
                    <span class="step-icon">🎚️</span>
                    <h4 class="step-title">生成控制信号</h4>
                    <p class="step-description">
                        Sigmoid函数输出0-1之间的遗忘系数
                    </p>
                </div>
            </div>

            <!-- 实际应用示例 -->
            <h3 style="text-align: center; color: var(--accent-yellow); margin: 3rem 0 2rem;">📝 实际应用场景</h3>

            <div class="card-grid">
                <div class="info-card">
                    <span class="card-icon">📖</span>
                    <h3 class="card-title">文本处理</h3>
                    <div class="card-content">
                        <p>在句子"小明去了北京，他很喜欢那里"中：</p>
                        <ul style="margin-top: 0.5rem; margin-left: 1rem;">
                            <li>看到"他"时，遗忘门保留"小明"的信息</li>
                            <li>看到"那里"时，遗忘门保留"北京"的信息</li>
                            <li>自动过滤标点符号等无关信息</li>
                        </ul>

                        <!-- 文本处理可视化 -->
                        <div style="margin-top: 1rem; background: rgba(0,0,0,0.2); border-radius: 8px; padding: 0.75rem;">
                            <div style="display: flex; justify-content: space-around; align-items: center; flex-wrap: wrap; gap: 0.5rem;">
                                <div style="text-align: center;">
                                    <div style="background: rgba(244,114,182,0.3); padding: 0.25rem 0.5rem; border-radius: 4px; font-size: 0.875rem;">小明</div>
                                    <div style="color: var(--accent-green); font-size: 0.75rem; margin-top: 0.25rem;">f=0.9</div>
                                </div>
                                <div style="color: var(--text-dim);">→</div>
                                <div style="text-align: center;">
                                    <div style="background: rgba(100,100,100,0.2); padding: 0.25rem 0.5rem; border-radius: 4px; font-size: 0.875rem;">去了</div>
                                    <div style="color: var(--text-dim); font-size: 0.75rem; margin-top: 0.25rem;">f=0.3</div>
                                </div>
                                <div style="color: var(--text-dim);">→</div>
                                <div style="text-align: center;">
                                    <div style="background: rgba(34,211,238,0.3); padding: 0.25rem 0.5rem; border-radius: 4px; font-size: 0.875rem;">北京</div>
                                    <div style="color: var(--accent-green); font-size: 0.75rem; margin-top: 0.25rem;">f=0.8</div>
                                </div>
                                <div style="color: var(--text-dim);">→</div>
                                <div style="text-align: center;">
                                    <div style="background: rgba(100,100,100,0.1); padding: 0.25rem 0.5rem; border-radius: 4px; font-size: 0.875rem;">，</div>
                                    <div style="color: var(--accent-pink); font-size: 0.75rem; margin-top: 0.25rem;">f=0.1</div>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>

                <div class="info-card">
                    <span class="card-icon">📊</span>
                    <h3 class="card-title">时序预测</h3>
                    <div class="card-content">
                        <p>在股票价格预测中：</p>
                        <ul style="margin-top: 0.5rem; margin-left: 1rem;">
                            <li>长期趋势信息被高度保留（f ≈ 0.9）</li>
                            <li>短期波动逐渐被遗忘（f ≈ 0.3）</li>
                            <li>异常值影响被快速消除（f ≈ 0.1）</li>
                        </ul>

                        <!-- 时序数据可视化 -->
                        <div style="margin-top: 1rem; background: rgba(0,0,0,0.2); border-radius: 8px; padding: 0.75rem;">
                            <svg width="100%" height="80" viewBox="0 0 200 80" style="display: block;">
                                <!-- 趋势线 -->
                                <path d="M 10 60 Q 50 50, 100 40 T 190 20" fill="none" stroke="var(--accent-green)" stroke-width="2" stroke-dasharray="5,5" opacity="0.8"/>
                                <!-- 实际数据线 -->
                                <path d="M 10 60 L 30 55 L 50 52 L 70 48 L 90 44 L 110 38 L 130 36 L 150 30 L 170 26 L 190 20"
                                      fill="none" stroke="var(--accent-cyan)" stroke-width="2"/>
                                <!-- 异常点 -->
                                <circle cx="70" cy="35" r="3" fill="var(--accent-pink)"/>
                                <circle cx="130" cy="45" r="3" fill="var(--accent-pink)"/>

                                <!-- 标注 -->
                                <text x="100" y="15" text-anchor="middle" fill="var(--text-secondary)" font-size="10">长期趋势 (f≈0.9)</text>
                                <text x="70" y="30" text-anchor="middle" fill="var(--accent-pink)" font-size="9">异常值 (f≈0.1)</text>
                            </svg>
                        </div>
                    </div>
                </div>

                <div class="info-card">
                    <span class="card-icon">🗣️</span>
                    <h3 class="card-title">语音识别</h3>
                    <div class="card-content">
                        <p>在连续语音流中：</p>
                        <ul style="margin-top: 0.5rem; margin-left: 1rem;">
                            <li>关键音素特征被保留</li>
                            <li>背景噪音被过滤</li>
                            <li>语调变化选择性记忆</li>
                        </ul>

                        <!-- 音频波形可视化 -->
                        <div style="margin-top: 1rem; background: rgba(0,0,0,0.2); border-radius: 8px; padding: 0.75rem;">
                            <div style="position: relative; height: 60px;">
                                <!-- 背景噪音 -->
                                <div style="position: absolute; width: 100%; height: 100%; display: flex; align-items: center; justify-content: space-around;">
                                    <div style="width: 3px; height: 20%; background: var(--text-dim); opacity: 0.3;"></div>
                                    <div style="width: 3px; height: 15%; background: var(--text-dim); opacity: 0.3;"></div>
                                    <div style="width: 3px; height: 25%; background: var(--text-dim); opacity: 0.3;"></div>
                                    <div style="width: 3px; height: 18%; background: var(--text-dim); opacity: 0.3;"></div>
                                </div>
                                <!-- 语音信号 -->
                                <div style="position: absolute; width: 100%; height: 100%; display: flex; align-items: center; justify-content: center; gap: 2px;">
                                    <div style="width: 4px; height: 30%; background: var(--accent-cyan); border-radius: 2px;"></div>
                                    <div style="width: 4px; height: 50%; background: var(--accent-green); border-radius: 2px;"></div>
                                    <div style="width: 4px; height: 80%; background: var(--accent-green); border-radius: 2px;"></div>
                                    <div style="width: 4px; height: 90%; background: var(--accent-yellow); border-radius: 2px;"></div>
                                    <div style="width: 4px; height: 70%; background: var(--accent-green); border-radius: 2px;"></div>
                                    <div style="width: 4px; height: 40%; background: var(--accent-cyan); border-radius: 2px;"></div>
                                    <div style="width: 4px; height: 20%; background: var(--accent-cyan); border-radius: 2px;"></div>
                                </div>
                            </div>
                            <div style="display: flex; justify-content: space-between; margin-top: 0.5rem; font-size: 0.75rem;">
                                <span style="color: var(--text-dim);">噪音 (f≈0.1)</span>
                                <span style="color: var(--accent-yellow);">关键音素 (f≈0.9)</span>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </section>

        <!-- 输入门、输出门和整合过程的详解 -->
        <section class="section-card">
            <h2 style="color: var(--accent-cyan); margin-bottom: 2rem;">📥 输入门与候选值详解</h2>

            <div class="formula-explainer">
                <div class="formula-column">
                    <h4>输入门公式</h4>
                    <div class="formula-math">
                        i<sub>t</sub> = σ(W<sub>i</sub> · [h<sub>t-1</sub>, x<sub>t</sub>] + b<sub>i</sub>)
                    </div>
                </div>

                <div class="formula-column">
                    <h4>候选值公式</h4>
                    <div class="formula-math">
                        C̃<sub>t</sub> = tanh(W<sub>C</sub> · [h<sub>t-1</sub>, x<sub>t</sub>] + b<sub>C</sub>)
                    </div>
                </div>

                <div class="formula-column">
                    <h4>新信息计算</h4>
                    <div class="formula-math">
                        新增信息 = i<sub>t</sub> ⊙ C̃<sub>t</sub>
                    </div>
                </div>
            </div>

            <div class="insight-box" style="background: linear-gradient(135deg, rgba(79, 172, 254, 0.1), rgba(0, 242, 254, 0.1)); border: 2px solid rgba(79, 172, 254, 0.3);">
                <h3 class="insight-title" style="color: var(--accent-cyan);">输入门的作用机制</h3>
                <p>输入门通过两步确定要存储的新信息：</p>
                <ul>
                    <li><strong>i<sub>t</sub>:</strong> 决定存储权重（0=忽略，1=全部存储）</li>
                    <li><strong>C̃<sub>t</sub>:</strong> 候选记忆内容（范围[-1,1]）</li>
                </ul>
            </div>
        </section>

        <section class="section-card">
            <h2 style="color: var(--accent-yellow); margin-bottom: 2rem;">📤 输出门详解</h2>

            <div class="formula-explainer">
                <div class="formula-column">
                    <h4>输出门公式</h4>
                    <div class="formula-math">
                        o<sub>t</sub> = σ(W<sub>o</sub> · [h<sub>t-1</sub>, x<sub>t</sub>] + b<sub>o</sub>)
                    </div>
                </div>

                <div class="formula-column">
                    <h4>隐藏状态公式</h4>
                    <div class="formula-math">
                        h<sub>t</sub> = o<sub>t</sub> ⊙ tanh(C<sub>t</sub>)
                    </div>
                </div>

                <div class="formula-column">
                    <h4>输出过滤</h4>
                    <div class="formula-math">
                        从细胞状态C<sub>t</sub>中<br>选择性输出信息
                    </div>
                </div>
            </div>

            <div class="insight-box" style="background: linear-gradient(135deg, rgba(250, 112, 154, 0.1), rgba(254, 225, 64, 0.1)); border: 2px solid rgba(250, 112, 154, 0.3);">
                <h3 class="insight-title" style="color: var(--accent-yellow);">输出门的智能选择</h3>
                <p>输出门决定从丰富的细胞状态中输出哪些信息：</p>
                <ul>
                    <li>细胞状态C<sub>t</sub>保存完整信息</li>
                    <li>通过tanh压缩到[-1,1]范围</li>
                    <li>o<sub>t</sub>选择性过滤输出内容</li>
                </ul>
            </div>
        </section>

        <section class="section-card" style="background: linear-gradient(135deg, rgba(102, 126, 234, 0.05), rgba(118, 75, 162, 0.05));">
            <h2 style="color: var(--accent-purple); margin-bottom: 2rem;">🔄 整合过程：三个门的协同效果</h2>

            <div class="formula-explainer">
                <div class="formula-column">
                    <h4>细胞状态更新</h4>
                    <div class="formula-math">
                        C<sub>t</sub> = f<sub>t</sub> ⊙ C<sub>t-1</sub> + i<sub>t</sub> ⊙ C̃<sub>t</sub>
                    </div>
                </div>

                <div class="formula-column">
                    <h4>三个门的作用</h4>
                    <div style="text-align: left; padding: 1rem;">
                        <p><span style="color: var(--accent-pink);">遗忘门:</span> 选择性遗忘</p>
                        <p><span style="color: var(--accent-cyan);">输入门:</span> 选择性记忆</p>
                        <p><span style="color: var(--accent-yellow);">输出门:</span> 选择性输出</p>
                    </div>
                </div>

                <div class="formula-column">
                    <h4>最终效果</h4>
                    <div style="text-align: center; padding: 1rem;">
                        <div style="font-size: 2rem; margin-bottom: 0.5rem;">✨</div>
                        <p>精确控制信息流<br>解决长期依赖问题</p>
                    </div>
                </div>
            </div>

            <!-- 整合过程的动态展示 -->
            <div style="background: rgba(255, 255, 255, 0.05); border-radius: 1rem; padding: 2rem; margin: 2rem 0;">
                <h3 style="color: var(--accent-cyan); text-align: center; margin-bottom: 2rem;">📊 数据流动过程示例</h3>

                <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 1.5rem; text-align: center;">
                    <div>
                        <h4 style="color: var(--accent-green); margin-bottom: 1rem;">初始状态</h4>
                        <div style="background: rgba(34, 197, 94, 0.1); padding: 1rem; border-radius: 0.5rem;">
                            <p>C<sub>t-1</sub> = 1.5</p>
                            <p>h<sub>t-1</sub> = 0.8</p>
                            <p>x<sub>t</sub> = 0.6</p>
                        </div>
                    </div>

                    <div>
                        <h4 style="color: var(--accent-pink); margin-bottom: 1rem;">遗忘阶段</h4>
                        <div style="background: rgba(244, 114, 182, 0.1); padding: 1rem; border-radius: 0.5rem;">
                            <p>f<sub>t</sub> = 0.7</p>
                            <p>遗忘后: 1.5 × 0.7 = 1.05</p>
                        </div>
                    </div>

                    <div>
                        <h4 style="color: var(--accent-cyan); margin-bottom: 1rem;">输入阶段</h4>
                        <div style="background: rgba(79, 172, 254, 0.1); padding: 1rem; border-radius: 0.5rem;">
                            <p>i<sub>t</sub> = 0.6, C̃<sub>t</sub> = 0.9</p>
                            <p>新增: 0.6 × 0.9 = 0.54</p>
                        </div>
                    </div>

                    <div>
                        <h4 style="color: var(--accent-yellow); margin-bottom: 1rem;">输出阶段</h4>
                        <div style="background: rgba(250, 112, 154, 0.1); padding: 1rem; border-radius: 0.5rem;">
                            <p>C<sub>t</sub> = 1.05 + 0.54 = 1.59</p>
                            <p>o<sub>t</sub> = 0.8</p>
                            <p>h<sub>t</sub> = 0.8 × tanh(1.59) ≈ 0.73</p>
                        </div>
                    </div>
                </div>
            </div>

            <div class="tip success" style="margin-top: 2rem;">
                <span style="font-size: 1.5rem;">🎯</span>
                <div>
                    <strong>关键洞察：</strong>通过三个门的协同工作，LSTM实现了：
                    <ul style="margin-left: 1.5rem; margin-top: 0.5rem;">
                        <li><strong>梯度稳定传播：</strong>细胞状态的线性路径避免梯度消失</li>
                        <li><strong>选择性记忆：</strong>精确控制信息的保留、更新和输出</li>
                        <li><strong>长期依赖建模：</strong>重要信息可以跨越很长的时间步传递</li>
                    </ul>
                </div>
            </div>
        </section>

            <div class="comparison-table">
                <table>
                    <thead>
                    <tr>
                        <th>组件</th>
                        <th>作用</th>
                        <th>激活函数</th>
                        <th>输出范围</th>
                        <th>关键特性</th>
                    </tr>
                    </thead>
                    <tbody>
                    <tr>
                        <td><strong>遗忘门</strong></td>
                        <td>决定忘记什么</td>
                        <td>Sigmoid</td>
                        <td>[0, 1]</td>
                        <td>选择性遗忘</td>
                    </tr>
                    <tr>
                        <td><strong>输入门</strong></td>
                        <td>决定存储权重</td>
                        <td>Sigmoid</td>
                        <td>[0, 1]</td>
                        <td>控制更新强度</td>
                    </tr>
                    <tr>
                        <td><strong>候选值</strong></td>
                        <td>新的记忆内容</td>
                        <td>Tanh</td>
                        <td>[-1, 1]</td>
                        <td>编码新信息</td>
                    </tr>
                    <tr>
                        <td><strong>细胞状态</strong></td>
                        <td>长期记忆存储</td>
                        <td>线性</td>
                        <td>(-∞, +∞)</td>
                        <td>梯度高速公路</td>
                    </tr>
                    <tr>
                        <td><strong>输出门</strong></td>
                        <td>决定输出什么</td>
                        <td>Sigmoid</td>
                        <td>[0, 1]</td>
                        <td>信息过滤</td>
                    </tr>
                    </tbody>
                </table>
            </div>
        </section>

        <!-- LSTM vs GRU 对比分析 -->
        <section id="lstm-vs-gru" class="section-card">
            <h2 style="color: var(--accent-yellow); margin-bottom: 2rem;">⚔️ LSTM vs GRU：繁与简的权衡</h2>

            <div class="architecture-comparison">
                <div class="architecture-card lstm">
                    <div class="architecture-title">
                        <div class="architecture-icon lstm">🏗️</div>
                        <div>
                            <h3 style="color: var(--accent-pink);">LSTM (1997)</h3>
                            <p style="color: var(--text-secondary);">Long Short-Term Memory</p>
                        </div>
                    </div>

                    <h4 style="color: var(--accent-cyan); margin-bottom: 1rem;">🔧 架构特点</h4>
                    <ul style="margin-left: 1.5rem; line-height: 1.8;">
                        <li><strong>三个门：</strong>遗忘门、输入门、输出门</li>
                        <li><strong>双状态：</strong>细胞状态 + 隐藏状态</li>
                        <li><strong>参数多：</strong>4个权重矩阵</li>
                        <li><strong>控制精细：</strong>独立控制遗忘和记忆</li>
                    </ul>

                    <div style="margin: 1.5rem 0;">
                        <canvas id="lstmArchCanvas" width="300" height="200"></canvas>
                    </div>

                    <div class="tip info">
                        <span>💡</span>
                        <div>
                            <strong>优势：</strong>表达能力强，适合复杂任务<br>
                            <strong>劣势：</strong>参数多，训练慢
                        </div>
                    </div>
                </div>

                <div class="architecture-card gru">
                    <div class="architecture-title">
                        <div class="architecture-icon gru">⚡</div>
                        <div>
                            <h3 style="color: var(--accent-orange);">GRU (2014)</h3>
                            <p style="color: var(--text-secondary);">Gated Recurrent Unit</p>
                        </div>
                    </div>

                    <h4 style="color: var(--accent-cyan); margin-bottom: 1rem;">🔧 架构特点</h4>
                    <ul style="margin-left: 1.5rem; line-height: 1.8;">
                        <li><strong>两个门：</strong>重置门、更新门</li>
                        <li><strong>单状态：</strong>只有隐藏状态</li>
                        <li><strong>参数少：</strong>3个权重矩阵</li>
                        <li><strong>简化版：</strong>遗忘门 + 输入门 = 更新门</li>
                    </ul>

                    <div style="margin: 1.5rem 0;">
                        <canvas id="gruArchCanvas" width="300" height="200"></canvas>
                    </div>

                    <div class="tip success">
                        <span>⚡</span>
                        <div>
                            <strong>优势：</strong>参数少，训练快，性能接近<br>
                            <strong>劣势：</strong>表达能力稍弱
                        </div>
                    </div>
                </div>
            </div>

            <!-- 公式对比 -->
            <div style="background: var(--bg-section); padding: 2rem; border-radius: 1rem; margin: 2rem 0;">
                <h3 style="color: var(--accent-purple); text-align: center; margin-bottom: 2rem;">📐 公式对比</h3>

                <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 2rem;">
                    <div>
                        <h4 style="color: var(--accent-pink); margin-bottom: 1rem;">LSTM公式</h4>
                        <div style="background: rgba(255, 255, 255, 0.05); padding: 1.5rem; border-radius: 0.5rem; font-family: monospace; font-size: 0.9rem;">
                            f_t = σ(W_f[h_{t-1}, x_t] + b_f)<br>
                            i_t = σ(W_i[h_{t-1}, x_t] + b_i)<br>
                            C̃_t = tanh(W_C[h_{t-1}, x_t] + b_C)<br>
                            C_t = f_t ⊙ C_{t-1} + i_t ⊙ C̃_t<br>
                            o_t = σ(W_o[h_{t-1}, x_t] + b_o)<br>
                            h_t = o_t ⊙ tanh(C_t)
                        </div>
                    </div>

                    <div>
                        <h4 style="color: var(--accent-orange); margin-bottom: 1rem;">GRU公式</h4>
                        <div style="background: rgba(255, 255, 255, 0.05); padding: 1.5rem; border-radius: 0.5rem; font-family: monospace; font-size: 0.9rem;">
                            r_t = σ(W_r[h_{t-1}, x_t] + b_r)<br>
                            z_t = σ(W_z[h_{t-1}, x_t] + b_z)<br>
                            h̃_t = tanh(W_h[r_t ⊙ h_{t-1}, x_t] + b_h)<br>
                            h_t = z_t ⊙ h_{t-1} + (1-z_t) ⊙ h̃_t<br>
                            <br>
                            <span style="color: var(--text-secondary);"># 注意：GRU只需要4行！</span>
                        </div>
                    </div>
                </div>

                <div class="tip warning" style="margin-top: 2rem;">
                    <span>🤔</span>
                    <div>
                        <strong>关键洞察：</strong>GRU通过 <code>z_t</code> 和 <code>(1-z_t)</code> 实现了LSTM中遗忘门和输入门的功能。
                        当 z_t = 1 时完全保留旧状态，当 z_t = 0 时完全接受新状态。
                    </div>
                </div>
            </div>

            <!-- 性能对比实验 -->
            <div class="live-demo">
                <div class="live-demo-content">
                    <h3 style="color: var(--accent-cyan); margin-bottom: 1.5rem;">🏆 性能对比实验</h3>
                    <p style="margin-bottom: 1.5rem;">在相同的语言建模任务上比较LSTM和GRU：</p>

                    <div style="display: grid; grid-template-columns: 1fr 1fr 1fr; gap: 1.5rem;">
                        <div style="text-align: center;">
                            <h4 style="color: var(--accent-blue);">训练速度</h4>
                            <div style="font-size: 2rem; margin: 1rem 0;">⚡</div>
                            <p>GRU快30%</p>
                        </div>
                        <div style="text-align: center;">
                            <h4 style="color: var(--accent-green);">准确率</h4>
                            <div style="font-size: 2rem; margin: 1rem 0;">📊</div>
                            <p>LSTM略胜2%</p>
                        </div>
                        <div style="text-align: center;">
                            <h4 style="color: var(--accent-orange);">内存占用</h4>
                            <div style="font-size: 2rem; margin: 1rem 0;">💾</div>
                            <p>GRU省25%</p>
                        </div>
                    </div>

                    <div style="margin-top: 2rem; padding: 1.5rem; background: rgba(255, 255, 255, 0.05); border-radius: 0.5rem;">
                        <h4 style="color: var(--accent-purple); margin-bottom: 1rem;">选择建议</h4>
                        <ul style="margin-left: 1.5rem; line-height: 1.8;">
                            <li><strong>选择LSTM：</strong>复杂任务、需要精细控制、计算资源充足</li>
                            <li><strong>选择GRU：</strong>简单任务、快速原型、资源受限</li>
                            <li><strong>实际建议：</strong>两个都试试，看哪个在你的任务上效果更好！</li>
                        </ul>
                    </div>
                </div>
            </div>
        </section>

        <!-- 数学证明 -->
        <section id="math-proof" class="section-card">
            <h2 style="color: var(--accent-red); margin-bottom: 2rem;">🔬 数学证明：LSTM如何解决梯度消失</h2>

            <div class="math-derivation">
                <h3 style="color: var(--accent-red); margin-bottom: 1.5rem;">📐 梯度传播分析</h3>

                <div class="derivation-step">
                    <div class="derivation-step-number">1</div>
                    <h4>细胞状态的梯度传播</h4>
                    <p>从细胞状态更新公式出发：</p>
                    <div style="text-align: center; margin: 1rem 0; font-size: 1.2rem;">
                        $C_t = f_t \odot C_{t-1} + i_t \odot \tilde{C}_t$
                    </div>
                    <p>计算梯度：</p>
                    <div style="text-align: center; margin: 1rem 0; font-size: 1.2rem;">
                        $\frac{\partial C_t}{\partial C_{t-1}} = \text{diag}(f_t)$
                    </div>
                </div>

                <div class="derivation-step">
                    <div class="derivation-step-number">2</div>
                    <h4>关键洞察</h4>
                    <p>梯度通过<strong>对角矩阵</strong>传播，而不是密集矩阵！</p>
                    <div class="tip success">
                        <span style="font-size: 1.5rem;">💡</span>
                        <div>
                            这意味着：
                            <ul style="margin-left: 1.5rem; margin-top: 0.5rem;">
                                <li>每个维度的梯度独立传播</li>
                                <li>没有信息混合</li>
                                <li>网络可以学习让 f_t ≈ 1 来保持梯度</li>
                            </ul>
                        </div>
                    </div>
                </div>

                <div class="derivation-step">
                    <div class="derivation-step-number">3</div>
                    <h4>数值稳定性分析</h4>
                    <p>虽然细胞状态线性传播，但仍可能数值不稳定。现代LSTM常用技巧：</p>
                    <ul style="margin-left: 1.5rem; margin-top: 1rem;">
                        <li><strong>层归一化：</strong>在每个门之前标准化输入</li>
                        <li><strong>梯度裁剪：</strong>防止梯度爆炸</li>
                        <li><strong>权重初始化：</strong>遗忘门偏置初始化为大正值</li>
                    </ul>
                </div>

                <div class="derivation-step">
                    <div class="derivation-step-number">4</div>
                    <h4>与RNN对比</h4>
                    <div class="comparison-table">
                        <table>
                            <thead>
                            <tr>
                                <th>模型</th>
                                <th>梯度传播</th>
                                <th>100步后梯度</th>
                                <th>稳定性</th>
                            </tr>
                            </thead>
                            <tbody>
                            <tr>
                                <td>RNN</td>
                                <td>$(W_{hh}^T \cdot \text{diag}(\tanh'))^{100}$</td>
                                <td>≈ 10⁻³⁰</td>
                                <td>❌ 极不稳定</td>
                            </tr>
                            <tr>
                                <td>LSTM</td>
                                <td>$\prod_{t=1}^{100} \text{diag}(f_t)$</td>
                                <td>≈ 10⁻⁵</td>
                                <td>✅ 相对稳定</td>
                            </tr>
                            </tbody>
                        </table>
                    </div>
                </div>
            </div>
        </section>

        <!-- 代码实现 -->
        <section id="implementation" class="section-card">
            <h2 style="color: var(--accent-yellow); margin-bottom: 2rem;">🛠️ 从零实现LSTM</h2>

            <div class="code-layers">
                <div class="code-layer-tabs">
                    <button class="code-layer-tab active" data-layer="pseudo">伪代码</button>
                    <button class="code-layer-tab" data-layer="numpy">NumPy实现</button>
                    <button class="code-layer-tab" data-layer="pytorch">PyTorch实现</button>
                    <button class="code-layer-tab" data-layer="tensorflow">TensorFlow实现</button>
                </div>

                <div class="code-layer-content active" data-layer-content="pseudo">
                    <pre><code class="language-plaintext">LSTM前向传播算法：

输入：当前输入 x_t, 上一隐藏状态 h_{t-1}, 上一细胞状态 C_{t-1}
输出：当前隐藏状态 h_t, 当前细胞状态 C_t

算法步骤：
1. 计算遗忘门：
   f_t = sigmoid(W_f · [h_{t-1}, x_t] + b_f)

2. 计算输入门和候选值：
   i_t = sigmoid(W_i · [h_{t-1}, x_t] + b_i)
   C_tilde_t = tanh(W_C · [h_{t-1}, x_t] + b_C)

3. 更新细胞状态：
   C_t = f_t ⊙ C_{t-1} + i_t ⊙ C_tilde_t

4. 计算输出门和隐藏状态：
   o_t = sigmoid(W_o · [h_{t-1}, x_t] + b_o)
   h_t = o_t ⊙ tanh(C_t)

返回 h_t, C_t</code></pre>
                </div>

                <div class="code-layer-content" data-layer-content="numpy">
                    <pre><code class="language-python">import numpy as np

class LSTMCell:
    """LSTM单元的NumPy实现"""

    def __init__(self, input_dim, hidden_dim):
        # 初始化权重矩阵 - Xavier初始化
        scale = np.sqrt(2.0 / (input_dim + hidden_dim))

        # 遗忘门参数
        self.Wf = np.random.randn(hidden_dim, input_dim + hidden_dim) * scale
        self.bf = np.ones((hidden_dim, 1))  # 初始化为1，促进记忆

        # 输入门参数
        self.Wi = np.random.randn(hidden_dim, input_dim + hidden_dim) * scale
        self.bi = np.zeros((hidden_dim, 1))

        # 候选值参数
        self.Wc = np.random.randn(hidden_dim, input_dim + hidden_dim) * scale
        self.bc = np.zeros((hidden_dim, 1))

        # 输出门参数
        self.Wo = np.random.randn(hidden_dim, input_dim + hidden_dim) * scale
        self.bo = np.zeros((hidden_dim, 1))

    def forward(self, x_t, h_prev, c_prev):
        """LSTM前向传播"""
        # 拼接输入 [h_{t-1}, x_t]
        concat = np.vstack([h_prev, x_t])

        # 计算四个门
        f_t = self.sigmoid(np.dot(self.Wf, concat) + self.bf)  # 遗忘门
        i_t = self.sigmoid(np.dot(self.Wi, concat) + self.bi)  # 输入门
        c_tilde_t = np.tanh(np.dot(self.Wc, concat) + self.bc)  # 候选值
        o_t = self.sigmoid(np.dot(self.Wo, concat) + self.bo)  # 输出门

        # 更新细胞状态
        c_t = f_t * c_prev + i_t * c_tilde_t

        # 计算隐藏状态
        h_t = o_t * np.tanh(c_t)

        # 保存中间结果用于反向传播
        cache = {
            'x_t': x_t, 'h_prev': h_prev, 'c_prev': c_prev,
            'f_t': f_t, 'i_t': i_t, 'c_tilde_t': c_tilde_t, 'o_t': o_t,
            'c_t': c_t, 'concat': concat
        }

        return h_t, c_t, cache

    def backward(self, dh_next, dc_next, cache):
        """LSTM反向传播"""
        # 解包缓存
        x_t = cache['x_t']
        h_prev = cache['h_prev']
        c_prev = cache['c_prev']
        f_t = cache['f_t']
        i_t = cache['i_t']
        c_tilde_t = cache['c_tilde_t']
        o_t = cache['o_t']
        c_t = cache['c_t']
        concat = cache['concat']

        # 计算各个门的梯度
        do_t = dh_next * np.tanh(c_t)
        dc_t = dc_next + dh_next * o_t * (1 - np.tanh(c_t)**2)

        df_t = dc_t * c_prev
        di_t = dc_t * c_tilde_t
        dc_tilde_t = dc_t * i_t
        dc_prev = dc_t * f_t

        # 通过激活函数的梯度
        dzo_t = do_t * o_t * (1 - o_t)
        dzf_t = df_t * f_t * (1 - f_t)
        dzi_t = di_t * i_t * (1 - i_t)
        dzc_t = dc_tilde_t * (1 - c_tilde_t**2)

        # 计算权重梯度
        self.dWo = np.dot(dzo_t, concat.T)
        self.dbo = dzo_t

        self.dWf = np.dot(dzf_t, concat.T)
        self.dbf = dzf_t

        self.dWi = np.dot(dzi_t, concat.T)
        self.dbi = dzi_t

        self.dWc = np.dot(dzc_t, concat.T)
        self.dbc = dzc_t

        # 计算输入梯度
        dconcat = (np.dot(self.Wf.T, dzf_t) +
                   np.dot(self.Wi.T, dzi_t) +
                   np.dot(self.Wc.T, dzc_t) +
                   np.dot(self.Wo.T, dzo_t))

        dh_prev = dconcat[:h_prev.shape[0]]
        dx_t = dconcat[h_prev.shape[0]:]

        return dx_t, dh_prev, dc_prev

    @staticmethod
    def sigmoid(x):
        """数值稳定的sigmoid函数"""
        return np.where(x >= 0,
                       1 / (1 + np.exp(-x)),
                       np.exp(x) / (1 + np.exp(x)))

# 使用示例
if __name__ == "__main__":
    # 创建LSTM单元
    lstm = LSTMCell(input_dim=100, hidden_dim=128)

    # 模拟输入
    x_t = np.random.randn(100, 1)
    h_prev = np.zeros((128, 1))
    c_prev = np.zeros((128, 1))

    # 前向传播
    h_t, c_t, cache = lstm.forward(x_t, h_prev, c_prev)

    print(f"隐藏状态形状: {h_t.shape}")
    print(f"细胞状态形状: {c_t.shape}")
    print(f"隐藏状态范围: [{h_t.min():.3f}, {h_t.max():.3f}]")
    print(f"细胞状态范围: [{c_t.min():.3f}, {c_t.max():.3f}]")</code></pre>
                </div>

                <div class="code-layer-content" data-layer-content="pytorch">
                    <pre><code class="language-python">import torch
import torch.nn as nn
import torch.nn.functional as F

class LSTMCell(nn.Module):
    """PyTorch LSTM单元实现"""

    def __init__(self, input_size, hidden_size):
        super(LSTMCell, self).__init__()
        self.input_size = input_size
        self.hidden_size = hidden_size

        # 合并所有门的权重，提高计算效率
        self.weight_ih = nn.Linear(input_size, 4 * hidden_size)
        self.weight_hh = nn.Linear(hidden_size, 4 * hidden_size)

        # 初始化参数
        self.reset_parameters()

    def reset_parameters(self):
        """参数初始化"""
        std = 1.0 / (self.hidden_size)**0.5
        for weight in self.parameters():
            weight.data.uniform_(-std, std)

        # 遗忘门偏置初始化为1
        self.weight_ih.bias.data[0:self.hidden_size].fill_(1.0)

    def forward(self, input, hidden):
        """前向传播"""
        hx, cx = hidden

        # 计算所有门
        gates = self.weight_ih(input) + self.weight_hh(hx)

        # 分割门
        ingate, forgetgate, cellgate, outgate = gates.chunk(4, 1)

        # 应用激活函数
        ingate = torch.sigmoid(ingate)
        forgetgate = torch.sigmoid(forgetgate)
        cellgate = torch.tanh(cellgate)
        outgate = torch.sigmoid(outgate)

        # 更新细胞状态
        cy = forgetgate * cx + ingate * cellgate

        # 计算隐藏状态
        hy = outgate * torch.tanh(cy)

        return hy, cy

class LSTM(nn.Module):
    """完整的LSTM模型"""

    def __init__(self, input_size, hidden_size, num_layers=1, dropout=0.0):
        super(LSTM, self).__init__()
        self.input_size = input_size
        self.hidden_size = hidden_size
        self.num_layers = num_layers

        # 创建LSTM层
        self.lstm_layers = nn.ModuleList()
        for i in range(num_layers):
            layer_input_size = input_size if i == 0 else hidden_size
            self.lstm_layers.append(LSTMCell(layer_input_size, hidden_size))

        # Dropout层
        self.dropout = nn.Dropout(dropout) if dropout > 0 else None

    def forward(self, input, hidden=None):
        """前向传播"""
        batch_size, seq_len, _ = input.size()

        # 初始化隐藏状态
        if hidden is None:
            h_0 = torch.zeros(self.num_layers, batch_size, self.hidden_size, device=input.device)
            c_0 = torch.zeros(self.num_layers, batch_size, self.hidden_size, device=input.device)
            hidden = (h_0, c_0)

        h_n, c_n = hidden
        output = []

        # 逐时间步处理
        for t in range(seq_len):
            x_t = input[:, t, :]

            # 逐层处理
            for layer in range(self.num_layers):
                h_t = h_n[layer]
                c_t = c_n[layer]

                # LSTM计算
                h_t, c_t = self.lstm_layers[layer](x_t, (h_t, c_t))

                # 更新状态
                h_n[layer] = h_t
                c_n[layer] = c_t

                # 准备下一层的输入
                x_t = h_t
                if self.dropout and layer < self.num_layers - 1:
                    x_t = self.dropout(x_t)

            output.append(h_t.unsqueeze(1))

        # 合并输出
        output = torch.cat(output, dim=1)
        return output, (h_n, c_n)

# 使用示例
if __name__ == "__main__":
    # 创建模型
    lstm = LSTM(input_size=100, hidden_size=256, num_layers=2, dropout=0.1)

    # 模拟输入
    x = torch.randn(32, 50, 100)  # (batch, seq_len, input_size)

    # 前向传播
    output, (h_n, c_n) = lstm(x)

    print(f"输入形状: {x.shape}")
    print(f"输出形状: {output.shape}")
    print(f"最终隐藏状态形状: {h_n.shape}")
    print(f"最终细胞状态形状: {c_n.shape}")

    # 参数统计
    total_params = sum(p.numel() for p in lstm.parameters())
    print(f"总参数量: {total_params:,}")</code></pre>
                </div>

                <div class="code-layer-content" data-layer-content="tensorflow">
                    <pre><code class="language-python">import tensorflow as tf
import numpy as np

class LSTMCell(tf.keras.layers.Layer):
    """TensorFlow LSTM单元实现"""

    def __init__(self, units, **kwargs):
        super(LSTMCell, self).__init__(**kwargs)
        self.units = units
        self.state_size = [units, units]  # [h, c]

    def build(self, input_shape):
        input_dim = input_shape[-1]

        # 创建权重矩阵
        self.kernel = self.add_weight(
            shape=(input_dim, self.units * 4),
            name='kernel',
            initializer='glorot_uniform'
        )

        self.recurrent_kernel = self.add_weight(
            shape=(self.units, self.units * 4),
            name='recurrent_kernel',
            initializer='orthogonal'
        )

        # 偏置
        self.bias = self.add_weight(
            shape=(self.units * 4,),
            name='bias',
            initializer=self.bias_initializer
        )

    def bias_initializer(self, shape, dtype=None):
        """自定义偏置初始化 - 遗忘门偏置为1"""
        bias = np.zeros(shape)
        bias[:self.units] = 1.0  # 遗忘门
        return tf.constant(bias, dtype=dtype)

    def call(self, inputs, states):
        """前向传播"""
        h_prev, c_prev = states

        # 计算所有门
        z = tf.matmul(inputs, self.kernel)
        z += tf.matmul(h_prev, self.recurrent_kernel)
        z = tf.nn.bias_add(z, self.bias)

        # 分割门
        z0, z1, z2, z3 = tf.split(z, 4, axis=1)

        # 应用激活函数
        f = tf.nn.sigmoid(z0)  # 遗忘门
        i = tf.nn.sigmoid(z1)  # 输入门
        c_tilde = tf.nn.tanh(z2)  # 候选值
        o = tf.nn.sigmoid(z3)  # 输出门

        # 更新状态
        c = f * c_prev + i * c_tilde
        h = o * tf.nn.tanh(c)

        return h, [h, c]

# 使用Keras高级API的LSTM
def create_lstm_model(input_shape, units, num_layers=1, dropout=0.0):
    """创建LSTM模型"""
    model = tf.keras.Sequential()

    # 输入层
    model.add(tf.keras.layers.Input(shape=input_shape))

    # LSTM层
    for i in range(num_layers):
        return_sequences = True if i < num_layers - 1 else False

        model.add(tf.keras.layers.LSTM(
            units=units,
            return_sequences=return_sequences,
            dropout=dropout,
            recurrent_dropout=dropout
        ))

    return model

# 使用示例
if __name__ == "__main__":
    # 创建模型
    model = create_lstm_model(
        input_shape=(50, 100),  # (seq_len, input_dim)
        units=256,
        num_layers=2,
        dropout=0.1
    )

    # 测试输入
    x = tf.random.normal((32, 50, 100))
    output = model(x)

    print(f"输入形状: {x.shape}")
    print(f"输出形状: {output.shape}")

    # 模型摘要
    model.summary()</code></pre>
                </div>
            </div>
        </section>

        <!-- 实时演示 -->
        <section id="visualization" class="section-card">
            <h2 style="color: var(--accent-green); margin-bottom: 2rem;">🚀 实时情感分析演示</h2>

            <div class="live-demo">
                <div class="live-demo-content">
                    <p style="margin-bottom: 1.5rem; font-size: 1.1rem;">
                        输入一句话，实时查看LSTM如何处理并分析情感（支持实时预测下一个字）：
                    </p>

                    <div class="input-group">
                        <div style="position: relative; flex: 1;">
                            <input type="text"
                                   class="live-demo-input"
                                   id="sentimentInput"
                                   placeholder="例如：这个产品太棒了！我非常喜欢！"
                                   value="">
                            <div class="prediction-preview" id="predictionPreview"></div>
                        </div>

                        <button class="analyze-btn" id="analyzeBtn">
                            分析情感 ✨
                        </button>
                    </div>

                    <div class="live-demo-output">
                        <div class="demo-result-card">
                            <h4 style="color: var(--accent-pink); margin-bottom: 1rem;">😊 预测结果</h4>
                            <div id="predictionResult" style="text-align: center;">
                                <div style="font-size: 4rem; margin-bottom: 1rem;">🤔</div>
                                <div style="font-size: 1.5rem; font-weight: bold; color: var(--text-secondary);">
                                    等待输入...
                                </div>
                            </div>
                        </div>

                        <div class="demo-result-card">
                            <h4 style="color: var(--accent-blue); margin-bottom: 1rem;">🚪 门激活值</h4>
                            <div id="gateActivations">
                                <canvas id="gateChart" width="400" height="250"></canvas>
                            </div>
                        </div>
                    </div>

                    <div style="margin-top: 2rem;">
                        <h4 style="color: var(--accent-cyan); margin-bottom: 1rem;">📈 处理过程可视化</h4>
                        <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 1.5rem;">
                            <div>
                                <h5 style="color: var(--accent-pink); margin-bottom: 0.5rem;">细胞状态变化</h5>
                                <canvas id="cellStateChart" width="300" height="200"></canvas>
                            </div>
                            <div>
                                <h5 style="color: var(--accent-green); margin-bottom: 0.5rem;">隐藏状态热图</h5>
                                <canvas id="hiddenStateChart" width="300" height="200"></canvas>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </section>

        <!-- 实战应用 -->
        <section id="practice" class="section-card">
            <h2 style="color: var(--accent-pink); margin-bottom: 2rem;">⚔️ 实战：用LSTM生成音乐</h2>

            <div class="story-card">
                <p style="font-size: 1.2rem; line-height: 1.8; margin-bottom: 2rem;">
                    让我们用LSTM创建一个音乐生成器，体验长期记忆在序列生成中的威力！
                </p>
            </div>

            <div class="practice-section">
                <h3 style="color: var(--accent-yellow); margin-bottom: 1.5rem;">🎵 智能音乐生成器</h3>

                <!-- 虚拟钢琴键盘 -->
                <div style="background: rgba(255, 255, 255, 0.05); padding: 2rem; border-radius: 1rem; margin-bottom: 2rem;">
                    <h4 style="color: var(--accent-cyan); margin-bottom: 1rem;">🎹 输入种子旋律</h4>
                    <p style="margin-bottom: 1rem; color: var(--text-secondary);">点击钢琴键输入一小段旋律，LSTM将续写：</p>

                    <div class="piano-keyboard" id="pianoKeyboard">
                        <!-- 钢琴键将通过JS动态生成 -->
                    </div>

                    <div style="margin-top: 1rem; display: flex; gap: 1rem; align-items: center; flex-wrap: wrap;">
                        <div style="display: flex; align-items: center; gap: 0.5rem;">
                            <span>种子旋律：</span>
                            <div id="seedMelody" style="background: rgba(255, 255, 255, 0.1); padding: 0.5rem 1rem; border-radius: 0.5rem; min-width: 100px; font-family: monospace;">
                                []
                            </div>
                        </div>
                        <button class="btn btn-secondary" onclick="window.lstmTutorial.clearMelody()">🗑️ 清空</button>
                        <button class="btn btn-primary" onclick="window.lstmTutorial.generateFromSeed()">🎼 续写旋律</button>
                    </div>
                </div>

                <!-- 预设情绪按钮 -->
                <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 1rem; margin-bottom: 2rem;">
                    <button class="btn btn-primary" onclick="window.lstmTutorial.generateMelody('happy')">
                        😊 生成欢快旋律
                    </button>
                    <button class="btn btn-primary" onclick="window.lstmTutorial.generateMelody('sad')">
                        😢 生成忧伤旋律
                    </button>
                    <button class="btn btn-primary" onclick="window.lstmTutorial.generateMelody('energetic')">
                        ⚡ 生成激昂旋律
                    </button>
                    <button class="btn btn-primary" onclick="window.lstmTutorial.generateMelody('calm')">
                        🌊 生成平静旋律
                    </button>
                </div>

                <div id="musicVisualizer" style="background: rgba(255, 255, 255, 0.05); padding: 2rem; border-radius: 1rem;">
                    <canvas id="musicCanvas" width="100%" height="300"></canvas>
                </div>

                <div style="margin-top: 2rem;">
                    <audio id="musicPlayer" controls style="width: 100%;"></audio>
                </div>
            </div>
        </section>

        <!-- 练习与思考 -->
        <section id="exercises" class="section-card">
            <h2 style="color: var(--accent-purple); margin-bottom: 2rem;">📝 练习与思考</h2>

            <div class="practice-section">
                <div class="practice-item">
                    <h3 style="color: var(--accent-blue); margin-bottom: 1rem;">
                        练习1：手动计算LSTM前向传播
                    </h3>
                    <p>给定以下参数，手动计算一步LSTM的输出：</p>
                    <div style="background: rgba(255, 255, 255, 0.05); padding: 1.5rem; border-radius: 0.5rem; margin: 1rem 0;">
                        <code>
                            x_t = [0.5, -0.2], h_{t-1} = [0.3, 0.1], C_{t-1} = [0.8, -0.4]<br>
                            W_f = [[0.1, 0.2, -0.1, 0.3], [0.2, -0.1, 0.1, 0.2]], b_f = [0.5, 0.5]
                        </code>
                    </div>
                    <div class="practice-solution">
                        <h4 style="color: var(--accent-green); margin-bottom: 1rem;">解答：</h4>
                        <div style="padding: 1rem; background: rgba(34, 197, 94, 0.1); border-radius: 0.5rem;">
                            <p><strong>步骤1：</strong>拼接输入 [h_{t-1}, x_t] = [0.3, 0.1, 0.5, -0.2]</p>
                            <p><strong>步骤2：</strong>计算遗忘门</p>
                            <p>z_f = W_f · [0.3, 0.1, 0.5, -0.2]^T + [0.5, 0.5]^T</p>
                            <p>= [0.1×0.3 + 0.2×0.1 + (-0.1)×0.5 + 0.3×(-0.2), 0.2×0.3 + (-0.1)×0.1 + 0.1×0.5 + 0.2×(-0.2)] + [0.5, 0.5]</p>
                            <p>= [-0.04, 0.09] + [0.5, 0.5] = [0.46, 0.59]</p>
                            <p><strong>步骤3：</strong>应用sigmoid激活</p>
                            <p>f_t = σ([0.46, 0.59]) = [0.613, 0.643]</p>
                        </div>
                    </div>
                </div>

                <div class="practice-item">
                    <h3 style="color: var(--accent-pink); margin-bottom: 1rem;">
                        练习2：分析梯度传播
                    </h3>
                    <p>证明：当遗忘门 f_t = 1 且输入门 i_t = 0 时，梯度可以无损传播。</p>
                    <div class="practice-solution">
                        <h4 style="color: var(--accent-green); margin-bottom: 1rem;">解答思路：</h4>
                        <div style="padding: 1rem; background: rgba(34, 197, 94, 0.1); border-radius: 0.5rem;">
                            <p>当 f_t = 1, i_t = 0 时：</p>
                            <p>C_t = f_t ⊙ C_{t-1} + i_t ⊙ C̃_t = 1 ⊙ C_{t-1} + 0 ⊙ C̃_t = C_{t-1}</p>
                            <p>因此：∂C_t/∂C_{t-1} = ∂C_{t-1}/∂C_{t-1} = I（单位矩阵）</p>
                            <p>梯度完全保留，实现无损传播！</p>
                        </div>
                    </div>
                </div>

                <div class="practice-item">
                    <h3 style="color: var(--accent-orange); margin-bottom: 1rem;">
                        练习3：门的相关性分析
                    </h3>
                    <p>在实际应用中，遗忘门和输入门往往呈现负相关。解释这种现象的原因。</p>
                    <div class="practice-solution">
                        <h4 style="color: var(--accent-green); margin-bottom: 1rem;">解答：</h4>
                        <div style="padding: 1rem; background: rgba(34, 197, 94, 0.1); border-radius: 0.5rem;">
                            <p><strong>直观解释：</strong>细胞状态的"容量"有限。当需要存储新信息时，通常需要先遗忘一些旧信息腾出空间。</p>
                            <p><strong>数学角度：</strong>为了保持C_t的数值稳定，f_t + i_t ≈ 1 是一个合理的约束。</p>
                            <p><strong>实际意义：</strong>这体现了LSTM的"选择性更新"特性——有选择地遗忘和记忆。</p>
                        </div>
                    </div>
                </div>

                <div class="practice-item">
                    <h3 style="color: var(--accent-cyan); margin-bottom: 1rem;">
                        练习4：LSTM变种设计
                    </h3>
                    <p>设计一个介于LSTM和GRU之间的模型，只使用两个门但保留独立的细胞状态。</p>
                    <div class="practice-solution">
                        <h4 style="color: var(--accent-green); margin-bottom: 1rem;">设计思路：</h4>
                        <div style="padding: 1rem; background: rgba(34, 197, 94, 0.1); border-radius: 0.5rem;">
                            <p><strong>简化方案：</strong>合并遗忘门和输入门为"更新门"z_t</p>
                            <p>f_t = z_t, i_t = 1 - z_t</p>
                            <p>C_t = z_t ⊙ C_{t-1} + (1-z_t) ⊙ C̃_t</p>
                            <p>h_t = o_t ⊙ tanh(C_t)</p>
                            <p><strong>优势：</strong>参数减少25%，计算更高效，同时保留细胞状态的梯度高速路。</p>
                        </div>
                    </div>
                </div>
            </div>

            <div class="think-card" style="margin-top: 2rem;">
                <h3>🤔 深度思考题</h3>
                <ol style="margin-left: 1.5rem; line-height: 2;">
                    <li><strong>应用场景：</strong>为什么LSTM在处理文本时通常比处理图像更有效？</li>
                    <li><strong>认知对比：</strong>如何解释LSTM中的"记忆"与人类记忆的相似性和差异？</li>
                    <li><strong>模型选择：</strong>在什么情况下，简单的RNN可能比LSTM表现更好？</li>
                    <li><strong>架构优化：</strong>LSTM的哪些设计可以被进一步简化而不显著影响性能？</li>
                    <li><strong>未来发展：</strong>随着Transformer的兴起，LSTM还有哪些独特优势？</li>
                </ol>
            </div>
        </section>

        <!-- 总结与展望 -->
        <section id="summary" class="section-card">
            <h2 style="color: var(--accent-purple); margin-bottom: 2rem;">🎯 本章总结：LSTM的精妙设计</h2>

            <div class="concept-grid">
                <div class="concept-card forget">
                    <h3 style="color: var(--accent-pink); margin-bottom: 1rem;">🎯 核心创新</h3>
                    <ul style="margin-left: 1.5rem;">
                        <li>细胞状态：线性信息高速公路</li>
                        <li>门控机制：精确的信息流控制</li>
                        <li>梯度高速路：解决长期依赖</li>
                        <li>模块化设计：清晰的数学结构</li>
                    </ul>
                </div>

                <div class="concept-card input">
                    <h3 style="color: var(--accent-blue); margin-bottom: 1rem;">💡 设计智慧</h3>
                    <ul style="margin-left: 1.5rem;">
                        <li>遗忘门：选择性遗忘</li>
                        <li>输入门：选择性记忆</li>
                        <li>输出门：按需提取</li>
                        <li>线性路径：梯度保护</li>
                    </ul>
                </div>

                <div class="concept-card output">
                    <h3 style="color: var(--accent-green); margin-bottom: 1rem;">🚀 应用领域</h3>
                    <ul style="margin-left: 1.5rem;">
                        <li>自然语言处理</li>
                        <li>语音识别</li>
                        <li>时序预测</li>
                        <li>音乐生成</li>
                    </ul>
                </div>

                <div class="concept-card cell">
                    <h3 style="color: var(--accent-orange); margin-bottom: 1rem;">⚠️ 局限性</h3>
                    <ul style="margin-left: 1.5rem;">
                        <li>计算复杂度高</li>
                        <li>难以并行化</li>
                        <li>参数量大</li>
                        <li>训练时间长</li>
                    </ul>
                </div>
            </div>

            <div class="timeline" style="margin-top: 3rem;">
                <div class="timeline-item">
                    <div class="timeline-dot"></div>
                    <h4 style="color: var(--accent-pink);">过去：RNN时代</h4>
                    <p>简单但梯度消失严重</p>
                </div>
                <div class="timeline-item">
                    <div class="timeline-dot"></div>
                    <h4 style="color: var(--accent-blue);">现在：LSTM主导</h4>
                    <p>解决长期依赖，广泛应用</p>
                </div>
                <div class="timeline-item">
                    <div class="timeline-dot"></div>
                    <h4 style="color: var(--accent-green);">未来：Transformer崛起</h4>
                    <p>并行计算，自注意力机制</p>
                </div>
                <div class="timeline-item">
                    <div class="timeline-dot"></div>
                    <h4 style="color: var(--accent-orange);">展望：混合架构</h4>
                    <p>LSTM + Attention 优势互补</p>
                </div>
            </div>

            <div class="tip success" style="margin-top: 3rem;">
                <span style="font-size: 2rem;">🎓</span>
                <div>
                    <h3 style="margin-bottom: 1rem;">学习LSTM的收获</h3>
                    <p style="font-size: 1.1rem; line-height: 1.8;">
                        通过本章的深度学习，你已经掌握了：<br>
                        • LSTM如何通过巧妙的门控机制解决梯度消失问题<br>
                        • 细胞状态作为信息高速公路的设计智慧<br>
                        • 从零实现LSTM的完整代码和数学推导<br>
                        • LSTM与GRU的详细对比和选择策略<br>
                        • 在实际应用中的优化技巧和最佳实践
                    </p>
                    <p style="margin-top: 1rem; font-size: 1.2rem; color: var(--accent-cyan);">
                        <strong>下一步：</strong>学习Transformer和自注意力机制，了解序列建模的最新突破！
                    </p>
                </div>
            </div>
        </section>

        <!-- 参考资源 -->
        <section class="section-card" style="background: linear-gradient(135deg, rgba(6, 182, 212, 0.1), rgba(59, 130, 246, 0.05));">
            <h2 style="color: var(--accent-cyan); margin-bottom: 2rem;">📚 延伸阅读与资源</h2>

            <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(300px, 1fr)); gap: 2rem;">
                <div style="background: rgba(255, 255, 255, 0.05); padding: 2rem; border-radius: 1rem;">
                    <h3 style="color: var(--accent-blue); margin-bottom: 1rem;">📄 经典论文</h3>
                    <ul style="line-height: 2;">
                        <li><strong>Hochreiter & Schmidhuber (1997)</strong> - Long Short-Term Memory</li>
                        <li><strong>Gers et al. (2000)</strong> - Learning to Forget: Continual Prediction with LSTM</li>
                        <li><strong>Graves (2013)</strong> - Generating Sequences with RNNs</li>
                        <li><strong>Cho et al. (2014)</strong> - Learning Phrase Representations using RNN Encoder-Decoder for Statistical Machine Translation (GRU)</li>
                    </ul>
                </div>

                <div style="background: rgba(255, 255, 255, 0.05); padding: 2rem; border-radius: 1rem;">
                    <h3 style="color: var(--accent-green); margin-bottom: 1rem;">🎥 推荐教程</h3>
                    <ul style="line-height: 2;">
                        <li><strong>Christopher Olah</strong> - Understanding LSTM Networks</li>
                        <li><strong>Andrej Karpathy</strong> - The Unreasonable Effectiveness of RNNs</li>
                        <li><strong>Fast.ai</strong> - Practical Deep Learning Course</li>
                        <li><strong>DeepLearning.ai</strong> - Sequence Models Course</li>
                    </ul>
                </div>

                <div style="background: rgba(255, 255, 255, 0.05); padding: 2rem; border-radius: 1rem;">
                    <h3 style="color: var(--accent-orange); margin-bottom: 1rem;">💻 代码资源</h3>
                    <ul style="line-height: 2;">
                        <li><strong>PyTorch</strong> - LSTM Tutorial & Examples</li>
                        <li><strong>TensorFlow</strong> - RNN Guide & Best Practices</li>
                        <li><strong>Keras</strong> - Sequential Models Documentation</li>
                        <li><strong>GitHub</strong> - LSTM Implementation Gallery</li>
                    </ul>
                </div>

                <div style="background: rgba(255, 255, 255, 0.05); padding: 2rem; border-radius: 1rem;">
                    <h3 style="color: var(--accent-purple); margin-bottom: 1rem;">🔬 进阶主题</h3>
                    <ul style="line-height: 2;">
                        <li><strong>Attention Mechanisms</strong> - 注意力机制</li>
                        <li><strong>Transformer Architecture</strong> - 自注意力模型</li>
                        <li><strong>BERT & GPT</strong> - 预训练语言模型</li>
                        <li><strong>Neural Architecture Search</strong> - 自动化架构设计</li>
                    </ul>
                </div>
            </div>
        </section>

        <!-- 结语 -->
        <section class="section-card" style="background: var(--lstm-gradient); color: #0f172a; margin-bottom: 0;">
            <div style="text-align: center; padding: 2rem;">
                <h2 style="font-size: 3rem; margin-bottom: 1.5rem;">🎊 恭喜完成本章学习！</h2>
                <p style="font-size: 1.3rem; margin-bottom: 2rem; line-height: 1.8;">
                    你已经深度掌握了LSTM的精髓 —— 通过精妙的门控设计让神经网络学会选择性的遗忘与记忆。<br>
                    这不仅是深度学习历史上的重要里程碑，更是通向现代AI的关键基石。<br>
                    <strong>从RNN的困境到LSTM的突破，你见证了AI如何学会"记忆"！</strong>
                </p>
                <div style="display: flex; justify-content: center; gap: 2rem; flex-wrap: wrap;">
                    <a href="#" class="btn" style="background: white; color: #0f172a; padding: 1rem 2rem; font-size: 1.1rem; text-decoration: none;">
                        ⬅️ 上一章：RNN基础
                    </a>
                    <a href="#" class="btn" style="background: #0f172a; color: white; padding: 1rem 2rem; font-size: 1.1rem; text-decoration: none;">
                        下一章：注意力机制 ➡️
                    </a>
                </div>
            </div>
        </section>

    </div>
</main>

<!-- 页脚 -->
<footer style="background: var(--bg-section); padding: 3rem 0; border-top: 1px solid var(--border-color);">
    <div class="container">
        <div style="text-align: center; color: var(--text-secondary);">
            <p style="margin-bottom: 1rem; font-size: 1.1rem;">
                📖 深度学习序列建模 | 第8章：长短期记忆网络LSTM
            </p>
            <p style="margin-bottom: 1rem;">
                用❤️制作 | 让AI知识触手可及 |
                <span style="color: var(--accent-cyan);">交互式学习，深度理解</span>
            </p>
            <p style="font-size: 0.9rem; color: var(--text-muted);">
                © 2024 Deep Learning Tutorial Series. 教育目的使用。
            </p>
        </div>
    </div>
</footer>

<!-- JavaScript模块化封装 -->
<script>
    (function() {
        'use strict';

        // ===== 全局模块对象 =====
        window.lstmTutorial = {
            // 状态管理
            state: {
                currentStep: 0,
                totalSteps: 4,
                animationsEnabled: true,
                seedMelody: [],
                currentInputText: '',
                savedUserInput: localStorage.getItem('lstm-tutorial-input') || '这个产品太棒了！我非常喜欢！'
            },

            // ===== 初始化函数 =====
            init: function() {
                this.setupEventListeners();
                this.createBackgroundAnimation();
                this.initializeComponents();
                this.restoreUserState();
                console.log('🧠 LSTM交互式教程已加载完成！');
            },

            // ===== 事件监听器设置 =====
            setupEventListeners: function() {
                // 导航相关
                const toggleSidebar = document.getElementById('toggle-sidebar');
                const sidebar = document.getElementById('sidebar');

                if (toggleSidebar && sidebar) {
                    toggleSidebar.addEventListener('click', () => {
                        sidebar.classList.toggle('open');
                    });
                }

                // 滚动相关
                this.setupScrollHandlers();

                // 交互式元素
                this.setupInteractiveElements();

                // 步进动画控制
                this.setupStepAnimation();

                // 代码层切换
                this.setupCodeLayerTabs();

                // 思考题交互
                this.setupThinkingQuestions();

                // 实时演示
                this.setupLiveDemo();

                // 钢琴键盘
                this.setupPianoKeyboard();

                // 主题和动画切换
                this.setupThemeControls();
            },

            // ===== 滚动处理 =====
            setupScrollHandlers: function() {
                const navHeader = document.querySelector('.nav-header');
                let lastScrollTop = 0;

                window.addEventListener('scroll', () => {
                    const scrollTop = window.pageYOffset || document.documentElement.scrollTop;

                    // 自动隐藏导航栏
                    if (scrollTop > lastScrollTop && scrollTop > 100) {
                        navHeader?.classList.add('hidden');
                    } else {
                        navHeader?.classList.remove('hidden');
                    }
                    lastScrollTop = scrollTop;

                    // 更新进度条
                    this.updateProgressBar();

                    // 更新侧边栏高亮
                    this.updateSidebarHighlight();
                });
            },

            // ===== 进度条更新 =====
            updateProgressBar: function() {
                const winScroll = document.body.scrollTop || document.documentElement.scrollTop;
                const height = document.documentElement.scrollHeight - document.documentElement.clientHeight;
                const scrolled = (winScroll / height) * 100;
                const progressBar = document.getElementById('progress-bar');
                if (progressBar) {
                    progressBar.style.width = scrolled + '%';
                }
            },

            // ===== 侧边栏高亮更新 =====
            updateSidebarHighlight: function() {
                const sections = document.querySelectorAll('section[id]');
                const tocItems = document.querySelectorAll('.toc-item');
                let current = '';

                sections.forEach(section => {
                    const sectionTop = section.offsetTop;
                    if (pageYOffset >= sectionTop - 200) {
                        current = section.getAttribute('id');
                    }
                });

                tocItems.forEach(item => {
                    item.classList.remove('active');
                    if (item.getAttribute('href') === `#${current}`) {
                        item.classList.add('active');
                    }
                });
            },

            // ===== 交互式元素设置 =====
            setupInteractiveElements: function() {
                // 公式高亮交互
                document.querySelectorAll('.highlight-target').forEach(elem => {
                    elem.addEventListener('mouseenter', () => {
                        const symbol = elem.getAttribute('data-symbol');
                        this.highlightSymbol(symbol, true);
                    });

                    elem.addEventListener('mouseleave', () => {
                        const symbol = elem.getAttribute('data-symbol');
                        this.highlightSymbol(symbol, false);
                    });

                    // 添加点击功能，显示详细解释
                    elem.addEventListener('click', () => {
                        const symbol = elem.getAttribute('data-symbol');
                        this.showSymbolDetails(symbol);
                    });
                });

                // 练习题展开
                document.querySelectorAll('.practice-item').forEach(item => {
                    item.addEventListener('click', function() {
                        this.classList.toggle('open');
                    });
                });

                // 折叠控制
                document.querySelectorAll('.collapsible-header').forEach(header => {
                    header.addEventListener('click', function() {
                        const collapsible = this.closest('.collapsible');
                        collapsible.classList.toggle('open');
                    });
                });
            },

            // ===== 符号高亮 =====
            highlightSymbol: function(symbol, highlight) {
                // 高亮所有相关元素
                document.querySelectorAll(`[data-symbol="${symbol}"]`).forEach(elem => {
                    if (highlight) {
                        elem.classList.add('highlight-active');
                    } else {
                        elem.classList.remove('highlight-active');
                    }
                });

                // 高亮对应的含义项
                document.querySelectorAll('.meaning-item').forEach(item => {
                    const strongText = item.querySelector('strong')?.textContent || '';
                    if (strongText.includes(symbol.replace('_', ''))) {
                        if (highlight) {
                            item.style.background = 'rgba(79, 172, 254, 0.2)';
                            item.style.borderColor = 'var(--accent-blue)';
                        } else {
                            item.style.background = '';
                            item.style.borderColor = 'transparent';
                        }
                    }
                });

                // 实时联动：在公式演示区域添加高亮
                if (highlight) {
                    this.triggerLiveHighlight(symbol);
                }
            },

            // ===== 实时联动高亮 =====
            triggerLiveHighlight: function(symbol) {
                const forgetGateExplainer = document.getElementById('forgetGateExplainer');
                if (forgetGateExplainer) {
                    const targetElement = forgetGateExplainer.querySelector(`[data-symbol="${symbol}"]`);
                    if (targetElement) {
                        targetElement.classList.add('live-highlight');
                        setTimeout(() => {
                            targetElement.classList.remove('live-highlight');
                        }, 1000);
                    }
                }
            },

            // ===== 符号详细信息 =====
            showSymbolDetails: function(symbol) {
                const details = {
                    'f_t': {
                        title: '遗忘门 f_t',
                        description: '遗忘门决定从细胞状态中丢弃哪些信息。它的输出在[0,1]之间，0表示完全遗忘，1表示完全保留。',
                        formula: 'f_t = σ(W_f · [h_{t-1}, x_t] + b_f)'
                    },
                    'i_t': {
                        title: '输入门 i_t',
                        description: '输入门决定新信息的重要性权重。配合候选值C̃_t，共同决定需要存储的新信息。',
                        formula: 'i_t = σ(W_i · [h_{t-1}, x_t] + b_i)'
                    },
                    'o_t': {
                        title: '输出门 o_t',
                        description: '输出门控制基于细胞状态输出什么信息给隐藏状态。',
                        formula: 'o_t = σ(W_o · [h_{t-1}, x_t] + b_o)'
                    },
                    'sigma': {
                        title: 'Sigmoid函数 σ',
                        description: 'Sigmoid函数将任意实数映射到[0,1]区间，在LSTM中用作"门"，控制信息通过的比例。',
                        formula: 'σ(x) = 1/(1 + e^(-x))'
                    }
                };

                const detail = details[symbol];
                if (detail) {
                    // 创建弹窗显示详细信息
                    this.showModal(detail);
                }
            },

            // ===== 模态框显示 =====
            showModal: function(content) {
                // 移除已存在的模态框
                const existingModal = document.querySelector('.symbol-modal');
                if (existingModal) {
                    existingModal.remove();
                }

                // 创建新的模态框
                const modal = document.createElement('div');
                modal.className = 'symbol-modal';
                modal.innerHTML = `
                <div class="modal-overlay" onclick="this.parentElement.remove()">
                    <div class="modal-content" onclick="event.stopPropagation()">
                        <div class="modal-header">
                            <h3>${content.title}</h3>
                            <button class="modal-close" onclick="this.closest('.symbol-modal').remove()">×</button>
                        </div>
                        <div class="modal-body">
                            <p>${content.description}</p>
                            <div class="modal-formula">
                                <code>${content.formula}</code>
                            </div>
                        </div>
                    </div>
                </div>
            `;

                // 添加样式
                const style = document.createElement('style');
                style.textContent = `
                .symbol-modal {
                    position: fixed;
                    top: 0;
                    left: 0;
                    right: 0;
                    bottom: 0;
                    z-index: 10000;
                }
                .modal-overlay {
                    width: 100%;
                    height: 100%;
                    background: rgba(0, 0, 0, 0.8);
                    display: flex;
                    align-items: center;
                    justify-content: center;
                    padding: 2rem;
                }
                .modal-content {
                    background: var(--bg-section);
                    border-radius: 1rem;
                    max-width: 500px;
                    width: 100%;
                    border: 1px solid var(--border-color);
                    box-shadow: 0 20px 60px rgba(0, 0, 0, 0.5);
                    animation: modalAppear 0.3s ease;
                }
                @keyframes modalAppear {
                    from { opacity: 0; transform: scale(0.9); }
                    to { opacity: 1; transform: scale(1); }
                }
                .modal-header {
                    display: flex;
                    justify-content: space-between;
                    align-items: center;
                    padding: 1.5rem;
                    border-bottom: 1px solid var(--border-color);
                }
                .modal-header h3 {
                    color: var(--accent-cyan);
                    margin: 0;
                }
                .modal-close {
                    background: none;
                    border: none;
                    color: var(--text-secondary);
                    font-size: 1.5rem;
                    cursor: pointer;
                    padding: 0.5rem;
                    border-radius: 0.25rem;
                    transition: all 0.3s ease;
                }
                .modal-close:hover {
                    background: rgba(255, 255, 255, 0.1);
                    color: var(--text-primary);
                }
                .modal-body {
                    padding: 1.5rem;
                }
                .modal-body p {
                    line-height: 1.6;
                    margin-bottom: 1rem;
                }
                .modal-formula {
                    background: rgba(255, 255, 255, 0.05);
                    padding: 1rem;
                    border-radius: 0.5rem;
                    border-left: 4px solid var(--accent-cyan);
                }
                .modal-formula code {
                    font-size: 1.1rem;
                    color: var(--accent-cyan);
                }
            `;
                document.head.appendChild(style);

                document.body.appendChild(modal);
            },

            // ===== 步进动画设置 =====
            setupStepAnimation: function() {
                // 步骤点击
                document.querySelectorAll('.step-dot').forEach(dot => {
                    dot.addEventListener('click', () => {
                        this.state.currentStep = parseInt(dot.getAttribute('data-step'));
                        this.updateStep();
                    });
                });

                // 导航按钮
                const prevBtn = document.getElementById('prevStep');
                const nextBtn = document.getElementById('nextStep');

                if (prevBtn) {
                    prevBtn.addEventListener('click', () => {
                        if (this.state.currentStep > 0) {
                            this.state.currentStep--;
                            this.updateStep();
                        }
                    });
                }

                if (nextBtn) {
                    nextBtn.addEventListener('click', () => {
                        if (this.state.currentStep < this.state.totalSteps - 1) {
                            this.state.currentStep++;
                            this.updateStep();
                        }
                    });
                }
            },

            // ===== 步骤更新 =====
            updateStep: function() {
                // 更新步骤指示器
                document.querySelectorAll('.step-dot').forEach((dot, index) => {
                    dot.classList.toggle('active', index === this.state.currentStep);
                });

                // 更新步骤内容
                document.querySelectorAll('.step-visual').forEach((visual, index) => {
                    visual.classList.toggle('active', index === this.state.currentStep);
                });

                // 更新按钮状态
                const prevBtn = document.getElementById('prevStep');
                const nextBtn = document.getElementById('nextStep');

                if (prevBtn) prevBtn.disabled = this.state.currentStep === 0;
                if (nextBtn) nextBtn.disabled = this.state.currentStep === this.state.totalSteps - 1;
            },

            // ===== 代码层切换设置 =====
            setupCodeLayerTabs: function() {
                document.querySelectorAll('.code-layer-tab').forEach(tab => {
                    tab.addEventListener('click', function() {
                        const layer = this.getAttribute('data-layer');

                        // 更新标签状态
                        document.querySelectorAll('.code-layer-tab').forEach(t => t.classList.remove('active'));
                        this.classList.add('active');

                        // 更新内容显示
                        document.querySelectorAll('.code-layer-content').forEach(content => {
                            if (content.getAttribute('data-layer-content') === layer) {
                                content.classList.add('active');
                            } else {
                                content.classList.remove('active');
                            }
                        });
                    });
                });
            },

            // ===== 思考题交互设置 =====
            setupThinkingQuestions: function() {
                document.querySelectorAll('.think-option').forEach(option => {
                    option.addEventListener('click', function() {
                        const answer = this.getAttribute('data-answer');
                        const thinkCard = this.closest('.think-card');
                        const feedbackId = thinkCard.querySelector('.think-feedback').id;

                        // 移除其他选项的选中状态
                        this.parentElement.querySelectorAll('.think-option').forEach(opt => {
                            opt.classList.remove('selected');
                        });

                        // 添加选中状态
                        this.classList.add('selected');

                        // 显示反馈
                        window.lstmTutorial.showThinkFeedback(feedbackId, answer);
                    });
                });
            },

            // ===== 思考题反馈 =====
            showThinkFeedback: function(feedbackId, answer) {
                const feedbackElement = document.getElementById(feedbackId);
                const feedbacks = {
                    'thinkFeedback1': {
                        'a': { correct: false, text: '速度确实是个问题，但不是RNN失败的主要原因。RNN的计算虽然不能并行化，但这不是导致长序列建模失败的根本原因。' },
                        'b': { correct: true, text: '🎯 完全正确！梯度消失/爆炸是RNN处理长序列失败的根本原因。当序列很长时，梯度会指数级衰减，使得网络无法学习到长距离的依赖关系。LSTM正是为了解决这个问题而设计的。' },
                        'c': { correct: false, text: 'RNN的参数量其实相对较少，这不是主要问题。相比之下，现代的Transformer模型参数量更大，但性能更好。' },
                        'd': { correct: false, text: '激活函数的选择确实会影响性能，但即使使用最优的激活函数，RNN仍然无法根本解决梯度消失问题。' }
                    },
                    'thinkFeedback2': {
                        'a': { correct: false, text: '增加模型容量不是主要目的。实际上，分离设计有时会增加计算复杂度。' },
                        'b': { correct: true, text: '🎯 正确！分离"什么"（候选值C̃_t）和"多少"（权重i_t）让网络可以更精确地控制信息流。这就像是分别决定"要存储的内容"和"存储的重要程度"，提供了更细粒度的控制。' },
                        'c': { correct: false, text: '实际上这样的设计增加了计算量，需要计算两个独立的向量。' },
                        'd': { correct: false, text: '虽然有一定的生物学合理性，但主要还是为了更好的信息控制能力。' }
                    }
                };

                const feedback = feedbacks[feedbackId]?.[answer];
                if (feedback) {
                    feedbackElement.innerHTML = `
                    <div style="padding: 1rem; background: ${feedback.correct ? 'rgba(34, 197, 94, 0.1)' : 'rgba(239, 68, 68, 0.1)'}; border-radius: 0.5rem; border-left: 4px solid ${feedback.correct ? 'var(--accent-green)' : 'var(--accent-red)'};">
                        <p style="font-weight: bold; color: ${feedback.correct ? 'var(--accent-green)' : 'var(--accent-red)'}; margin-bottom: 0.5rem;">
                            ${feedback.correct ? '✅ 正确！' : '❌ 不太对哦'}
                        </p>
                        <p style="line-height: 1.6;">${feedback.text}</p>
                    </div>
                `;
                    feedbackElement.classList.add('show');
                }
            },

            // ===== 实时演示设置 =====
            setupLiveDemo: function() {
                const input = document.getElementById('sentimentInput');
                const analyzeBtn = document.getElementById('analyzeBtn');
                const predictionPreview = document.getElementById('predictionPreview');

                if (input) {
                    // 设置保存的用户输入
                    input.value = this.state.savedUserInput;

                    // 实时输入预测
                    let timeoutId;
                    input.addEventListener('input', (e) => {
                        this.state.currentInputText = e.target.value;

                        // 保存用户输入
                        localStorage.setItem('lstm-tutorial-input', e.target.value);

                        // 防抖处理
                        clearTimeout(timeoutId);
                        timeoutId = setTimeout(() => {
                            this.showNextCharPrediction(e.target.value);
                        }, 300);
                    });

                    // 焦点事件
                    input.addEventListener('focus', () => {
                        if (predictionPreview) {
                            predictionPreview.style.display = 'block';
                        }
                    });

                    input.addEventListener('blur', () => {
                        setTimeout(() => {
                            if (predictionPreview) {
                                predictionPreview.style.display = 'none';
                            }
                        }, 200);
                    });
                }

                if (analyzeBtn) {
                    analyzeBtn.addEventListener('click', async () => {
                        await this.analyzeSentiment();
                    });
                }
            },

            // ===== 下一字符预测 =====
            showNextCharPrediction: function(text) {
                const predictionPreview = document.getElementById('predictionPreview');
                if (!predictionPreview || !text.trim()) return;

                // 简单的下一字符预测逻辑
                const predictions = this.predictNextChar(text);

                if (predictions.length > 0) {
                    const input = document.getElementById('sentimentInput');
                    const rect = input.getBoundingClientRect();

                    predictionPreview.style.left = (rect.left + text.length * 8) + 'px';
                    predictionPreview.style.top = (rect.top - 40) + 'px';
                    predictionPreview.innerHTML = `
                    <div style="font-size: 0.9rem;">
                        <div style="color: var(--accent-cyan); margin-bottom: 0.25rem;">可能的下一个字：</div>
                        ${predictions.map(p => `<span style="margin-right: 0.5rem; color: var(--accent-green);">${p}</span>`).join('')}
                    </div>
                `;
                    predictionPreview.style.display = 'block';
                }
            },

            // ===== 预测下一个字符 =====
            predictNextChar: function(text) {
                // 简化的规则基预测
                const patterns = {
                    '这个': ['产品', '东西', '想法'],
                    '太': ['棒了', '好了', '差了'],
                    '我': ['很', '非常', '觉得'],
                    '很': ['好', '棒', '喜欢'],
                    '非常': ['好', '棒', '满意'],
                    '不': ['错', '好', '行']
                };

                // 获取最后几个字符
                const lastChars = text.slice(-2);
                return patterns[lastChars] || patterns[text.slice(-1)] || ['好', '的', '了'];
            },

            // ===== 情感分析 =====
            analyzeSentiment: async function() {
                const input = document.getElementById('sentimentInput');
                const btn = document.getElementById('analyzeBtn');

                if (!input || !btn) return;

                const text = input.value.trim();
                if (!text) {
                    alert('请输入一些文字进行分析！');
                    return;
                }

                // 添加加载动画
                btn.innerHTML = '<span class="loading"></span> 分析中...';
                btn.disabled = true;

                // 模拟处理延迟
                await new Promise(resolve => setTimeout(resolve, 1500));

                // 执行分析
                const result = this.performSentimentAnalysis(text);
                this.updatePredictionResult(result);
                this.drawGateActivations(text);
                this.drawCellStateChart();
                this.drawHiddenStateChart();

                // 实时联动：高亮相关公式部分
                this.triggerFormulaHighlight();

                // 恢复按钮
                btn.innerHTML = '分析情感 ✨';
                btn.disabled = false;
            },

            // ===== 执行情感分析 =====
            performSentimentAnalysis: function(text) {
                // 情感词典
                const positiveWords = ['棒', '好', '喜欢', '优秀', '推荐', '满意', '完美', '赞', '太好了', '不错', '很棒', '喜爱', '厉害'];
                const negativeWords = ['差', '糟', '失望', '不好', '垃圾', '讨厌', '糟糕', '烂', '太差', '不行', '不满', '讨厌'];
                const neutralWords = ['还行', '一般', '普通', '凑合', '还可以'];

                let score = 0.5; // 基础分数
                let wordCount = 0;

                // 分析正面词汇
                positiveWords.forEach(word => {
                    const count = (text.match(new RegExp(word, 'g')) || []).length;
                    score += count * 0.15;
                    wordCount += count;
                });

                // 分析负面词汇
                negativeWords.forEach(word => {
                    const count = (text.match(new RegExp(word, 'g')) || []).length;
                    score -= count * 0.2;
                    wordCount += count;
                });

                // 分析中性词汇
                neutralWords.forEach(word => {
                    const count = (text.match(new RegExp(word, 'g')) || []).length;
                    score += count * 0.02;
                    wordCount += count;
                });

                // 文本长度影响
                if (text.length > 10) score += 0.05;
                if (text.includes('！') || text.includes('!')) score += 0.1;
                if (text.includes('？') || text.includes('?')) score -= 0.05;

                // 确保分数在合理范围内
                score = Math.max(0.1, Math.min(0.9, score));

                return {
                    score: score,
                    confidence: Math.min(0.95, 0.6 + wordCount * 0.1),
                    wordCount: wordCount,
                    textLength: text.length
                };
            },

            // ===== 更新预测结果 =====
            updatePredictionResult: function(result) {
                const resultDiv = document.getElementById('predictionResult');
                if (!resultDiv) return;

                const isPositive = result.score > 0.5;
                const sentiment = isPositive ? '正面情感' : '负面情感';
                const emoji = isPositive ? '😊' : '😔';
                const color = isPositive ? 'var(--accent-green)' : 'var(--accent-red)';

                resultDiv.innerHTML = `
                <div style="font-size: 4rem; margin-bottom: 1rem;">${emoji}</div>
                <div style="font-size: 1.5rem; font-weight: bold; color: ${color}; margin-bottom: 0.5rem;">
                    ${sentiment}
                </div>
                <div style="font-size: 1.2rem; color: var(--text-secondary); margin-bottom: 1rem;">
                    置信度：${Math.round(result.confidence * 100)}%
                </div>
                <div style="margin-top: 1.5rem;">
                    <div style="background: rgba(255, 255, 255, 0.1); border-radius: 0.5rem; height: 20px; overflow: hidden;">
                        <div style="height: 100%; width: ${result.confidence * 100}%; background: ${color}; transition: width 0.8s ease; border-radius: 0.5rem;"></div>
                    </div>
                </div>
                <div style="margin-top: 1rem; font-size: 0.9rem; color: var(--text-muted);">
                    分析了 ${result.textLength} 个字符，识别出 ${result.wordCount} 个情感词汇
                </div>
            `;
            },

            // ===== 公式联动高亮 =====
            triggerFormulaHighlight: function() {
                // 依次高亮各个门的公式
                const symbols = ['f_t', 'i_t', 'o_t'];
                let index = 0;

                const highlightNext = () => {
                    if (index < symbols.length) {
                        this.highlightSymbol(symbols[index], true);
                        setTimeout(() => {
                            this.highlightSymbol(symbols[index], false);
                            index++;
                            setTimeout(highlightNext, 200);
                        }, 800);
                    }
                };

                setTimeout(highlightNext, 500);
            },

            // ===== 绘制门激活图 =====
            drawGateActivations: function(text = '') {
                const canvas = document.getElementById('gateChart');
                if (!canvas) return;

                const ctx = canvas.getContext('2d');
                canvas.width = 400;
                canvas.height = 250;

                // 清空画布
                ctx.clearRect(0, 0, canvas.width, canvas.height);

                // 根据文本内容模拟门激活值
                const sentiment = this.performSentimentAnalysis(text);
                const gates = {
                    '遗忘门': 0.3 + Math.random() * 0.4, // 遗忘不重要信息
                    '输入门': 0.6 + Math.random() * 0.3, // 接受新信息
                    '输出门': Math.max(0.4, sentiment.score) + Math.random() * 0.2 // 基于情感输出
                };

                const colors = ['#f5576c', '#4facfe', '#43e97b'];
                const labels = Object.keys(gates);
                const values = Object.values(gates);

                // 绘制动画柱状图
                const barWidth = 80;
                const spacing = 40;
                const startX = (canvas.width - (barWidth * 3 + spacing * 2)) / 2;

                values.forEach((value, i) => {
                    const x = startX + i * (barWidth + spacing);
                    const maxHeight = 150;
                    const height = value * maxHeight;
                    const y = canvas.height - height - 60;

                    // 绘制柱子（带动画效果）
                    const gradient = ctx.createLinearGradient(0, y, 0, y + height);
                    gradient.addColorStop(0, colors[i]);
                    gradient.addColorStop(1, colors[i] + '80');

                    ctx.fillStyle = gradient;
                    ctx.fillRect(x, y, barWidth, height);

                    // 绘制边框
                    ctx.strokeStyle = colors[i];
                    ctx.lineWidth = 2;
                    ctx.strokeRect(x, y, barWidth, height);

                    // 绘制标签
                    ctx.fillStyle = '#f1f5f9';
                    ctx.font = 'bold 14px Arial';
                    ctx.textAlign = 'center';
                    ctx.fillText(labels[i], x + barWidth/2, canvas.height - 35);

                    // 绘制数值
                    ctx.fillStyle = colors[i];
                    ctx.font = 'bold 16px Arial';
                    ctx.fillText((value * 100).toFixed(0) + '%', x + barWidth/2, y - 10);
                });

                // 绘制网格线
                ctx.strokeStyle = 'rgba(255, 255, 255, 0.1)';
                ctx.lineWidth = 1;
                for (let i = 0; i <= 5; i++) {
                    const y = canvas.height - 60 - (i * 30);
                    ctx.beginPath();
                    ctx.moveTo(startX - 10, y);
                    ctx.lineTo(startX + barWidth * 3 + spacing * 2 + 10, y);
                    ctx.stroke();
                }
            },

            // ===== 绘制细胞状态图 =====
            drawCellStateChart: function() {
                const canvas = document.getElementById('cellStateChart');
                if (!canvas) return;

                const ctx = canvas.getContext('2d');
                canvas.width = canvas.offsetWidth || 300;
                canvas.height = 200;

                // 清空画布
                ctx.clearRect(0, 0, canvas.width, canvas.height);

                // 模拟细胞状态变化
                const steps = 20;
                const values = [];
                let current = 0;

                for (let i = 0; i < steps; i++) {
                    // 添加一些趋势和随机变化
                    const trend = Math.sin(i * 0.3) * 0.3;
                    const noise = (Math.random() - 0.5) * 0.2;
                    current = current * 0.7 + trend + noise;
                    values.push(current);
                }

                // 绘制折线图
                const stepWidth = canvas.width / steps;
                const midY = canvas.height / 2;
                const scale = 60;

                // 背景网格
                ctx.strokeStyle = 'rgba(255, 255, 255, 0.1)';
                ctx.lineWidth = 1;
                for (let i = 0; i <= 4; i++) {
                    const y = (canvas.height / 4) * i;
                    ctx.beginPath();
                    ctx.moveTo(0, y);
                    ctx.lineTo(canvas.width, y);
                    ctx.stroke();
                }

                // 绘制细胞状态线
                ctx.strokeStyle = '#fa709a';
                ctx.lineWidth = 3;
                ctx.beginPath();

                values.forEach((value, i) => {
                    const x = i * stepWidth;
                    const y = midY - value * scale;

                    if (i === 0) {
                        ctx.moveTo(x, y);
                    } else {
                        ctx.lineTo(x, y);
                    }

                    // 绘制数据点
                    ctx.save();
                    ctx.fillStyle = '#fa709a';
                    ctx.beginPath();
                    ctx.arc(x, y, 3, 0, 2 * Math.PI);
                    ctx.fill();
                    ctx.restore();
                });

                ctx.stroke();

                // 绘制基准线
                ctx.strokeStyle = 'rgba(255, 255, 255, 0.3)';
                ctx.lineWidth = 1;
                ctx.setLineDash([5, 5]);
                ctx.beginPath();
                ctx.moveTo(0, midY);
                ctx.lineTo(canvas.width, midY);
                ctx.stroke();
                ctx.setLineDash([]);

                // 标签
                ctx.fillStyle = '#f1f5f9';
                ctx.font = '12px Arial';
                ctx.fillText('时间 →', canvas.width - 50, canvas.height - 10);
                ctx.save();
                ctx.translate(15, canvas.height / 2);
                ctx.rotate(-Math.PI / 2);
                ctx.fillText('细胞状态值', 0, 0);
                ctx.restore();
            },

            // ===== 绘制隐藏状态热图 =====
            drawHiddenStateChart: function() {
                const canvas = document.getElementById('hiddenStateChart');
                if (!canvas) return;

                const ctx = canvas.getContext('2d');
                canvas.width = canvas.offsetWidth || 300;
                canvas.height = 200;

                // 清空画布
                ctx.clearRect(0, 0, canvas.width, canvas.height);

                // 模拟隐藏状态热图
                const width = 24;
                const height = 12;
                const cellWidth = canvas.width / width;
                const cellHeight = canvas.height / height;

                for (let i = 0; i < width; i++) {
                    for (let j = 0; j < height; j++) {
                        const value = Math.random();

                        // 使用更丰富的颜色映射
                        let r, g, b;
                        if (value > 0.7) {
                            // 高激活 - 红色
                            r = Math.floor(255 * value);
                            g = Math.floor(100 * (1 - value));
                            b = Math.floor(100 * (1 - value));
                        } else if (value > 0.3) {
                            // 中等激活 - 蓝色
                            r = Math.floor(100 * value);
                            g = Math.floor(150 * value);
                            b = Math.floor(255 * value);
                        } else {
                            // 低激活 - 绿色
                            r = Math.floor(100 * value);
                            g = Math.floor(200 * value);
                            b = Math.floor(150 * value);
                        }

                        ctx.fillStyle = `rgb(${r}, ${g}, ${b})`;
                        ctx.fillRect(i * cellWidth, j * cellHeight, cellWidth - 1, cellHeight - 1);
                    }
                }

                // 添加标签
                ctx.fillStyle = '#f1f5f9';
                ctx.font = '10px Arial';
                ctx.fillText('隐藏层维度 →', canvas.width - 80, canvas.height - 5);
                ctx.save();
                ctx.translate(5, 20);
                ctx.rotate(-Math.PI / 2);
                ctx.fillText('时间步', 0, 0);
                ctx.restore();
            },

            // ===== 钢琴键盘设置 =====
            setupPianoKeyboard: function() {
                const keyboard = document.getElementById('pianoKeyboard');
                if (!keyboard) return;

                // 清空现有内容
                keyboard.innerHTML = '';

                // 创建钢琴键
                const whiteKeys = ['C', 'D', 'E', 'F', 'G', 'A', 'B'];
                const blackKeys = ['C#', 'D#', null, 'F#', 'G#', 'A#', null];

                for (let octave = 4; octave <= 5; octave++) {
                    for (let i = 0; i < whiteKeys.length; i++) {
                        // 白键
                        const whiteKey = document.createElement('div');
                        whiteKey.className = 'piano-key';
                        whiteKey.dataset.note = whiteKeys[i] + octave;
                        whiteKey.addEventListener('click', () => {
                            this.playNote(whiteKeys[i] + octave);
                        });
                        keyboard.appendChild(whiteKey);

                        // 黑键
                        if (blackKeys[i]) {
                            const blackKey = document.createElement('div');
                            blackKey.className = 'piano-key black';
                            blackKey.dataset.note = blackKeys[i] + octave;
                            blackKey.addEventListener('click', () => {
                                this.playNote(blackKeys[i] + octave);
                            });
                            keyboard.appendChild(blackKey);
                        }
                    }
                }
            },

            // ===== 播放音符 =====
            playNote: function(note) {
                // 音符到频率的映射
                const noteFreq = {
                    'C4': 261.63, 'C#4': 277.18, 'D4': 293.66, 'D#4': 311.13,
                    'E4': 329.63, 'F4': 349.23, 'F#4': 369.99, 'G4': 392.00,
                    'G#4': 415.30, 'A4': 440.00, 'A#4': 466.16, 'B4': 493.88,
                    'C5': 523.25, 'C#5': 554.37, 'D5': 587.33, 'D#5': 622.25,
                    'E5': 659.25, 'F5': 698.46, 'F#5': 739.99, 'G5': 783.99,
                    'G#5': 830.61, 'A5': 880.00, 'A#5': 932.33, 'B5': 987.77
                };

                const freq = noteFreq[note];
                if (!freq) return;

                // 添加到种子旋律
                this.state.seedMelody.push(note);
                this.updateSeedMelodyDisplay();

                // 高亮按键
                const key = document.querySelector(`[data-note="${note}"]`);
                if (key) {
                    key.classList.add('active');
                    setTimeout(() => {
                        key.classList.remove('active');
                    }, 200);
                }

                // 使用Web Audio API播放音符
                this.playSynthNote(freq);
            },

            // ===== 合成音频播放 =====
            playSynthNote: function(frequency) {
                if (!window.AudioContext && !window.webkitAudioContext) return;

                const audioContext = new (window.AudioContext || window.webkitAudioContext)();
                const oscillator = audioContext.createOscillator();
                const gainNode = audioContext.createGain();

                oscillator.connect(gainNode);
                gainNode.connect(audioContext.destination);

                oscillator.frequency.setValueAtTime(frequency, audioContext.currentTime);
                oscillator.type = 'sine';

                gainNode.gain.setValueAtTime(0.3, audioContext.currentTime);
                gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.5);

                oscillator.start(audioContext.currentTime);
                oscillator.stop(audioContext.currentTime + 0.5);
            },

            // ===== 更新种子旋律显示 =====
            updateSeedMelodyDisplay: function() {
                const display = document.getElementById('seedMelody');
                if (display) {
                    if (this.state.seedMelody.length === 0) {
                        display.textContent = '[]';
                    } else {
                        display.textContent = `[${this.state.seedMelody.join(', ')}]`;
                    }
                }
            },

            // ===== 清空旋律 =====
            clearMelody: function() {
                this.state.seedMelody = [];
                this.updateSeedMelodyDisplay();
            },

            // ===== 从种子生成旋律 =====
            generateFromSeed: function() {
                if (this.state.seedMelody.length === 0) {
                    alert('请先在钢琴上输入一些音符作为种子旋律！');
                    return;
                }

                // 基于种子生成更长的旋律
                const generatedMelody = this.extendMelody(this.state.seedMelody);
                this.visualizeMelody(generatedMelody, '种子续写');
            },

            // ===== 扩展旋律 =====
            extendMelody: function(seed) {
                const allNotes = ['C4', 'D4', 'E4', 'F4', 'G4', 'A4', 'B4', 'C5', 'D5', 'E5', 'F5', 'G5'];
                const extended = [...seed];

                // 简单的马尔可夫链生成
                for (let i = 0; i < 8; i++) {
                    const lastNote = extended[extended.length - 1];
                    const lastIndex = allNotes.indexOf(lastNote);

                    if (lastIndex !== -1) {
                        // 倾向于选择相邻的音符
                        const choices = [
                            lastIndex - 1,
                            lastIndex,
                            lastIndex + 1,
                            lastIndex + 2
                        ].filter(idx => idx >= 0 && idx < allNotes.length);

                        const nextIndex = choices[Math.floor(Math.random() * choices.length)];
                        extended.push(allNotes[nextIndex]);
                    } else {
                        extended.push(allNotes[Math.floor(Math.random() * allNotes.length)]);
                    }
                }

                return extended;
            },

            // ===== 生成预设旋律 =====
            generateMelody: function(mood) {
                const melodyPatterns = {
                    happy: ['C4', 'E4', 'G4', 'C5', 'G4', 'E4', 'C4', 'E4', 'G4', 'C5'],
                    sad: ['A4', 'F4', 'D4', 'F4', 'A4', 'G4', 'F4', 'E4', 'D4', 'C4'],
                    energetic: ['C4', 'C4', 'G4', 'G4', 'A4', 'A4', 'G4', 'F4', 'F4', 'E4'],
                    calm: ['C4', 'D4', 'E4', 'F4', 'E4', 'D4', 'C4', 'D4', 'E4', 'C4']
                };

                const melody = melodyPatterns[mood] || melodyPatterns.happy;
                this.visualizeMelody(melody, this.getMoodTitle(mood));
            },

            // ===== 获取情绪标题 =====
            getMoodTitle: function(mood) {
                const titles = {
                    happy: '😊 欢快旋律',
                    sad: '😢 忧伤旋律',
                    energetic: '⚡ 激昂旋律',
                    calm: '🌊 平静旋律'
                };
                return titles[mood] || '🎵 生成旋律';
            },

            // ===== 可视化旋律 =====
            visualizeMelody: function(melody, title = '生成的旋律') {
                const canvas = document.getElementById('musicCanvas');
                if (!canvas) return;

                const ctx = canvas.getContext('2d');
                canvas.width = canvas.offsetWidth || 800;
                canvas.height = 300;

                // 清空画布
                ctx.clearRect(0, 0, canvas.width, canvas.height);

                if (melody.length === 0) return;

                // 音符映射到Y坐标
                const noteToY = {
                    'C4': 250, 'C#4': 240, 'D4': 230, 'D#4': 220, 'E4': 210,
                    'F4': 200, 'F#4': 190, 'G4': 180, 'G#4': 170, 'A4': 160,
                    'A#4': 150, 'B4': 140, 'C5': 130, 'C#5': 120, 'D5': 110,
                    'D#5': 100, 'E5': 90, 'F5': 80, 'F#5': 70, 'G5': 60
                };

                const noteWidth = canvas.width / melody.length;

                // 绘制五线谱背景
                ctx.strokeStyle = 'rgba(255, 255, 255, 0.2)';
                ctx.lineWidth = 1;
                for (let i = 0; i < 5; i++) {
                    const y = 160 + i * 20;
                    ctx.beginPath();
                    ctx.moveTo(0, y);
                    ctx.lineTo(canvas.width, y);
                    ctx.stroke();
                }

                // 绘制标题
                ctx.fillStyle = '#f1f5f9';
                ctx.font = 'bold 18px Arial';
                ctx.textAlign = 'center';
                ctx.fillText(title, canvas.width / 2, 30);

                // 绘制音符
                melody.forEach((note, i) => {
                    const x = i * noteWidth + noteWidth / 2;
                    const y = noteToY[note] || 160;

                    // 绘制音符
                    ctx.beginPath();
                    ctx.arc(x, y, 8, 0, 2 * Math.PI);
                    ctx.fillStyle = this.getNoteColor(note);
                    ctx.fill();
                    ctx.strokeStyle = 'white';
                    ctx.lineWidth = 2;
                    ctx.stroke();

                    // 连接线
                    if (i > 0) {
                        const prevY = noteToY[melody[i-1]] || 160;
                        ctx.beginPath();
                        ctx.moveTo((i-1) * noteWidth + noteWidth / 2, prevY);
                        ctx.lineTo(x, y);
                        ctx.strokeStyle = this.getNoteColor(note);
                        ctx.lineWidth = 3;
                        ctx.stroke();
                    }

                    // 音符标签
                    ctx.fillStyle = 'white';
                    ctx.font = '10px Arial';
                    ctx.textAlign = 'center';
                    ctx.fillText(note, x, y + 25);
                });

                // 播放旋律
                this.playMelody(melody);
            },

            // ===== 获取音符颜色 =====
            getNoteColor: function(note) {
                const colors = {
                    'C': '#ff4757', 'D': '#ff6b7a', 'E': '#ffa502',
                    'F': '#ffda79', 'G': '#7bed9f', 'A': '#5352ed',
                    'B': '#a4b0be'
                };
                return colors[note[0]] || '#70a1ff';
            },

            // ===== 播放旋律 =====
            playMelody: function(melody) {
                if (!melody || melody.length === 0) return;

                melody.forEach((note, index) => {
                    setTimeout(() => {
                        this.playNote(note);
                    }, index * 400);
                });
            },

            // ===== 主题控制设置 =====
            setupThemeControls: function() {
                const themeToggle = document.getElementById('toggle-theme');
                const animationToggle = document.getElementById('toggle-animations');

                if (themeToggle) {
                    themeToggle.addEventListener('click', () => {
                        document.body.classList.toggle('light-theme');
                        // 可以在这里添加更多主题切换逻辑
                    });
                }

                if (animationToggle) {
                    animationToggle.addEventListener('click', () => {
                        this.state.animationsEnabled = !this.state.animationsEnabled;
                        document.body.style.setProperty('--animation-duration',
                            this.state.animationsEnabled ? '0.3s' : '0s');

                        animationToggle.innerHTML = this.state.animationsEnabled ?
                            '<svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><circle cx="12" cy="12" r="10"></circle><path d="M10 8l6 4-6 4V8z"></path></svg>' :
                            '<svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><circle cx="12" cy="12" r="10"></circle><rect x="9" y="9" width="6" height="6"></rect></svg>';
                    });
                }
            },

            // ===== 梯度消失动画 =====
            animateGradientVanishing: function() {
                const canvas = document.getElementById('gradientVanishingCanvas');
                if (!canvas) return;

                const ctx = canvas.getContext('2d');
                canvas.width = 900;
                canvas.height = 300;

                let step = 0;
                const totalSteps = 20;

                const animate = () => {
                    ctx.clearRect(0, 0, canvas.width, canvas.height);

                    // 绘制标题
                    ctx.fillStyle = '#f1f5f9';
                    ctx.font = 'bold 16px Arial';
                    ctx.textAlign = 'center';
                    ctx.fillText('RNN梯度传播：每层衰减90%', canvas.width / 2, 30);

                    // 绘制时间步
                    const stepWidth = canvas.width / totalSteps;

                    for (let i = 0; i <= step; i++) {
                        const x = i * stepWidth;
                        const gradientStrength = Math.pow(0.9, i); // 每步衰减90%

                        // 绘制梯度强度条
                        const barHeight = gradientStrength * 200;
                        ctx.fillStyle = `rgba(239, 68, 68, ${gradientStrength})`;
                        ctx.fillRect(x + 5, 250 - barHeight, stepWidth - 10, barHeight);

                        // 绘制边框
                        ctx.strokeStyle = '#ef4444';
                        ctx.lineWidth = 1;
                        ctx.strokeRect(x + 5, 250 - barHeight, stepWidth - 10, barHeight);

                        // 绘制时间步标签
                        ctx.fillStyle = '#f1f5f9';
                        ctx.font = '12px Arial';
                        ctx.textAlign = 'center';
                        ctx.fillText(`t=${i+1}`, x + stepWidth/2, 275);

                        // 绘制数值
                        ctx.fillStyle = gradientStrength > 0.1 ? '#f1f5f9' : '#ef4444';
                        ctx.font = '10px Arial';
                        ctx.fillText(gradientStrength.toFixed(3), x + stepWidth/2, 150);
                    }

                    // 绘制警告信息
                    if (step >= 10) {
                        ctx.fillStyle = '#ef4444';
                        ctx.font = 'bold 14px Arial';
                        ctx.textAlign = 'center';
                        ctx.fillText('梯度几乎消失！无法学习长期依赖', canvas.width / 2, canvas.height - 20);
                    }

                    step++;
                    if (step <= totalSteps) {
                        setTimeout(animate, 300);
                    }
                };

                animate();
            },

            // ===== 重置梯度动画 =====
            resetGradientAnimation: function() {
                const canvas = document.getElementById('gradientVanishingCanvas');
                if (!canvas) return;

                const ctx = canvas.getContext('2d');
                ctx.clearRect(0, 0, canvas.width, canvas.height);

                // 绘制初始状态
                ctx.fillStyle = '#f1f5f9';
                ctx.font = 'bold 16px Arial';
                ctx.textAlign = 'center';
                ctx.fillText('点击"演示梯度消失"按钮开始', canvas.width / 2, canvas.height / 2);
            },

            // ===== LSTM单元交互功能 =====
            highlightForgetGate: function() {
                this.updateGateDescription('forget', '#f5576c');
                this.drawLSTMHighlight('forget');
            },

            highlightInputGate: function() {
                this.updateGateDescription('input', '#4facfe');
                this.drawLSTMHighlight('input');
            },

            highlightOutputGate: function() {
                this.updateGateDescription('output', '#43e97b');
                this.drawLSTMHighlight('output');
            },

            animateDataFlow: function() {
                this.updateGateDescription('flow', '#a8edea');
                this.drawLSTMDataFlow();
            },

            // ===== 更新门描述 =====
            updateGateDescription: function(gateType, color) {
                const descriptions = {
                    forget: {
                        title: '遗忘门 (Forget Gate)',
                        formula: 'f_t = σ(W_f · [h_{t-1}, x_t] + b_f)',
                        description: '遗忘门决定从细胞状态中丢弃什么信息。它查看 h_{t-1} 和 x_t，输出一个 0 到 1 之间的数值给每个细胞状态。1 表示"完全保留"，0 表示"完全丢弃"。这个门让LSTM能够主动遗忘不再重要的历史信息。',
                        keyPoints: ['选择性遗忘过时信息', '输出范围[0,1]', '0=完全遗忘，1=完全保留', 'Sigmoid激活函数']
                    },
                    input: {
                        title: '输入门 (Input Gate)',
                        formula: 'i_t = σ(W_i · [h_{t-1}, x_t] + b_i)',
                        description: '输入门决定什么新信息要存储到细胞状态中。它包含两部分：sigmoid 层决定哪些值要更新，tanh 层创建新的候选值向量。两者结合实现选择性的信息存储。',
                        keyPoints: ['控制新信息的重要性', '与候选值配合工作', '实现选择性更新', '防止信息过载']
                    },
                    output: {
                        title: '输出门 (Output Gate)',
                        formula: 'o_t = σ(W_o · [h_{t-1}, x_t] + b_o)',
                        description: '输出门决定基于细胞状态输出什么。首先运行 sigmoid 层决定细胞状态的哪些部分要输出，然后将细胞状态通过 tanh 并乘以 sigmoid 的输出，得到最终的隐藏状态。',
                        keyPoints: ['控制输出信息', '基于细胞状态过滤', 'tanh压缩到[-1,1]', '产生最终隐藏状态']
                    },
                    flow: {
                        title: '数据流动 (Data Flow)',
                        formula: 'C_t = f_t ⊙ C_{t-1} + i_t ⊙ C̃_t',
                        description: '观察数据如何在LSTM中流动：输入经过三个门的处理，细胞状态在高速公路上线性传播，最终通过输出门产生隐藏状态。这种设计确保了梯度的稳定传播。',
                        keyPoints: ['信息高速公路', '线性细胞状态传播', '三门协同工作', '梯度稳定传播']
                    }
                };

                const desc = descriptions[gateType];
                if (!desc) return;

                const descriptionDiv = document.getElementById('gateDescription');
                if (descriptionDiv) {
                    descriptionDiv.innerHTML = `
                    <div style="border-left: 4px solid ${color}; padding-left: 1rem;">
                        <h3 style="color: ${color}; margin-bottom: 1rem; display: flex; align-items: center; gap: 0.5rem;">
                            ${desc.title}
                            <span style="font-size: 0.8rem; background: rgba(255,255,255,0.1); padding: 0.25rem 0.5rem; border-radius: 0.25rem;">实时分析</span>
                        </h3>
                        <div style="background: rgba(255, 255, 255, 0.05); padding: 1rem; border-radius: 0.5rem; margin-bottom: 1rem;">
                            <code style="font-size: 1.1rem; color: ${color};">${desc.formula}</code>
                        </div>
                        <p style="line-height: 1.8; margin-bottom: 1rem;">${desc.description}</p>
                        <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 0.5rem;">
                            ${desc.keyPoints.map(point => `
                                <div style="background: rgba(255,255,255,0.05); padding: 0.5rem; border-radius: 0.25rem; font-size: 0.9rem;">
                                    • ${point}
                                </div>
                            `).join('')}
                        </div>
                    </div>
                `;
                }
            },

            // ===== 绘制LSTM高亮 =====
            drawLSTMHighlight: function(gateType) {
                const canvas = document.getElementById('lstmCanvas');
                if (!canvas) return;

                const ctx = canvas.getContext('2d');
                canvas.width = canvas.offsetWidth;
                canvas.height = 500;

                // 清空画布
                ctx.clearRect(0, 0, canvas.width, canvas.height);

                // 绘制基本LSTM结构
                this.drawBasicLSTMStructure(ctx, canvas.width, canvas.height);

                // 高亮特定门
                this.highlightSpecificGate(ctx, canvas.width, canvas.height, gateType);
            },

            // ===== 绘制基本LSTM结构 =====
            drawBasicLSTMStructure: function(ctx, width, height) {
                // 绘制细胞状态高速公路
                ctx.strokeStyle = '#a8edea';
                ctx.lineWidth = 6;
                ctx.beginPath();
                ctx.moveTo(50, height/2);
                ctx.lineTo(width - 50, height/2);
                ctx.stroke();

                // 添加箭头
                this.drawArrow(ctx, width - 80, height/2, width - 50, height/2, '#a8edea');

                // 绘制细胞状态标签
                ctx.fillStyle = '#a8edea';
                ctx.font = 'bold 16px Arial';
                ctx.textAlign = 'center';
                ctx.fillText('细胞状态 C_t', width/2, height/2 - 20);

                // 绘制门的位置
                const gates = [
                    { name: '遗忘门', x: width * 0.25, y: height * 0.25, color: '#f5576c', symbol: 'f_t' },
                    { name: '输入门', x: width * 0.5, y: height * 0.25, color: '#4facfe', symbol: 'i_t' },
                    { name: '输出门', x: width * 0.75, y: height * 0.75, color: '#43e97b', symbol: 'o_t' }
                ];

                gates.forEach(gate => {
                    // 绘制门圆圈
                    ctx.beginPath();
                    ctx.arc(gate.x, gate.y, 35, 0, 2 * Math.PI);
                    ctx.fillStyle = gate.color + '40';
                    ctx.fill();
                    ctx.strokeStyle = gate细：</strong>独立控制遗忘和记忆</li>
                </ul>

                    <div style="margin: 1.5rem 0;">
                        <canvas id="lstmArchCanvas" width="300" height="200"></canvas>
                    </div>

                    <div class="tip info">
                        <span>💡</span>
                        <div>
                            <strong>优势：</strong>表达能力强，适合复杂任务<br>
                            <strong>劣势：</strong>参数多，训练慢
                        </div>
                    </div>
                </div>

                    <!-- JavaScript模块化封装 -->
                    <script>
                        (function() {
                        'use strict';

                        // ===== 全局模块对象 =====
                        window.lstmTutorial = {
                        // 状态管理
                        state: {
                        currentStep: 0,
                        totalSteps: 4,
                        animationsEnabled: true,
                        seedMelody: [],
                        currentInputText: '',
                        savedUserInput: localStorage.getItem('lstm-tutorial-input') || '这个产品太棒了！我非常喜欢！'
                    },

                        // ===== 初始化函数 =====
                        init: function() {
                        this.setupEventListeners();
                        this.createBackgroundAnimation();
                        this.initializeComponents();
                        this.restoreUserState();
                        console.log('🧠 LSTM交互式教程已加载完成！');
                    },

                        // ===== 事件监听器设置 =====
                        setupEventListeners: function() {
                        // 导航相关
                        const toggleSidebar = document.getElementById('toggle-sidebar');
                        const sidebar = document.getElementById('sidebar');

                        if (toggleSidebar && sidebar) {
                        toggleSidebar.addEventListener('click', () => {
                        sidebar.classList.toggle('open');
                    });
                    }

                        // 滚动相关
                        this.setupScrollHandlers();

                        // 交互式元素
                        this.setupInteractiveElements();

                        // 步进动画控制
                        this.setupStepAnimation();

                        // 代码层切换
                        this.setupCodeLayerTabs();

                        // 思考题交互
                        this.setupThinkingQuestions();

                        // 实时演示
                        this.setupLiveDemo();

                        // 钢琴键盘
                        this.setupPianoKeyboard();

                        // 主题和动画切换
                        this.setupThemeControls();
                    },

                        // ===== 滚动处理 =====
                        setupScrollHandlers: function() {
                        const navHeader = document.querySelector('.nav-header');
                        let lastScrollTop = 0;

                        window.addEventListener('scroll', () => {
                        const scrollTop = window.pageYOffset || document.documentElement.scrollTop;

                        // 自动隐藏导航栏
                        if (scrollTop > lastScrollTop && scrollTop > 100) {
                        navHeader?.classList.add('hidden');
                    } else {
                        navHeader?.classList.remove('hidden');
                    }
                        lastScrollTop = scrollTop;

                        // 更新进度条
                        this.updateProgressBar();

                        // 更新侧边栏高亮
                        this.updateSidebarHighlight();
                    });
                    },

                        // ===== 进度条更新 =====
                        updateProgressBar: function() {
                        const winScroll = document.body.scrollTop || document.documentElement.scrollTop;
                        const height = document.documentElement.scrollHeight - document.documentElement.clientHeight;
                        const scrolled = (winScroll / height) * 100;
                        const progressBar = document.getElementById('progress-bar');
                        if (progressBar) {
                        progressBar.style.width = scrolled + '%';
                    }
                    },

                        // ===== 侧边栏高亮更新 =====
                        updateSidebarHighlight: function() {
                        const sections = document.querySelectorAll('section[id]');
                        const tocItems = document.querySelectorAll('.toc-item');
                        let current = '';

                        sections.forEach(section => {
                        const sectionTop = section.offsetTop;
                        if (pageYOffset >= sectionTop - 200) {
                        current = section.getAttribute('id');
                    }
                    });

                        tocItems.forEach(item => {
                        item.classList.remove('active');
                        if (item.getAttribute('href') === `#${current}`) {
                        item.classList.add('active');
                    }
                    });
                    },

                        // ===== 交互式元素设置 =====
                        setupInteractiveElements: function() {
                        // 公式高亮交互
                        document.querySelectorAll('.highlight-target').forEach(elem => {
                        elem.addEventListener('mouseenter', () => {
                        const symbol = elem.getAttribute('data-symbol');
                        this.highlightSymbol(symbol, true);
                    });

                        elem.addEventListener('mouseleave', () => {
                        const symbol = elem.getAttribute('data-symbol');
                        this.highlightSymbol(symbol, false);
                    });

                        // 添加点击功能，显示详细解释
                        elem.addEventListener('click', () => {
                        const symbol = elem.getAttribute('data-symbol');
                        this.showSymbolDetails(symbol);
                    });
                    });

                        // 练习题展开
                        document.querySelectorAll('.practice-item').forEach(item => {
                        item.addEventListener('click', function() {
                        this.classList.toggle('open');
                    });
                    });

                        // 折叠控制
                        document.querySelectorAll('.collapsible-header').forEach(header => {
                        header.addEventListener('click', function() {
                        const collapsible = this.closest('.collapsible');
                        collapsible.classList.toggle('open');
                    });
                    });
                    },

                        // ===== 符号高亮 =====
                        highlightSymbol: function(symbol, highlight) {
                        // 高亮所有相关元素
                        document.querySelectorAll(`[data-symbol="${symbol}"]`).forEach(elem => {
                        if (highlight) {
                        elem.classList.add('highlight-active');
                    } else {
                        elem.classList.remove('highlight-active');
                    }
                    });

                        // 高亮对应的含义项
                        document.querySelectorAll('.meaning-item').forEach(item => {
                        const strongText = item.querySelector('strong')?.textContent || '';
                        if (strongText.includes(symbol.replace('_', ''))) {
                        if (highlight) {
                        item.style.background = 'rgba(79, 172, 254, 0.2)';
                        item.style.borderColor = 'var(--accent-blue)';
                    } else {
                        item.style.background = '';
                        item.style.borderColor = 'transparent';
                    }
                    }
                    });

                        // 实时联动：在公式演示区域添加高亮
                        if (highlight) {
                        this.triggerLiveHighlight(symbol);
                    }
                    },

                        // ===== 实时联动高亮 =====
                        triggerLiveHighlight: function(symbol) {
                        const forgetGateExplainer = document.getElementById('forgetGateExplainer');
                        if (forgetGateExplainer) {
                        const targetElement = forgetGateExplainer.querySelector(`[data-symbol="${symbol}"]`);
                        if (targetElement) {
                        targetElement.classList.add('live-highlight');
                        setTimeout(() => {
                        targetElement.classList.remove('live-highlight');
                    }, 1000);
                    }
                    }
                    },

                        // ===== 符号详细信息 =====
                        showSymbolDetails: function(symbol) {
                        const details = {
                        'f_t': {
                        title: '遗忘门 f_t',
                        description: '遗忘门决定从细胞状态中丢弃哪些信息。它的输出在[0,1]之间，0表示完全遗忘，1表示完全保留。',
                        formula: 'f_t = σ(W_f · [h_{t-1}, x_t] + b_f)'
                    },
                        'i_t': {
                        title: '输入门 i_t',
                        description: '输入门决定新信息的重要性权重。配合候选值C̃_t，共同决定需要存储的新信息。',
                        formula: 'i_t = σ(W_i · [h_{t-1}, x_t] + b_i)'
                    },
                        'o_t': {
                        title: '输出门 o_t',
                        description: '输出门控制基于细胞状态输出什么信息给隐藏状态。',
                        formula: 'o_t = σ(W_o · [h_{t-1}, x_t] + b_o)'
                    },
                        'sigma': {
                        title: 'Sigmoid函数 σ',
                        description: 'Sigmoid函数将任意实数映射到[0,1]区间，在LSTM中用作"门"，控制信息通过的比例。',
                        formula: 'σ(x) = 1/(1 + e^(-x))'
                    }
                    };

                        const detail = details[symbol];
                        if (detail) {
                        // 创建弹窗显示详细信息
                        this.showModal(detail);
                    }
                    },

                        // ===== 模态框显示 =====
                        showModal: function(content) {
                        // 移除已存在的模态框
                        const existingModal = document.querySelector('.symbol-modal');
                        if (existingModal) {
                        existingModal.remove();
                    }

                        // 创建新的模态框
                        const modal = document.createElement('div');
                        modal.className = 'symbol-modal';
                        modal.innerHTML = `
                <div class="modal-overlay" onclick="this.parentElement.remove()">
                    <div class="modal-content" onclick="event.stopPropagation()">
                        <div class="modal-header">
                            <h3>${content.title}</h3>
                            <button class="modal-close" onclick="this.closest('.symbol-modal').remove()">×</button>
                        </div>
                        <div class="modal-body">
                            <p>${content.description}</p>
                            <div class="modal-formula">
                                <code>${content.formula}</code>
                            </div>
                        </div>
                    </div>
                </div>
            `;

                        // 添加样式
                        const style = document.createElement('style');
                        style.textContent = `
                .symbol-modal {
                    position: fixed;
                    top: 0;
                    left: 0;
                    right: 0;
                    bottom: 0;
                    z-index: 10000;
                }
                .modal-overlay {
                    width: 100%;
                    height: 100%;
                    background: rgba(0, 0, 0, 0.8);
                    display: flex;
                    align-items: center;
                    justify-content: center;
                    padding: 2rem;
                }
                .modal-content {
                    background: var(--bg-section);
                    border-radius: 1rem;
                    max-width: 500px;
                    width: 100%;
                    border: 1px solid var(--border-color);
                    box-shadow: 0 20px 60px rgba(0, 0, 0, 0.5);
                    animation: modalAppear 0.3s ease;
                }
                @keyframes modalAppear {
                    from { opacity: 0; transform: scale(0.9); }
                    to { opacity: 1; transform: scale(1); }
                }
                .modal-header {
                    display: flex;
                    justify-content: space-between;
                    align-items: center;
                    padding: 1.5rem;
                    border-bottom: 1px solid var(--border-color);
                }
                .modal-header h3 {
                    color: var(--accent-cyan);
                    margin: 0;
                }
                .modal-close {
                    background: none;
                    border: none;
                    color: var(--text-secondary);
                    font-size: 1.5rem;
                    cursor: pointer;
                    padding: 0.5rem;
                    border-radius: 0.25rem;
                    transition: all 0.3s ease;
                }
                .modal-close:hover {
                    background: rgba(255, 255, 255, 0.1);
                    color: var(--text-primary);
                }
                .modal-body {
                    padding: 1.5rem;
                }
                .modal-body p {
                    line-height: 1.6;
                    margin-bottom: 1rem;
                }
                .modal-formula {
                    background: rgba(255, 255, 255, 0.05);
                    padding: 1rem;
                    border-radius: 0.5rem;
                    border-left: 4px solid var(--accent-cyan);
                }
                .modal-formula code {
                    font-size: 1.1rem;
                    color: var(--accent-cyan);
                }
            `;
                        document.head.appendChild(style);

                        document.body.appendChild(modal);
                    },

                        // ===== 步进动画设置 =====
                        setupStepAnimation: function() {
                        // 步骤点击
                        document.querySelectorAll('.step-dot').forEach(dot => {
                        dot.addEventListener('click', () => {
                        this.state.currentStep = parseInt(dot.getAttribute('data-step'));
                        this.updateStep();
                    });
                    });

                        // 导航按钮
                        const prevBtn = document.getElementById('prevStep');
                        const nextBtn = document.getElementById('nextStep');

                        if (prevBtn) {
                        prevBtn.addEventListener('click', () => {
                        if (this.state.currentStep > 0) {
                        this.state.currentStep--;
                        this.updateStep();
                    }
                    });
                    }

                        if (nextBtn) {
                        nextBtn.addEventListener('click', () => {
                        if (this.state.currentStep < this.state.totalSteps - 1) {
                        this.state.currentStep++;
                        this.updateStep();
                    }
                    });
                    }
                    },

                        // ===== 步骤更新 =====
                        updateStep: function() {
                        // 更新步骤指示器
                        document.querySelectorAll('.step-dot').forEach((dot, index) => {
                        dot.classList.toggle('active', index === this.state.currentStep);
                    });

                        // 更新步骤内容
                        document.querySelectorAll('.step-visual').forEach((visual, index) => {
                        visual.classList.toggle('active', index === this.state.currentStep);
                    });

                        // 更新按钮状态
                        const prevBtn = document.getElementById('prevStep');
                        const nextBtn = document.getElementById('nextStep');

                        if (prevBtn) prevBtn.disabled = this.state.currentStep === 0;
                        if (nextBtn) nextBtn.disabled = this.state.currentStep === this.state.totalSteps - 1;
                    },

                        // ===== 代码层切换设置 =====
                        setupCodeLayerTabs: function() {
                        document.querySelectorAll('.code-layer-tab').forEach(tab => {
                        tab.addEventListener('click', function() {
                        const layer = this.getAttribute('data-layer');

                        // 更新标签状态
                        document.querySelectorAll('.code-layer-tab').forEach(t => t.classList.remove('active'));
                        this.classList.add('active');

                        // 更新内容显示
                        document.querySelectorAll('.code-layer-content').forEach(content => {
                        if (content.getAttribute('data-layer-content') === layer) {
                        content.classList.add('active');
                    } else {
                        content.classList.remove('active');
                    }
                    });
                    });
                    });
                    },

                        // ===== 思考题交互设置 =====
                        setupThinkingQuestions: function() {
                        document.querySelectorAll('.think-option').forEach(option => {
                        option.addEventListener('click', function() {
                        const answer = this.getAttribute('data-answer');
                        const thinkCard = this.closest('.think-card');
                        const feedbackId = thinkCard.querySelector('.think-feedback').id;

                        // 移除其他选项的选中状态
                        this.parentElement.querySelectorAll('.think-option').forEach(opt => {
                        opt.classList.remove('selected');
                    });

                        // 添加选中状态
                        this.classList.add('selected');

                        // 显示反馈
                        window.lstmTutorial.showThinkFeedback(feedbackId, answer);
                    });
                    });
                    },

                        // ===== 思考题反馈 =====
                        showThinkFeedback: function(feedbackId, answer) {
                        const feedbackElement = document.getElementById(feedbackId);
                        const feedbacks = {
                        'thinkFeedback1': {
                        'a': { correct: false, text: '速度确实是个问题，但不是RNN失败的主要原因。RNN的计算虽然不能并行化，但这不是导致长序列建模失败的根本原因。' },
                        'b': { correct: true, text: '🎯 完全正确！梯度消失/爆炸是RNN处理长序列失败的根本原因。当序列很长时，梯度会指数级衰减，使得网络无法学习到长距离的依赖关系。LSTM正是为了解决这个问题而设计的。' },
                        'c': { correct: false, text: 'RNN的参数量其实相对较少，这不是主要问题。相比之下，现代的Transformer模型参数量更大，但性能更好。' },
                        'd': { correct: false, text: '激活函数的选择确实会影响性能，但即使使用最优的激活函数，RNN仍然无法根本解决梯度消失问题。' }
                    },
                        'thinkFeedback2': {
                        'a': { correct: false, text: '增加模型容量不是主要目的。实际上，分离设计有时会增加计算复杂度。' },
                        'b': { correct: true, text: '🎯 正确！分离"什么"（候选值C̃_t）和"多少"（权重i_t）让网络可以更精确地控制信息流。这就像是分别决定"要存储的内容"和"存储的重要程度"，提供了更细粒度的控制。' },
                        'c': { correct: false, text: '实际上这样的设计增加了计算量，需要计算两个独立的向量。' },
                        'd': { correct: false, text: '虽然有一定的生物学合理性，但主要还是为了更好的信息控制能力。' }
                    }
                    };

                        const feedback = feedbacks[feedbackId]?.[answer];
                        if (feedback) {
                        feedbackElement.innerHTML = `
                    <div style="padding: 1rem; background: ${feedback.correct ? 'rgba(34, 197, 94, 0.1)' : 'rgba(239, 68, 68, 0.1)'}; border-radius: 0.5rem; border-left: 4px solid ${feedback.correct ? 'var(--accent-green)' : 'var(--accent-red)'};">
                        <p style="font-weight: bold; color: ${feedback.correct ? 'var(--accent-green)' : 'var(--accent-red)'}; margin-bottom: 0.5rem;">
                            ${feedback.correct ? '✅ 正确！' : '❌ 不太对哦'}
                        </p>
                        <p style="line-height: 1.6;">${feedback.text}</p>
                    </div>
                `;
                        feedbackElement.classList.add('show');
                    }
                    },

                        // ===== 实时演示设置 =====
                        setupLiveDemo: function() {
                        const input = document.getElementById('sentimentInput');
                        const analyzeBtn = document.getElementById('analyzeBtn');
                        const predictionPreview = document.getElementById('predictionPreview');

                        if (input) {
                        // 设置保存的用户输入
                        input.value = this.state.savedUserInput;

                        // 实时输入预测
                        let timeoutId;
                        input.addEventListener('input', (e) => {
                        this.state.currentInputText = e.target.value;

                        // 保存用户输入
                        localStorage.setItem('lstm-tutorial-input', e.target.value);

                        // 防抖处理
                        clearTimeout(timeoutId);
                        timeoutId = setTimeout(() => {
                        this.showNextCharPrediction(e.target.value);
                    }, 300);
                    });

                        // 焦点事件
                        input.addEventListener('focus', () => {
                        if (predictionPreview) {
                        predictionPreview.style.display = 'block';
                    }
                    });

                        input.addEventListener('blur', () => {
                        setTimeout(() => {
                        if (predictionPreview) {
                        predictionPreview.style.display = 'none';
                    }
                    }, 200);
                    });
                    }

                        if (analyzeBtn) {
                        analyzeBtn.addEventListener('click', async () => {
                        await this.analyzeSentiment();
                    });
                    }
                    },

                        // ===== 下一字符预测 =====
                        showNextCharPrediction: function(text) {
                        const predictionPreview = document.getElementById('predictionPreview');
                        if (!predictionPreview || !text.trim()) return;

                        // 简单的下一字符预测逻辑
                        const predictions = this.predictNextChar(text);

                        if (predictions.length > 0) {
                        const input = document.getElementById('sentimentInput');
                        const rect = input.getBoundingClientRect();

                        predictionPreview.style.left = (rect.left + text.length * 8) + 'px';
                        predictionPreview.style.top = (rect.top - 40) + 'px';
                        predictionPreview.innerHTML = `
                    <div style="font-size: 0.9rem;">
                        <div style="color: var(--accent-cyan); margin-bottom: 0.25rem;">可能的下一个字：</div>
                        ${predictions.map(p => `<span style="margin-right: 0.5rem; color: var(--accent-green);">${p}</span>`).join('')}
                    </div>
                `;
                        predictionPreview.style.display = 'block';
                    }
                    },

                        // ===== 预测下一个字符 =====
                        predictNextChar: function(text) {
                        // 简化的规则基预测
                        const patterns = {
                        '这个': ['产品', '东西', '想法'],
                        '太': ['棒了', '好了', '差了'],
                        '我': ['很', '非常', '觉得'],
                        '很': ['好', '棒', '喜欢'],
                        '非常': ['好', '棒', '满意'],
                        '不': ['错', '好', '行']
                    };

                        // 获取最后几个字符
                        const lastChars = text.slice(-2);
                        return patterns[lastChars] || patterns[text.slice(-1)] || ['好', '的', '了'];
                    },

                        // ===== 情感分析 =====
                        analyzeSentiment: async function() {
                        const input = document.getElementById('sentimentInput');
                        const btn = document.getElementById('analyzeBtn');

                        if (!input || !btn) return;

                        const text = input.value.trim();
                        if (!text) {
                        alert('请输入一些文字进行分析！');
                        return;
                    }

                        // 添加加载动画
                        btn.innerHTML = '<span class="loading"></span> 分析中...';
                        btn.disabled = true;

                        // 模拟处理延迟
                        await new Promise(resolve => setTimeout(resolve, 1500));

                        // 执行分析
                        const result = this.performSentimentAnalysis(text);
                        this.updatePredictionResult(result);
                        this.drawGateActivations(text);
                        this.drawCellStateChart();
                        this.drawHiddenStateChart();

                        // 实时联动：高亮相关公式部分
                        this.triggerFormulaHighlight();

                        // 恢复按钮
                        btn.innerHTML = '分析情感 ✨';
                        btn.disabled = false;
                    },

                        // ===== 执行情感分析 =====
                        performSentimentAnalysis: function(text) {
                        // 情感词典
                        const positiveWords = ['棒', '好', '喜欢', '优秀', '推荐', '满意', '完美', '赞', '太好了', '不错', '很棒', '喜爱', '厉害'];
                        const negativeWords = ['差', '糟', '失望', '不好', '垃圾', '讨厌', '糟糕', '烂', '太差', '不行', '不满', '讨厌'];
                        const neutralWords = ['还行', '一般', '普通', '凑合', '还可以'];

                        let score = 0.5; // 基础分数
                        let wordCount = 0;

                        // 分析正面词汇
                        positiveWords.forEach(word => {
                        const count = (text.match(new RegExp(word, 'g')) || []).length;
                        score += count * 0.15;
                        wordCount += count;
                    });

                        // 分析负面词汇
                        negativeWords.forEach(word => {
                        const count = (text.match(new RegExp(word, 'g')) || []).length;
                        score -= count * 0.2;
                        wordCount += count;
                    });

                        // 分析中性词汇
                        neutralWords.forEach(word => {
                        const count = (text.match(new RegExp(word, 'g')) || []).length;
                        score += count * 0.02;
                        wordCount += count;
                    });

                        // 文本长度影响
                        if (text.length > 10) score += 0.05;
                        if (text.includes('！') || text.includes('!')) score += 0.1;
                        if (text.includes('？') || text.includes('?')) score -= 0.05;

                        // 确保分数在合理范围内
                        score = Math.max(0.1, Math.min(0.9, score));

                        return {
                        score: score,
                        confidence: Math.min(0.95, 0.6 + wordCount * 0.1),
                        wordCount: wordCount,
                        textLength: text.length
                    };
                    },

                        // ===== 更新预测结果 =====
                        updatePredictionResult: function(result) {
                        const resultDiv = document.getElementById('predictionResult');
                        if (!resultDiv) return;

                        const isPositive = result.score > 0.5;
                        const sentiment = isPositive ? '正面情感' : '负面情感';
                        const emoji = isPositive ? '😊' : '😔';
                        const color = isPositive ? 'var(--accent-green)' : 'var(--accent-red)';

                        resultDiv.innerHTML = `
                <div style="font-size: 4rem; margin-bottom: 1rem;">${emoji}</div>
                <div style="font-size: 1.5rem; font-weight: bold; color: ${color}; margin-bottom: 0.5rem;">
                    ${sentiment}
                </div>
                <div style="font-size: 1.2rem; color: var(--text-secondary); margin-bottom: 1rem;">
                    置信度：${Math.round(result.confidence * 100)}%
                </div>
                <div style="margin-top: 1.5rem;">
                    <div style="background: rgba(255, 255, 255, 0.1); border-radius: 0.5rem; height: 20px; overflow: hidden;">
                        <div style="height: 100%; width: ${result.confidence * 100}%; background: ${color}; transition: width 0.8s ease; border-radius: 0.5rem;"></div>
                    </div>
                </div>
                <div style="margin-top: 1rem; font-size: 0.9rem; color: var(--text-muted);">
                    分析了 ${result.textLength} 个字符，识别出 ${result.wordCount} 个情感词汇
                </div>
            `;
                    },

                        // ===== 公式联动高亮 =====
                        triggerFormulaHighlight: function() {
                        // 依次高亮各个门的公式
                        const symbols = ['f_t', 'i_t', 'o_t'];
                        let index = 0;

                        const highlightNext = () => {
                        if (index < symbols.length) {
                        this.highlightSymbol(symbols[index], true);
                        setTimeout(() => {
                        this.highlightSymbol(symbols[index], false);
                        index++;
                        setTimeout(highlightNext, 200);
                    }, 800);
                    }
                    };

                        setTimeout(highlightNext, 500);
                    },

                        // ===== 绘制门激活图 =====
                        drawGateActivations: function(text = '') {
                        const canvas = document.getElementById('gateChart');
                        if (!canvas) return;

                        const ctx = canvas.getContext('2d');
                        canvas.width = 400;
                        canvas.height = 250;

                        // 清空画布
                        ctx.clearRect(0, 0, canvas.width, canvas.height);

                        // 根据文本内容模拟门激活值
                        const sentiment = this.performSentimentAnalysis(text);
                        const gates = {
                        '遗忘门': 0.3 + Math.random() * 0.4, // 遗忘不重要信息
                        '输入门': 0.6 + Math.random() * 0.3, // 接受新信息
                        '输出门': Math.max(0.4, sentiment.score) + Math.random() * 0.2 // 基于情感输出
                    };

                        const colors = ['#f5576c', '#4facfe', '#43e97b'];
                        const labels = Object.keys(gates);
                        const values = Object.values(gates);

                        // 绘制动画柱状图
                        const barWidth = 80;
                        const spacing = 40;
                        const startX = (canvas.width - (barWidth * 3 + spacing * 2)) / 2;

                        values.forEach((value, i) => {
                        const x = startX + i * (barWidth + spacing);
                        const maxHeight = 150;
                        const height = value * maxHeight;
                        const y = canvas.height - height - 60;

                        // 绘制柱子（带动画效果）
                        const gradient = ctx.createLinearGradient(0, y, 0, y + height);
                        gradient.addColorStop(0, colors[i]);
                        gradient.addColorStop(1, colors[i] + '80');

                        ctx.fillStyle = gradient;
                        ctx.fillRect(x, y, barWidth, height);

                        // 绘制边框
                        ctx.strokeStyle = colors[i];
                        ctx.lineWidth = 2;
                        ctx.strokeRect(x, y, barWidth, height);

                        // 绘制标签
                        ctx.fillStyle = '#f1f5f9';
                        ctx.font = 'bold 14px Arial';
                        ctx.textAlign = 'center';
                        ctx.fillText(labels[i], x + barWidth/2, canvas.height - 35);

                        // 绘制数值
                        ctx.fillStyle = colors[i];
                        ctx.font = 'bold 16px Arial';
                        ctx.fillText((value * 100).toFixed(0) + '%', x + barWidth/2, y - 10);
                    });

                        // 绘制网格线
                        ctx.strokeStyle = 'rgba(255, 255, 255, 0.1)';
                        ctx.lineWidth = 1;
                        for (let i = 0; i <= 5; i++) {
                        const y = canvas.height - 60 - (i * 30);
                        ctx.beginPath();
                        ctx.moveTo(startX - 10, y);
                        ctx.lineTo(startX + barWidth * 3 + spacing * 2 + 10, y);
                        ctx.stroke();
                    }
                    },

                        // ===== 绘制细胞状态图 =====
                        drawCellStateChart: function() {
                        const canvas = document.getElementById('cellStateChart');
                        if (!canvas) return;

                        const ctx = canvas.getContext('2d');
                        canvas.width = canvas.offsetWidth || 300;
                        canvas.height = 200;

                        // 清空画布
                        ctx.clearRect(0, 0, canvas.width, canvas.height);

                        // 模拟细胞状态变化
                        const steps = 20;
                        const values = [];
                        let current = 0;

                        for (let i = 0; i < steps; i++) {
                        // 添加一些趋势和随机变化
                        const trend = Math.sin(i * 0.3) * 0.3;
                        const noise = (Math.random() - 0.5) * 0.2;
                        current = current * 0.7 + trend + noise;
                        values.push(current);
                    }

                        // 绘制折线图
                        const stepWidth = canvas.width / steps;
                        const midY = canvas.height / 2;
                        const scale = 60;

                        // 背景网格
                        ctx.strokeStyle = 'rgba(255, 255, 255, 0.1)';
                        ctx.lineWidth = 1;
                        for (let i = 0; i <= 4; i++) {
                        const y = (canvas.height / 4) * i;
                        ctx.beginPath();
                        ctx.moveTo(0, y);
                        ctx.lineTo(canvas.width, y);
                        ctx.stroke();
                    }

                        // 绘制细胞状态线
                        ctx.strokeStyle = '#fa709a';
                        ctx.lineWidth = 3;
                        ctx.beginPath();

                        values.forEach((value, i) => {
                        const x = i * stepWidth;
                        const y = midY - value * scale;

                        if (i === 0) {
                        ctx.moveTo(x, y);
                    } else {
                        ctx.lineTo(x, y);
                    }

                        // 绘制数据点
                        ctx.save();
                        ctx.fillStyle = '#fa709a';
                        ctx.beginPath();
                        ctx.arc(x, y, 3, 0, 2 * Math.PI);
                        ctx.fill();
                        ctx.restore();
                    });

                        ctx.stroke();

                        // 绘制基准线
                        ctx.strokeStyle = 'rgba(255, 255, 255, 0.3)';
                        ctx.lineWidth = 1;
                        ctx.setLineDash([5, 5]);
                        ctx.beginPath();
                        ctx.moveTo(0, midY);
                        ctx.lineTo(canvas.width, midY);
                        ctx.stroke();
                        ctx.setLineDash([]);

                        // 标签
                        ctx.fillStyle = '#f1f5f9';
                        ctx.font = '12px Arial';
                        ctx.fillText('时间 →', canvas.width - 50, canvas.height - 10);
                        ctx.save();
                        ctx.translate(15, canvas.height / 2);
                        ctx.rotate(-Math.PI / 2);
                        ctx.fillText('细胞状态值', 0, 0);
                        ctx.restore();
                    },

                        // ===== 绘制隐藏状态热图 =====
                        drawHiddenStateChart: function() {
                        const canvas = document.getElementById('hiddenStateChart');
                        if (!canvas) return;

                        const ctx = canvas.getContext('2d');
                        canvas.width = canvas.offsetWidth || 300;
                        canvas.height = 200;

                        // 清空画布
                        ctx.clearRect(0, 0, canvas.width, canvas.height);

                        // 模拟隐藏状态热图
                        const width = 24;
                        const height = 12;
                        const cellWidth = canvas.width / width;
                        const cellHeight = canvas.height / height;

                        for (let i = 0; i < width; i++) {
                        for (let j = 0; j < height; j++) {
                        const value = Math.random();

                        // 使用更丰富的颜色映射
                        let r, g, b;
                        if (value > 0.7) {
                        // 高激活 - 红色
                        r = Math.floor(255 * value);
                        g = Math.floor(100 * (1 - value));
                        b = Math.floor(100 * (1 - value));
                    } else if (value > 0.3) {
                        // 中等激活 - 蓝色
                        r = Math.floor(100 * value);
                        g = Math.floor(150 * value);
                        b = Math.floor(255 * value);
                    } else {
                        // 低激活 - 绿色
                        r = Math.floor(100 * value);
                        g = Math.floor(200 * value);
                        b = Math.floor(150 * value);
                    }

                        ctx.fillStyle = `rgb(${r}, ${g}, ${b})`;
                        ctx.fillRect(i * cellWidth, j * cellHeight, cellWidth - 1, cellHeight - 1);
                    }
                    }

                        // 添加标签
                        ctx.fillStyle = '#f1f5f9';
                        ctx.font = '10px Arial';
                        ctx.fillText('隐藏层维度 →', canvas.width - 80, canvas.height - 5);
                        ctx.save();
                        ctx.translate(5, 20);
                        ctx.rotate(-Math.PI / 2);
                        ctx.fillText('时间步', 0, 0);
                        ctx.restore();
                    },

                        // ===== 钢琴键盘设置 =====
                        setupPianoKeyboard: function() {
                        const keyboard = document.getElementById('pianoKeyboard');
                        if (!keyboard) return;

                        // 清空现有内容
                        keyboard.innerHTML = '';

                        // 创建钢琴键
                        const whiteKeys = ['C', 'D', 'E', 'F', 'G', 'A', 'B'];
                        const blackKeys = ['C#', 'D#', null, 'F#', 'G#', 'A#', null];

                        for (let octave = 4; octave <= 5; octave++) {
                        for (let i = 0; i < whiteKeys.length; i++) {
                        // 白键
                        const whiteKey = document.createElement('div');
                        whiteKey.className = 'piano-key';
                        whiteKey.dataset.note = whiteKeys[i] + octave;
                        whiteKey.addEventListener('click', () => {
                        this.playNote(whiteKeys[i] + octave);
                    });
                        keyboard.appendChild(whiteKey);

                        // 黑键
                        if (blackKeys[i]) {
                        const blackKey = document.createElement('div');
                        blackKey.className = 'piano-key black';
                        blackKey.dataset.note = blackKeys[i] + octave;
                        blackKey.addEventListener('click', () => {
                        this.playNote(blackKeys[i] + octave);
                    });
                        keyboard.appendChild(blackKey);
                    }
                    }
                    }
                    },

                        // ===== 播放音符 =====
                        playNote: function(note) {
                        // 音符到频率的映射
                        const noteFreq = {
                        'C4': 261.63, 'C#4': 277.18, 'D4': 293.66, 'D#4': 311.13,
                        'E4': 329.63, 'F4': 349.23, 'F#4': 369.99, 'G4': 392.00,
                        'G#4': 415.30, 'A4': 440.00, 'A#4': 466.16, 'B4': 493.88,
                        'C5': 523.25, 'C#5': 554.37, 'D5': 587.33, 'D#5': 622.25,
                        'E5': 659.25, 'F5': 698.46, 'F#5': 739.99, 'G5': 783.99,
                        'G#5': 830.61, 'A5': 880.00, 'A#5': 932.33, 'B5': 987.77
                    };

                        const freq = noteFreq[note];
                        if (!freq) return;

                        // 添加到种子旋律
                        this.state.seedMelody.push(note);
                        this.updateSeedMelodyDisplay();

                        // 高亮按键
                        const key = document.querySelector(`[data-note="${note}"]`);
                        if (key) {
                        key.classList.add('active');
                        setTimeout(() => {
                        key.classList.remove('active');
                    }, 200);
                    }

                        // 使用Web Audio API播放音符
                        this.playSynthNote(freq);
                    },

                        // ===== 合成音频播放 =====
                        playSynthNote: function(frequency) {
                        if (!window.AudioContext && !window.webkitAudioContext) return;

                        const audioContext = new (window.AudioContext || window.webkitAudioContext)();
                        const oscillator = audioContext.createOscillator();
                        const gainNode = audioContext.createGain();

                        oscillator.connect(gainNode);
                        gainNode.connect(audioContext.destination);

                        oscillator.frequency.setValueAtTime(frequency, audioContext.currentTime);
                        oscillator.type = 'sine';

                        gainNode.gain.setValueAtTime(0.3, audioContext.currentTime);
                        gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.5);

                        oscillator.start(audioContext.currentTime);
                        oscillator.stop(audioContext.currentTime + 0.5);
                    },

                        // ===== 更新种子旋律显示 =====
                        updateSeedMelodyDisplay: function() {
                        const display = document.getElementById('seedMelody');
                        if (display) {
                        if (this.state.seedMelody.length === 0) {
                        display.textContent = '[]';
                    } else {
                        display.textContent = `[${this.state.seedMelody.join(', ')}]`;
                    }
                    }
                    },

                        // ===== 清空旋律 =====
                        clearMelody: function() {
                        this.state.seedMelody = [];
                        this.updateSeedMelodyDisplay();
                    },

                        // ===== 从种子生成旋律 =====
                        generateFromSeed: function() {
                        if (this.state.seedMelody.length === 0) {
                        alert('请先在钢琴上输入一些音符作为种子旋律！');
                        return;
                    }

                        // 基于种子生成更长的旋律
                        const generatedMelody = this.extendMelody(this.state.seedMelody);
                        this.visualizeMelody(generatedMelody, '种子续写');
                    },

                        // ===== 扩展旋律 =====
                        extendMelody: function(seed) {
                        const allNotes = ['C4', 'D4', 'E4', 'F4', 'G4', 'A4', 'B4', 'C5', 'D5', 'E5', 'F5', 'G5'];
                        const extended = [...seed];

                        // 简单的马尔可夫链生成
                        for (let i = 0; i < 8; i++) {
                        const lastNote = extended[extended.length - 1];
                        const lastIndex = allNotes.indexOf(lastNote);

                        if (lastIndex !== -1) {
                        // 倾向于选择相邻的音符
                        const choices = [
                        lastIndex - 1,
                        lastIndex,
                        lastIndex + 1,
                        lastIndex + 2
                        ].filter(idx => idx >= 0 && idx < allNotes.length);

                        const nextIndex = choices[Math.floor(Math.random() * choices.length)];
                        extended.push(allNotes[nextIndex]);
                    } else {
                        extended.push(allNotes[Math.floor(Math.random() * allNotes.length)]);
                    }
                    }

                        return extended;
                    },

                        // ===== 生成预设旋律 =====
                        generateMelody: function(mood) {
                        const melodyPatterns = {
                        happy: ['C4', 'E4', 'G4', 'C5', 'G4', 'E4', 'C4', 'E4', 'G4', 'C5'],
                        sad: ['A4', 'F4', 'D4', 'F4', 'A4', 'G4', 'F4', 'E4', 'D4', 'C4'],
                        energetic: ['C4', 'C4', 'G4', 'G4', 'A4', 'A4', 'G4', 'F4', 'F4', 'E4'],
                        calm: ['C4', 'D4', 'E4', 'F4', 'E4', 'D4', 'C4', 'D4', 'E4', 'C4']
                    };

                        const melody = melodyPatterns[mood] || melodyPatterns.happy;
                        this.visualizeMelody(melody, this.getMoodTitle(mood));
                    },

                        // ===== 获取情绪标题 =====
                        getMoodTitle: function(mood) {
                        const titles = {
                        happy: '😊 欢快旋律',
                        sad: '😢 忧伤旋律',
                        energetic: '⚡ 激昂旋律',
                        calm: '🌊 平静旋律'
                    };
                        return titles[mood] || '🎵 生成旋律';
                    },

                        // ===== 可视化旋律 =====
                        visualizeMelody: function(melody, title = '生成的旋律') {
                        const canvas = document.getElementById('musicCanvas');
                        if (!canvas) return;

                        const ctx = canvas.getContext('2d');
                        canvas.width = canvas.offsetWidth || 800;
                        canvas.height = 300;

                        // 清空画布
                        ctx.clearRect(0, 0, canvas.width, canvas.height);

                        if (melody.length === 0) return;

                        // 音符映射到Y坐标
                        const noteToY = {
                        'C4': 250, 'C#4': 240, 'D4': 230, 'D#4': 220, 'E4': 210,
                        'F4': 200, 'F#4': 190, 'G4': 180, 'G#4': 170, 'A4': 160,
                        'A#4': 150, 'B4': 140, 'C5': 130, 'C#5': 120, 'D5': 110,
                        'D#5': 100, 'E5': 90, 'F5': 80, 'F#5': 70, 'G5': 60
                    };

                        const noteWidth = canvas.width / melody.length;

                        // 绘制五线谱背景
                        ctx.strokeStyle = 'rgba(255, 255, 255, 0.2)';
                        ctx.lineWidth = 1;
                        for (let i = 0; i < 5; i++) {
                        const y = 160 + i * 20;
                        ctx.beginPath();
                        ctx.moveTo(0, y);
                        ctx.lineTo(canvas.width, y);
                        ctx.stroke();
                    }

                        // 绘制标题
                        ctx.fillStyle = '#f1f5f9';
                        ctx.font = 'bold 18px Arial';
                        ctx.textAlign = 'center';
                        ctx.fillText(title, canvas.width / 2, 30);

                        // 绘制音符
                        melody.forEach((note, i) => {
                        const x = i * noteWidth + noteWidth / 2;
                        const y = noteToY[note] || 160;

                        // 绘制音符
                        ctx.beginPath();
                        ctx.arc(x, y, 8, 0, 2 * Math.PI);
                        ctx.fillStyle = this.getNoteColor(note);
                        ctx.fill();
                        ctx.strokeStyle = 'white';
                        ctx.lineWidth = 2;
                        ctx.stroke();

                        // 连接线
                        if (i > 0) {
                        const prevY = noteToY[melody[i-1]] || 160;
                        ctx.beginPath();
                        ctx.moveTo((i-1) * noteWidth + noteWidth / 2, prevY);
                        ctx.lineTo(x, y);
                        ctx.strokeStyle = this.getNoteColor(note);
                        ctx.lineWidth = 3;
                        ctx.stroke();
                    }

                        // 音符标签
                        ctx.fillStyle = 'white';
                        ctx.font = '10px Arial';
                        ctx.textAlign = 'center';
                        ctx.fillText(note, x, y + 25);
                    });

                        // 播放旋律
                        this.playMelody(melody);
                    },

                        // ===== 获取音符颜色 =====
                        getNoteColor: function(note) {
                        const colors = {
                        'C': '#ff4757', 'D': '#ff6b7a', 'E': '#ffa502',
                        'F': '#ffda79', 'G': '#7bed9f', 'A': '#5352ed',
                        'B': '#a4b0be'
                    };
                        return colors[note[0]] || '#70a1ff';
                    },

                        // ===== 播放旋律 =====
                        playMelody: function(melody) {
                        if (!melody || melody.length === 0) return;

                        melody.forEach((note, index) => {
                        setTimeout(() => {
                        this.playNote(note);
                    }, index * 400);
                    });
                    },

                        // ===== 主题控制设置 =====
                        setupThemeControls: function() {
                        const themeToggle = document.getElementById('toggle-theme');
                        const animationToggle = document.getElementById('toggle-animations');

                        if (themeToggle) {
                        themeToggle.addEventListener('click', () => {
                        document.body.classList.toggle('light-theme');
                        // 可以在这里添加更多主题切换逻辑
                    });
                    }

                        if (animationToggle) {
                        animationToggle.addEventListener('click', () => {
                        this.state.animationsEnabled = !this.state.animationsEnabled;
                        document.body.style.setProperty('--animation-duration',
                        this.state.animationsEnabled ? '0.3s' : '0s');

                        animationToggle.innerHTML = this.state.animationsEnabled ?
                        '<svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><circle cx="12" cy="12" r="10"></circle><path d="M10 8l6 4-6 4V8z"></path></svg>' :
                        '<svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><circle cx="12" cy="12" r="10"></circle><rect x="9" y="9" width="6" height="6"></rect></svg>';
                    });
                    }
                    },

                        // ===== 梯度消失动画 =====
                        animateGradientVanishing: function() {
                        const canvas = document.getElementById('gradientVanishingCanvas');
                        if (!canvas) return;

                        const ctx = canvas.getContext('2d');
                        canvas.width = 900;
                        canvas.height = 300;

                        let step = 0;
                        const totalSteps = 20;

                        const animate = () => {
                        ctx.clearRect(0, 0, canvas.width, canvas.height);

                        // 绘制标题
                        ctx.fillStyle = '#f1f5f9';
                        ctx.font = 'bold 16px Arial';
                        ctx.textAlign = 'center';
                        ctx.fillText('RNN梯度传播：每层衰减90%', canvas.width / 2, 30);

                        // 绘制时间步
                        const stepWidth = canvas.width / totalSteps;

                        for (let i = 0; i <= step; i++) {
                        const x = i * stepWidth;
                        const gradientStrength = Math.pow(0.9, i); // 每步衰减90%

                        // 绘制梯度强度条
                        const barHeight = gradientStrength * 200;
                        ctx.fillStyle = `rgba(239, 68, 68, ${gradientStrength})`;
                        ctx.fillRect(x + 5, 250 - barHeight, stepWidth - 10, barHeight);

                        // 绘制边框
                        ctx.strokeStyle = '#ef4444';
                        ctx.lineWidth = 1;
                        ctx.strokeRect(x + 5, 250 - barHeight, stepWidth - 10, barHeight);

                        // 绘制时间步标签
                        ctx.fillStyle = '#f1f5f9';
                        ctx.font = '12px Arial';
                        ctx.textAlign = 'center';
                        ctx.fillText(`t=${i+1}`, x + stepWidth/2, 275);

                        // 绘制数值
                        ctx.fillStyle = gradientStrength > 0.1 ? '#f1f5f9' : '#ef4444';
                        ctx.font = '10px Arial';
                        ctx.fillText(gradientStrength.toFixed(3), x + stepWidth/2, 150);
                    }

                        // 绘制警告信息
                        if (step >= 10) {
                        ctx.fillStyle = '#ef4444';
                        ctx.font = 'bold 14px Arial';
                        ctx.textAlign = 'center';
                        ctx.fillText('梯度几乎消失！无法学习长期依赖', canvas.width / 2, canvas.height - 20);
                    }

                        step++;
                        if (step <= totalSteps) {
                        setTimeout(animate, 300);
                    }
                    };

                        animate();
                    },

                        // ===== 重置梯度动画 =====
                        resetGradientAnimation: function() {
                        const canvas = document.getElementById('gradientVanishingCanvas');
                        if (!canvas) return;

                        const ctx = canvas.getContext('2d');
                        ctx.clearRect(0, 0, canvas.width, canvas.height);

                        // 绘制初始状态
                        ctx.fillStyle = '#f1f5f9';
                        ctx.font = 'bold 16px Arial';
                        ctx.textAlign = 'center';
                        ctx.fillText('点击"演示梯度消失"按钮开始', canvas.width / 2, canvas.height / 2);
                    },

                        // ===== LSTM单元交互功能 =====
                        highlightForgetGate: function() {
                        this.updateGateDescription('forget', '#f5576c');
                        this.drawLSTMHighlight('forget');
                    },

                        highlightInputGate: function() {
                        this.updateGateDescription('input', '#4facfe');
                        this.drawLSTMHighlight('input');
                    },

                        highlightOutputGate: function() {
                        this.updateGateDescription('output', '#43e97b');
                        this.drawLSTMHighlight('output');
                    },

                        animateDataFlow: function() {
                        this.updateGateDescription('flow', '#a8edea');
                        this.drawLSTMDataFlow();
                    },

                        // ===== 更新门描述 =====
                        updateGateDescription: function(gateType, color) {
                        const descriptions = {
                        forget: {
                        title: '遗忘门 (Forget Gate)',
                        formula: 'f_t = σ(W_f · [h_{t-1}, x_t] + b_f)',
                        description: '遗忘门决定从细胞状态中丢弃什么信息。它查看 h_{t-1} 和 x_t，输出一个 0 到 1 之间的数值给每个细胞状态。1 表示"完全保留"，0 表示"完全丢弃"。这个门让LSTM能够主动遗忘不再重要的历史信息。',
                        keyPoints: ['选择性遗忘过时信息', '输出范围[0,1]', '0=完全遗忘，1=完全保留', 'Sigmoid激活函数']
                    },
                        input: {
                        title: '输入门 (Input Gate)',
                        formula: 'i_t = σ(W_i · [h_{t-1}, x_t] + b_i)',
                        description: '输入门决定什么新信息要存储到细胞状态中。它包含两部分：sigmoid 层决定哪些值要更新，tanh 层创建新的候选值向量。两者结合实现选择性的信息存储。',
                        keyPoints: ['控制新信息的重要性', '与候选值配合工作', '实现选择性更新', '防止信息过载']
                    },
                        output: {
                        title: '输出门 (Output Gate)',
                        formula: 'o_t = σ(W_o · [h_{t-1}, x_t] + b_o)',
                        description: '输出门决定基于细胞状态输出什么。首先运行 sigmoid 层决定细胞状态的哪些部分要输出，然后将细胞状态通过 tanh 并乘以 sigmoid 的输出，得到最终的隐藏状态。',
                        keyPoints: ['控制输出信息', '基于细胞状态过滤', 'tanh压缩到[-1,1]', '产生最终隐藏状态']
                    },
                        flow: {
                        title: '数据流动 (Data Flow)',
                        formula: 'C_t = f_t ⊙ C_{t-1} + i_t ⊙ C̃_t',
                        description: '观察数据如何在LSTM中流动：输入经过三个门的处理，细胞状态在高速公路上线性传播，最终通过输出门产生隐藏状态。这种设计确保了梯度的稳定传播。',
                        keyPoints: ['信息高速公路', '线性细胞状态传播', '三门协同工作', '梯度稳定传播']
                    }
                    };

                        const desc = descriptions[gateType];
                        if (!desc) return;

                        const descriptionDiv = document.getElementById('gateDescription');
                        if (descriptionDiv) {
                        descriptionDiv.innerHTML = `
                    <div style="border-left: 4px solid ${color}; padding-left: 1rem;">
                        <h3 style="color: ${color}; margin-bottom: 1rem; display: flex; align-items: center; gap: 0.5rem;">
                            ${desc.title}
                            <span style="font-size: 0.8rem; background: rgba(255,255,255,0.1); padding: 0.25rem 0.5rem; border-radius: 0.25rem;">实时分析</span>
                        </h3>
                        <div style="background: rgba(255, 255, 255, 0.05); padding: 1rem; border-radius: 0.5rem; margin-bottom: 1rem;">
                            <code style="font-size: 1.1rem; color: ${color};">${desc.formula}</code>
                        </div>
                        <p style="line-height: 1.8; margin-bottom: 1rem;">${desc.description}</p>
                        <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 0.5rem;">
                            ${desc.keyPoints.map(point => `
                                <div style="background: rgba(255,255,255,0.05); padding: 0.5rem; border-radius: 0.25rem; font-size: 0.9rem;">
                                    • ${point}
                                </div>
                            `).join('')}
                        </div>
                    </div>
                `;
                    }
                    },

                        // ===== 绘制LSTM高亮 =====
                        drawLSTMHighlight: function(gateType) {
                        const canvas = document.getElementById('lstmCanvas');
                        if (!canvas) return;

                        const ctx = canvas.getContext('2d');
                        canvas.width = canvas.offsetWidth;
                        canvas.height = 500;

                        // 清空画布
                        ctx.clearRect(0, 0, canvas.width, canvas.height);

                        // 绘制基本LSTM结构
                        this.drawBasicLSTMStructure(ctx, canvas.width, canvas.height);

                        // 高亮特定门
                        this.highlightSpecificGate(ctx, canvas.width, canvas.height, gateType);
                    },

                        // ===== 绘制基本LSTM结构 =====
                        drawBasicLSTMStructure: function(ctx, width, height) {
                        // 绘制细胞状态高速公路
                        ctx.strokeStyle = '#a8edea';
                        ctx.lineWidth = 6;
                        ctx.beginPath();
                        ctx.moveTo(50, height/2);
                        ctx.lineTo(width - 50, height/2);
                        ctx.stroke();

                        // 添加箭头
                        this.drawArrow(ctx, width - 80, height/2, width - 50, height/2, '#a8edea');

                        // 绘制细胞状态标签
                        ctx.fillStyle = '#a8edea';
                        ctx.font = 'bold 16px Arial';
                        ctx.textAlign = 'center';
                        ctx.fillText('细胞状态 C_t', width/2, height/2 - 20);

                        // 绘制门的位置
                        const gates = [
                    { name: '遗忘门', x: width * 0.25, y: height * 0.25, color: '#f5576c', symbol: 'f_t' },
                    { name: '输入门', x: width * 0.5, y: height * 0.25, color: '#4facfe', symbol: 'i_t' },
                    { name: '输出门', x: width * 0.75, y: height * 0.75, color: '#43e97b', symbol: 'o_t' }
                        ];

                        gates.forEach(gate => {
                        // 绘制门圆圈
                        ctx.beginPath();
                        ctx.arc(gate.x, gate.y, 35, 0, 2 * Math.PI);
                        ctx.fillStyle = gate.color + '40';
                        ctx.fill();
                        ctx.strokeStyle= gate.color;
                        ctx.lineWidth = 3;
                        ctx.stroke();

                        // 绘制门标签
                        ctx.fillStyle = 'white';
                        ctx.font = 'bold 14px Arial';
                        ctx.textAlign = 'center';
                        ctx.fillText(gate.symbol, gate.x, gate.y + 5);

                        // 绘制门名称
                        ctx.fillStyle = gate.color;
                        ctx.font = '12px Arial';
                        ctx.fillText(gate.name, gate.x, gate.y + 55);
                    });

                        // 绘制输入箭头
                        this.drawArrow(ctx, 50, height * 0.8, width * 0.2, height * 0.6, '#ffffff');
                        ctx.fillStyle = '#ffffff';
                        ctx.font = '14px Arial';
                        ctx.textAlign = 'left';
                        ctx.fillText('x_t', 60, height * 0.8 + 5);

                        // 绘制输出箭头
                        this.drawArrow(ctx, width * 0.8, height * 0.8, width - 50, height * 0.8, '#ffffff');
                        ctx.fillStyle = '#ffffff';
                        ctx.font = '14px Arial';
                        ctx.textAlign = 'right';
                        ctx.fillText('h_t', width - 60, height * 0.8 + 5);
                    },

                        // ===== 绘制箭头 =====
                        drawArrow: function(ctx, fromX, fromY, toX, toY, color) {
                        const headlen = 10;
                        const dx = toX - fromX;
                        const dy = toY - fromY;
                        const angle = Math.atan2(dy, dx);

                        ctx.strokeStyle = color;
                        ctx.fillStyle = color;
                        ctx.lineWidth = 2;

                        // 绘制线段
                        ctx.beginPath();
                        ctx.moveTo(fromX, fromY);
                        ctx.lineTo(toX, toY);
                        ctx.stroke();

                        // 绘制箭头头部
                        ctx.beginPath();
                        ctx.moveTo(toX, toY);
                        ctx.lineTo(toX - headlen * Math.cos(angle - Math.PI / 6), toY - headlen * Math.sin(angle - Math.PI / 6));
                        ctx.lineTo(toX - headlen * Math.cos(angle + Math.PI / 6), toY - headlen * Math.sin(angle + Math.PI / 6));
                        ctx.closePath();
                        ctx.fill();
                    },

                        // ===== 高亮特定门 =====
                        highlightSpecificGate: function(ctx, width, height, gateType) {
                        const gates = {
                        forget: { x: width * 0.25, y: height * 0.25, color: '#f5576c' },
                        input: { x: width * 0.5, y: height * 0.25, color: '#4facfe' },
                        output: { x: width * 0.75, y: height * 0.75, color: '#43e97b' }
                    };

                        const gate = gates[gateType];
                        if (!gate) return;

                        // 绘制高亮效果
                        ctx.shadowColor = gate.color;
                        ctx.shadowBlur = 20;

                        ctx.beginPath();
                        ctx.arc(gate.x, gate.y, 45, 0, 2 * Math.PI);
                        ctx.strokeStyle = gate.color;
                        ctx.lineWidth = 4;
                        ctx.stroke();

                        // 重置阴影
                        ctx.shadowColor = 'transparent';
                        ctx.shadowBlur = 0;

                        // 添加脉冲动画效果
                        let pulse = 0;
                        const pulseAnimation = () => {
                        if (pulse < 20) {
                        ctx.beginPath();
                        ctx.arc(gate.x, gate.y, 45 + pulse * 2, 0, 2 * Math.PI);
                        ctx.strokeStyle = gate.color + Math.floor((1 - pulse / 20) * 255).toString(16).padStart(2, '0');
                        ctx.lineWidth = 2;
                        ctx.stroke();
                        pulse++;
                        requestAnimationFrame(pulseAnimation);
                    }
                    };
                        pulseAnimation();
                    },

                        // ===== 绘制LSTM数据流 =====
                        drawLSTMDataFlow: function() {
                        const canvas = document.getElementById('lstmCanvas');
                        if (!canvas) return;

                        const ctx = canvas.getContext('2d');
                        canvas.width = canvas.offsetWidth;
                        canvas.height = 500;

                        // 清空画布
                        ctx.clearRect(0, 0, canvas.width, canvas.height);

                        // 绘制基本结构
                        this.drawBasicLSTMStructure(ctx, canvas.width, canvas.height);

                        // 动画显示数据流
                        this.animateDataFlowPath(ctx, canvas.width, canvas.height);
                    },

                        // ===== 动画数据流路径 =====
                        animateDataFlowPath: function(ctx, width, height) {
                        const paths = [
                        // 输入到遗忘门
                    { from: { x: width * 0.2, y: height * 0.6 }, to: { x: width * 0.25, y: height * 0.25 }, color: '#f5576c', delay: 0 },
                        // 输入到输入门
                    { from: { x: width * 0.2, y: height * 0.6 }, to: { x: width * 0.5, y: height * 0.25 }, color: '#4facfe', delay: 500 },
                        // 细胞状态更新
                    { from: { x: width * 0.25, y: height * 0.5 }, to: { x: width * 0.5, y: height * 0.5 }, color: '#a8edea', delay: 1000 },
                        // 输出门
                    { from: { x: width * 0.5, y: height * 0.5 }, to: { x: width * 0.75, y: height * 0.75 }, color: '#43e97b', delay: 1500 }
                        ];

                        paths.forEach((path, index) => {
                        setTimeout(() => {
                        this.animatePath(ctx, path.from, path.to, path.color);
                    }, path.delay);
                    });
                    },

                        // ===== 动画路径 =====
                        animatePath: function(ctx, from, to, color) {
                        let progress = 0;
                        const duration = 1000; // 1秒

                        const animate = (timestamp) => {
                        if (!this.startTime) this.startTime = timestamp;
                        progress = (timestamp - this.startTime) / duration;

                        if (progress <= 1) {
                        const currentX = from.x + (to.x - from.x) * progress;
                        const currentY = from.y + (to.y - from.y) * progress;

                        // 绘制流动的点
                        ctx.beginPath();
                        ctx.arc(currentX, currentY, 8, 0, 2 * Math.PI);
                        ctx.fillStyle = color;
                        ctx.shadowColor = color;
                        ctx.shadowBlur = 15;
                        ctx.fill();
                        ctx.shadowColor = 'transparent';
                        ctx.shadowBlur = 0;

                        requestAnimationFrame(animate);
                    } else {
                        this.startTime = null;
                    }
                    };

                        requestAnimationFrame(animate);
                    },

                        // ===== 创建背景动画 =====
                        createBackgroundAnimation: function() {
                        const bgAnimation = document.getElementById('bgAnimation');
                        if (!bgAnimation) return;

                        // 创建浮动粒子
                        for (let i = 0; i < 20; i++) {
                        const particle = document.createElement('div');
                        particle.className = 'bg-particle';
                        particle.style.left = Math.random() * 100 + '%';
                        particle.style.animationDelay = Math.random() * 20 + 's';
                        particle.style.animationDuration = (15 + Math.random() * 10) + 's';
                        bgAnimation.appendChild(particle);
                    }
                    },

                        // ===== 初始化组件 =====
                        initializeComponents: function() {
                        // 初始化语法高亮
                        if (typeof hljs !== 'undefined') {
                        hljs.highlightAll();
                    }

                        // 初始化数学公式渲染
                        if (typeof katex !== 'undefined') {
                        document.querySelectorAll('script[type="math/tex"]').forEach(element => {
                        const math = element.textContent;
                        const rendered = katex.renderToString(math, {
                        displayMode: element.type === 'math/tex; mode=display'
                    });
                        const wrapper = document.createElement('span');
                        wrapper.innerHTML = rendered;
                        element.parentNode.replaceChild(wrapper, element);
                    });
                    }

                        // 初始化图表
                        this.initializeCharts();

                        // 设置默认状态
                        this.updateStep();
                    },

                        // ===== 初始化图表 =====
                        initializeCharts: function() {
                        // 绘制初始的门激活图
                        this.drawGateActivations();

                        // 绘制初始的细胞状态图
                        this.drawCellStateChart();

                        // 绘制初始的隐藏状态图
                        this.drawHiddenStateChart();

                        // 初始化LSTM架构图
                        this.drawLSTMArchitecture();
                        this.drawGRUArchitecture();
                    },

                        // ===== 绘制LSTM架构图 =====
                        drawLSTMArchitecture: function() {
                        const canvas = document.getElementById('lstmArchCanvas');
                        if (!canvas) return;

                        const ctx = canvas.getContext('2d');
                        canvas.width = 300;
                        canvas.height = 200;

                        // 清空画布
                        ctx.clearRect(0, 0, canvas.width, canvas.height);

                        // 绘制LSTM结构简图
                        const centerX = canvas.width / 2;
                        const centerY = canvas.height / 2;

                        // 细胞状态线
                        ctx.strokeStyle = '#a8edea';
                        ctx.lineWidth = 4;
                        ctx.beginPath();
                        ctx.moveTo(20, centerY);
                        ctx.lineTo(280, centerY);
                        ctx.stroke();

                        // 三个门
                        const gates = [
                    { x: centerX - 60, y: centerY - 50, color: '#f5576c', label: 'f' },
                    { x: centerX, y: centerY - 50, color: '#4facfe', label: 'i' },
                    { x: centerX + 60, y: centerY + 50, color: '#43e97b', label: 'o' }
                        ];

                        gates.forEach(gate => {
                        ctx.beginPath();
                        ctx.arc(gate.x, gate.y, 15, 0, 2 * Math.PI);
                        ctx.fillStyle = gate.color;
                        ctx.fill();
                        ctx.strokeStyle = 'white';
                        ctx.lineWidth = 2;
                        ctx.stroke();

                        ctx.fillStyle = 'white';
                        ctx.font = 'bold 12px Arial';
                        ctx.textAlign = 'center';
                        ctx.fillText(gate.label, gate.x, gate.y + 4);
                    });

                        // 标签
                        ctx.fillStyle = '#f1f5f9';
                        ctx.font = '12px Arial';
                        ctx.textAlign = 'center';
                        ctx.fillText('LSTM单元', centerX, 20);
                    },

                        // ===== 绘制GRU架构图 =====
                        drawGRUArchitecture: function() {
                        const canvas = document.getElementById('gruArchCanvas');
                        if (!canvas) return;

                        const ctx = canvas.getContext('2d');
                        canvas.width = 300;
                        canvas.height = 200;

                        // 清空画布
                        ctx.clearRect(0, 0, canvas.width, canvas.height);

                        // 绘制GRU结构简图
                        const centerX = canvas.width / 2;
                        const centerY = canvas.height / 2;

                        // 隐藏状态线
                        ctx.strokeStyle = '#fdbb2d';
                        ctx.lineWidth = 4;
                        ctx.beginPath();
                        ctx.moveTo(20, centerY);
                        ctx.lineTo(280, centerY);
                        ctx.stroke();

                        // 两个门
                        const gates = [
                    { x: centerX - 40, y: centerY - 40, color: '#ff6b7a', label: 'r' },
                    { x: centerX + 40, y: centerY - 40, color: '#4facfe', label: 'z' }
                        ];

                        gates.forEach(gate => {
                        ctx.beginPath();
                        ctx.arc(gate.x, gate.y, 15, 0, 2 * Math.PI);
                        ctx.fillStyle = gate.color;
                        ctx.fill();
                        ctx.strokeStyle = 'white';
                        ctx.lineWidth = 2;
                        ctx.stroke();

                        ctx.fillStyle = 'white';
                        ctx.font = 'bold 12px Arial';
                        ctx.textAlign = 'center';
                        ctx.fillText(gate.label, gate.x, gate.y + 4);
                    });

                        // 标签
                        ctx.fillStyle = '#f1f5f9';
                        ctx.font = '12px Arial';
                        ctx.textAlign = 'center';
                        ctx.fillText('GRU单元', centerX, 20);
                    },

                        // ===== 恢复用户状态 =====
                        restoreUserState: function() {
                        // 恢复用户输入
                        const sentimentInput = document.getElementById('sentimentInput');
                        if (sentimentInput && this.state.savedUserInput) {
                        sentimentInput.value = this.state.savedUserInput;
                        this.state.currentInputText = this.state.savedUserInput;
                    }

                        // 恢复其他用户设置
                        const animationsEnabled = localStorage.getItem('lstm-animations-enabled');
                        if (animationsEnabled !== null) {
                        this.state.animationsEnabled = JSON.parse(animationsEnabled);
                        document.body.style.setProperty('--animation-duration',
                        this.state.animationsEnabled ? '0.3s' : '0s');
                    }
                    },

                        // ===== 工具函数：防抖 =====
                        debounce: function(func, wait) {
                        let timeout;
                        return function executedFunction(...args) {
                        const later = () => {
                        clearTimeout(timeout);
                        func(...args);
                    };
                        clearTimeout(timeout);
                        timeout = setTimeout(later, wait);
                    };
                    },

                        // ===== 工具函数：节流 =====
                        throttle: function(func, limit) {
                        let inThrottle;
                        return function(...args) {
                        if (!inThrottle) {
                        func.apply(this, args);
                        inThrottle = true;
                        setTimeout(() => inThrottle = false, limit);
                    }
                    };
                    },

                        // ===== 错误处理 =====
                        handleError: function(error, context = '') {
                        console.error(`LSTM Tutorial Error ${context}:`, error);

                        // 显示用户友好的错误消息
                        const errorMessage = document.createElement('div');
                        errorMessage.style.cssText = `
                position: fixed;
                top: 20px;
                right: 20px;
                background: #ef4444;
                color: white;
                padding: 1rem 1.5rem;
                border-radius: 0.5rem;
                box-shadow: 0 10px 30px rgba(0, 0, 0, 0.3);
                z-index: 10000;
                animation: slideIn 0.3s ease;
            `;
                        errorMessage.innerHTML = `
                <div style="display: flex; align-items: center; gap: 0.5rem;">
                    <span>⚠️</span>
                    <span>出现了一个小问题，但不影响继续学习</span>
                    <button onclick="this.parentElement.parentElement.remove()" style="background: none; border: none; color: white; font-size: 1.2rem; margin-left: 0.5rem; cursor: pointer;">×</button>
                </div>
            `;

                        document.body.appendChild(errorMessage);

                        // 5秒后自动移除
                        setTimeout(() => {
                        if (errorMessage.parentNode) {
                        errorMessage.remove();
                    }
                    }, 5000);
                    },

                        // ===== 清理函数 =====
                        cleanup: function() {
                        // 清理事件监听器
                        window.removeEventListener('scroll', this.handleScroll);
                        window.removeEventListener('resize', this.handleResize);

                        // 清理动画
                        if (this.animationFrame) {
                        cancelAnimationFrame(this.animationFrame);
                    }

                        // 清理定时器
                        if (this.timers) {
                        this.timers.forEach(timer => clearTimeout(timer));
                    }
                    }
                    };

                        // ===== 全局错误处理 =====
                        window.addEventListener('error', (event) => {
                        window.lstmTutorial.handleError(event.error, 'Global');
                    });

                        // ===== 页面加载完成后初始化 =====
                        if (document.readyState === 'loading') {
                        document.addEventListener('DOMContentLoaded', () => {
                        try {
                        window.lstmTutorial.init();
                    } catch (error) {
                        window.lstmTutorial.handleError(error, 'Initialization');
                    }
                    });
                    } else {
                        try {
                        window.lstmTutorial.init();
                    } catch (error) {
                        window.lstmTutorial.handleError(error, 'Initialization');
                    }
                    }

                        // ===== 页面卸载时清理 =====
                        window.addEventListener('beforeunload', () => {
                        try {
                        window.lstmTutorial.cleanup();
                    } catch (error) {
                        console.error('Cleanup error:', error);
                    }
                    });

                        // ===== 导出模块（可选，用于其他脚本调用） =====
                        if (typeof module !== 'undefined' && module.exports) {
                        module.exports = window.lstmTutorial;
                    }

                    })();

                        // ===== KaTeX数学公式支持 =====
                        document.addEventListener('DOMContentLoaded', function() {
                        // 渲染行内数学公式
                        const inlineMath = document.querySelectorAll('span:not(.katex)');
                        inlineMath.forEach(span => {
                        const text = span.textContent;
                        if (text.includes('$$') && window.katex) {
                        try {
                        const mathText = text.replace(/\$\$(.*?)\$\$/g, '$1');
                        if (mathText !== text) {
                        span.innerHTML = katex.renderToString(mathText, {
                        displayMode: false,
                        throwOnError: false
                    });
                    }
                    } catch (e) {
                        console.warn('KaTeX render error:', e);
                    }
                    }
                    });

                        // 渲染块级数学公式
                        const blockMath = document.querySelectorAll('div:not(.katex-display)');
                        blockMath.forEach(div => {
                        const text = div.textContent;
                        if (text.includes('$$') && window.katex) {
                        try {
                        const mathText = text.replace(/\$\$(.*?)\$\$/g, '$1');
                        if (mathText !== text) {
                        div.innerHTML = katex.renderToString(mathText, {
                        displayMode: true,
                        throwOnError: false
                    });
                    }
                    } catch (e) {
                        console.warn('KaTeX render error:', e);
                    }
                    }
                    });
                    });

                        // ===== 性能监控 =====
                        if (window.performance && window.performance.mark) {
                        window.performance.mark('lstm-tutorial-start');

                        window.addEventListener('load', () => {
                        window.performance.mark('lstm-tutorial-end');
                        window.performance.measure('lstm-tutorial-load', 'lstm-tutorial-start', 'lstm-tutorial-end');

                        const measures = window.performance.getEntriesByName('lstm-tutorial-load');
                        if (measures.length > 0) {
                        console.log(`🚀 LSTM教程加载完成，耗时: ${measures[0].duration.toFixed(2)}ms`);
                    }
                    });
                    }
</script>

<!-- 外部依赖加载 -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.9/katex.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.9/contrib/auto-render.min.js"></script>

<!-- 最终初始化 -->
<script>
    // 确保所有依赖加载完成后再渲染数学公式
    window.addEventListener('load', function() {
        if (window.renderMathInElement) {
            renderMathInElement(document.body, {
                delimiters: [
                    {left: '$$', right: '$$', display: true},
                    {left: '$', right: '$', display: false},
                    {left: '\\(', right: '\\)', display: false},
                    {left: '\\[', right: '\\]', display: true}
                ],
                throwOnError: false
            });
        }

        // 添加加载完成的视觉反馈
        document.body.style.opacity = '1';
        console.log('🎉 LSTM交互式教程已完全加载并准备就绪！');
    });

    // 页面加载进度
    document.body.style.opacity = '0';
    document.body.style.transition = 'opacity 0.5s ease';
</script>

</body>
</html>